{
    "{56BAC6EF-55B0-4A36-B937-9A2AC40C9A0E}": {
        "source": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _index = _interopRequireDefault(require(\"./lib/index.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _default = _index[\"default\"];\nexports[\"default\"] = _default;",
        "mapping": {
            "./lib/index.js": "{D679299D-6D98-4A9A-8BBD-1CFA8798C367}"
        },
        "path": "{remark-parse}/index.js"
    },
    "{D679299D-6D98-4A9A-8BBD-1CFA8798C367}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('mdast').Root} Root\n* @typedef {import('mdast-util-from-markdown').Options} Options\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = remarkParse;\n\nvar _mdastUtilFromMarkdown = require(\"mdast-util-from-markdown\");\n\n/** @type {import('unified').Plugin<[Options?] | void[], string, Root>} */\nfunction remarkParse(options) {\n  var _this = this;\n\n  /** @type {import('unified').ParserFunction<Root>} */\n  var parser = function parser(doc) {\n    // Assume options.\n    var settings =\n    /** @type {Options} */\n    _this.data('settings');\n\n    return (0, _mdastUtilFromMarkdown.fromMarkdown)(doc, Object.assign({}, settings, options, {\n      // Note: these options are not in the readme.\n      // The goal is for them to be set by plugins on `data` instead of being\n      // passed by users.\n      extensions: _this.data('micromarkExtensions') || [],\n      mdastExtensions: _this.data('fromMarkdownExtensions') || []\n    }));\n  };\n\n  Object.assign(this, {\n    Parser: parser\n  });\n}",
        "mapping": {
            "mdast-util-from-markdown": "{AC61B300-E7B9-4B4C-A5EB-B75481C9C919}"
        },
        "path": "{remark-parse}/lib/index.js"
    },
    "{AC61B300-E7B9-4B4C-A5EB-B75481C9C919}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('./lib/index.js').Value} Value\n* @typedef {import('./lib/index.js').Encoding} Encoding\n* @typedef {import('./lib/index.js').Options} Options\n* @typedef {import('./lib/index.js').Extension} Extension\n* @typedef {import('./lib/index.js').Handle} Handle\n* @typedef {import('./lib/index.js').Transform} Transform\n* @typedef {import('./lib/index.js').Token} Token\n* @typedef {import('./lib/index.js').CompileContext} CompileContext\n* @typedef {import('./lib/index.js').OnEnterError} OnEnterError\n* @typedef {import('./lib/index.js').OnExitError} OnExitError\n*\n* @typedef {import('./lib/index.js').OnEnterError} OnError\n*   To do: deprecate next major.\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"fromMarkdown\", {\n  enumerable: true,\n  get: function get() {\n    return _index.fromMarkdown;\n  }\n});\n\nvar _index = require(\"./lib/index.js\");",
        "mapping": {
            "./lib/index.js": "{F43937B9-D470-4CA7-B703-99654D81F8E4}"
        },
        "path": "{remark-parse}/../mdast-util-from-markdown/index.js"
    },
    "{F43937B9-D470-4CA7-B703-99654D81F8E4}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Encoding} Encoding\n* @typedef {import('micromark-util-types').Event} Event\n* @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n* @typedef {import('micromark-util-types').Token} Token\n* @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n* @typedef {import('micromark-util-types').Value} Value\n* @typedef {import('unist').Parent} UnistParent\n* @typedef {import('unist').Point} Point\n* @typedef {import('mdast').PhrasingContent} PhrasingContent\n* @typedef {import('mdast').Content} Content\n* @typedef {Root|Content} Node\n* @typedef {Extract<Node, UnistParent>} Parent\n* @typedef {import('mdast').Break} Break\n* @typedef {import('mdast').Blockquote} Blockquote\n* @typedef {import('mdast').Code} Code\n* @typedef {import('mdast').Definition} Definition\n* @typedef {import('mdast').Emphasis} Emphasis\n* @typedef {import('mdast').Heading} Heading\n* @typedef {import('mdast').HTML} HTML\n* @typedef {import('mdast').Image} Image\n* @typedef {import('mdast').ImageReference} ImageReference\n* @typedef {import('mdast').InlineCode} InlineCode\n* @typedef {import('mdast').Link} Link\n* @typedef {import('mdast').LinkReference} LinkReference\n* @typedef {import('mdast').List} List\n* @typedef {import('mdast').ListItem} ListItem\n* @typedef {import('mdast').Paragraph} Paragraph\n* @typedef {import('mdast').Root} Root\n* @typedef {import('mdast').Strong} Strong\n* @typedef {import('mdast').Text} Text\n* @typedef {import('mdast').ThematicBreak} ThematicBreak\n*\n* @typedef {UnistParent & {type: 'fragment', children: Array<PhrasingContent>}} Fragment\n*/\n\n/**\n * @typedef _CompileDataFields\n * @property {boolean|undefined} expectingFirstListItemValue\n * @property {boolean|undefined} flowCodeInside\n * @property {boolean|undefined} setextHeadingSlurpLineEnding\n * @property {boolean|undefined} atHardBreak\n * @property {'collapsed'|'full'} referenceType\n * @property {boolean|undefined} inReference\n * @property {'characterReferenceMarkerHexadecimal'|'characterReferenceMarkerNumeric'} characterReferenceType\n *\n * @typedef {Record<string, unknown> & Partial<_CompileDataFields>} CompileData\n *\n * @typedef {(tree: Root) => Root|void} Transform\n * @typedef {(this: CompileContext, token: Token) => void} Handle\n * @typedef {Record<string, Handle>} Handles\n *   Token types mapping to handles\n * @typedef {Record<string, Record<string, unknown>|Array<unknown>> & {canContainEols: Array<string>, transforms: Array<Transform>, enter: Handles, exit: Handles}} NormalizedExtension\n * @typedef {Partial<NormalizedExtension>} Extension\n *   An mdast extension changes how markdown tokens are turned into mdast.\n *\n * @typedef {(this: Omit<CompileContext, 'sliceSerialize'>, left: Token|undefined, right: Token) => void} OnEnterError\n * @typedef {(this: Omit<CompileContext, 'sliceSerialize'>, left: Token, right: Token) => void} OnExitError\n *\n * @typedef CompileContext\n *   mdast compiler context\n * @property {Array<Node | Fragment>} stack\n * @property {Array<[Token, OnEnterError|undefined]>} tokenStack\n * @property {(key: string, value?: unknown) => void} setData\n *   Set data into the key-value store.\n * @property {<K extends string>(key: K) => CompileData[K]} getData\n *   Get data from the key-value store.\n * @property {(this: CompileContext) => void} buffer\n *   Capture some of the output data.\n * @property {(this: CompileContext) => string} resume\n *   Stop capturing and access the output data.\n * @property {<N extends Node>(this: CompileContext, node: N, token: Token, onError?: OnEnterError) => N} enter\n *   Enter a token.\n * @property {(this: CompileContext, token: Token, onError?: OnExitError) => Node} exit\n *   Exit a token.\n * @property {TokenizeContext['sliceSerialize']} sliceSerialize\n *   Get the string value of a token.\n * @property {NormalizedExtension} config\n *   Configuration.\n *\n * @typedef {{mdastExtensions?: Array<Extension|Array<Extension>>}} FromMarkdownOptions\n * @typedef {ParseOptions & FromMarkdownOptions} Options\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromMarkdown = void 0;\n\nvar _mdastUtilToString = require(\"mdast-util-to-string\");\n\nvar _parse = require(\"micromark/lib/parse.js\");\n\nvar _preprocess = require(\"micromark/lib/preprocess.js\");\n\nvar _postprocess = require(\"micromark/lib/postprocess.js\");\n\nvar _micromarkUtilDecodeNumericCharacterReference = require(\"micromark-util-decode-numeric-character-reference\");\n\nvar _micromarkUtilDecodeString = require(\"micromark-util-decode-string\");\n\nvar _micromarkUtilNormalizeIdentifier = require(\"micromark-util-normalize-identifier\");\n\nvar _decodeNamedCharacterReference = require(\"decode-named-character-reference\");\n\nvar _unistUtilStringifyPosition = require(\"unist-util-stringify-position\");\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar own = {}.hasOwnProperty;\n/**\n * @param value Markdown to parse (`string` or `Buffer`).\n * @param [encoding] Character encoding to understand `value` as when it’s a `Buffer` (`string`, default: `'utf8'`).\n * @param [options] Configuration\n */\n\nvar fromMarkdown =\n/**\n * @type {(\n *   ((value: Value, encoding: Encoding, options?: Options) => Root) &\n *   ((value: Value, options?: Options) => Root)\n * )}\n */\n\n/**\n * @param {Value} value\n * @param {Encoding} [encoding]\n * @param {Options} [options]\n * @returns {Root}\n */\nfunction fromMarkdown(value, encoding, options) {\n  if (typeof encoding !== 'string') {\n    options = encoding;\n    encoding = undefined;\n  }\n\n  return compiler(options)((0, _postprocess.postprocess)((0, _parse.parse)(options).document().write((0, _preprocess.preprocess)()(value, encoding, true))));\n};\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options} [options]\n */\n\n\nexports.fromMarkdown = fromMarkdown;\n\nfunction compiler() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  /** @type {NormalizedExtension} */\n  // @ts-expect-error: our base has all required fields, so the result will too.\n  var config = configure({\n    transforms: [],\n    canContainEols: ['emphasis', 'fragment', 'heading', 'paragraph', 'strong'],\n    enter: {\n      autolink: opener(link),\n      autolinkProtocol: onenterdata,\n      autolinkEmail: onenterdata,\n      atxHeading: opener(heading),\n      blockQuote: opener(blockQuote),\n      characterEscape: onenterdata,\n      characterReference: onenterdata,\n      codeFenced: opener(codeFlow),\n      codeFencedFenceInfo: buffer,\n      codeFencedFenceMeta: buffer,\n      codeIndented: opener(codeFlow, buffer),\n      codeText: opener(codeText, buffer),\n      codeTextData: onenterdata,\n      data: onenterdata,\n      codeFlowValue: onenterdata,\n      definition: opener(definition),\n      definitionDestinationString: buffer,\n      definitionLabelString: buffer,\n      definitionTitleString: buffer,\n      emphasis: opener(emphasis),\n      hardBreakEscape: opener(hardBreak),\n      hardBreakTrailing: opener(hardBreak),\n      htmlFlow: opener(html, buffer),\n      htmlFlowData: onenterdata,\n      htmlText: opener(html, buffer),\n      htmlTextData: onenterdata,\n      image: opener(image),\n      label: buffer,\n      link: opener(link),\n      listItem: opener(listItem),\n      listItemValue: onenterlistitemvalue,\n      listOrdered: opener(list, onenterlistordered),\n      listUnordered: opener(list),\n      paragraph: opener(paragraph),\n      reference: onenterreference,\n      referenceString: buffer,\n      resourceDestinationString: buffer,\n      resourceTitleString: buffer,\n      setextHeading: opener(heading),\n      strong: opener(strong),\n      thematicBreak: opener(thematicBreak)\n    },\n    exit: {\n      atxHeading: closer(),\n      atxHeadingSequence: onexitatxheadingsequence,\n      autolink: closer(),\n      autolinkEmail: onexitautolinkemail,\n      autolinkProtocol: onexitautolinkprotocol,\n      blockQuote: closer(),\n      characterEscapeValue: onexitdata,\n      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n      characterReferenceValue: onexitcharacterreferencevalue,\n      codeFenced: closer(onexitcodefenced),\n      codeFencedFence: onexitcodefencedfence,\n      codeFencedFenceInfo: onexitcodefencedfenceinfo,\n      codeFencedFenceMeta: onexitcodefencedfencemeta,\n      codeFlowValue: onexitdata,\n      codeIndented: closer(onexitcodeindented),\n      codeText: closer(onexitcodetext),\n      codeTextData: onexitdata,\n      data: onexitdata,\n      definition: closer(),\n      definitionDestinationString: onexitdefinitiondestinationstring,\n      definitionLabelString: onexitdefinitionlabelstring,\n      definitionTitleString: onexitdefinitiontitlestring,\n      emphasis: closer(),\n      hardBreakEscape: closer(onexithardbreak),\n      hardBreakTrailing: closer(onexithardbreak),\n      htmlFlow: closer(onexithtmlflow),\n      htmlFlowData: onexitdata,\n      htmlText: closer(onexithtmltext),\n      htmlTextData: onexitdata,\n      image: closer(onexitimage),\n      label: onexitlabel,\n      labelText: onexitlabeltext,\n      lineEnding: onexitlineending,\n      link: closer(onexitlink),\n      listItem: closer(),\n      listOrdered: closer(),\n      listUnordered: closer(),\n      paragraph: closer(),\n      referenceString: onexitreferencestring,\n      resourceDestinationString: onexitresourcedestinationstring,\n      resourceTitleString: onexitresourcetitlestring,\n      resource: onexitresource,\n      setextHeading: closer(onexitsetextheading),\n      setextHeadingLineSequence: onexitsetextheadinglinesequence,\n      setextHeadingText: onexitsetextheadingtext,\n      strong: closer(),\n      thematicBreak: closer()\n    }\n  }, options.mdastExtensions || []);\n  /** @type {CompileData} */\n\n  var data = {};\n  return compile;\n  /**\n   * @param {Array<Event>} events\n   * @returns {Root}\n   */\n\n  function compile(events) {\n    /** @type {Root} */\n    var tree = {\n      type: 'root',\n      children: []\n    };\n    /** @type {CompileContext['stack']} */\n\n    var stack = [tree];\n    /** @type {CompileContext['tokenStack']} */\n\n    var tokenStack = [];\n    /** @type {Array<number>} */\n\n    var listStack = [];\n    /** @type {Omit<CompileContext, 'sliceSerialize'>} */\n\n    var context = {\n      stack: stack,\n      tokenStack: tokenStack,\n      config: config,\n      enter: enter,\n      exit: exit,\n      buffer: buffer,\n      resume: resume,\n      setData: setData,\n      getData: getData\n    };\n    var index = -1;\n\n    while (++index < events.length) {\n      // We preprocess lists to add `listItem` tokens, and to infer whether\n      // items the list itself are spread out.\n      if (events[index][1].type === 'listOrdered' || events[index][1].type === 'listUnordered') {\n        if (events[index][0] === 'enter') {\n          listStack.push(index);\n        } else {\n          var tail = listStack.pop();\n          index = prepareList(events, tail, index);\n        }\n      }\n    }\n\n    index = -1;\n\n    while (++index < events.length) {\n      var handler = config[events[index][0]];\n\n      if (own.call(handler, events[index][1].type)) {\n        handler[events[index][1].type].call(Object.assign({\n          sliceSerialize: events[index][2].sliceSerialize\n        }, context), events[index][1]);\n      }\n    }\n\n    if (tokenStack.length > 0) {\n      var _tail = tokenStack[tokenStack.length - 1];\n\n      var _handler = _tail[1] || defaultOnError;\n\n      _handler.call(context, undefined, _tail[0]);\n    } // Figure out `root` position.\n\n\n    tree.position = {\n      start: point(events.length > 0 ? events[0][1].start : {\n        line: 1,\n        column: 1,\n        offset: 0\n      }),\n      end: point(events.length > 0 ? events[events.length - 2][1].end : {\n        line: 1,\n        column: 1,\n        offset: 0\n      })\n    };\n    index = -1;\n\n    while (++index < config.transforms.length) {\n      tree = config.transforms[index](tree) || tree;\n    }\n\n    return tree;\n  }\n  /**\n   * @param {Array<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */\n\n\n  function prepareList(events, start, length) {\n    var index = start - 1;\n    var containerBalance = -1;\n    var listSpread = false;\n    /** @type {Token|undefined} */\n\n    var listItem;\n    /** @type {number|undefined} */\n\n    var lineIndex;\n    /** @type {number|undefined} */\n\n    var firstBlankLineIndex;\n    /** @type {boolean|undefined} */\n\n    var atMarker;\n\n    while (++index <= length) {\n      var event = events[index];\n\n      if (event[1].type === 'listUnordered' || event[1].type === 'listOrdered' || event[1].type === 'blockQuote') {\n        if (event[0] === 'enter') {\n          containerBalance++;\n        } else {\n          containerBalance--;\n        }\n\n        atMarker = undefined;\n      } else if (event[1].type === 'lineEndingBlank') {\n        if (event[0] === 'enter') {\n          if (listItem && !atMarker && !containerBalance && !firstBlankLineIndex) {\n            firstBlankLineIndex = index;\n          }\n\n          atMarker = undefined;\n        }\n      } else if (event[1].type === 'linePrefix' || event[1].type === 'listItemValue' || event[1].type === 'listItemMarker' || event[1].type === 'listItemPrefix' || event[1].type === 'listItemPrefixWhitespace') {// Empty.\n      } else {\n        atMarker = undefined;\n      }\n\n      if (!containerBalance && event[0] === 'enter' && event[1].type === 'listItemPrefix' || containerBalance === -1 && event[0] === 'exit' && (event[1].type === 'listUnordered' || event[1].type === 'listOrdered')) {\n        if (listItem) {\n          var tailIndex = index;\n          lineIndex = undefined;\n\n          while (tailIndex--) {\n            var tailEvent = events[tailIndex];\n\n            if (tailEvent[1].type === 'lineEnding' || tailEvent[1].type === 'lineEndingBlank') {\n              if (tailEvent[0] === 'exit') continue;\n\n              if (lineIndex) {\n                events[lineIndex][1].type = 'lineEndingBlank';\n                listSpread = true;\n              }\n\n              tailEvent[1].type = 'lineEnding';\n              lineIndex = tailIndex;\n            } else if (tailEvent[1].type === 'linePrefix' || tailEvent[1].type === 'blockQuotePrefix' || tailEvent[1].type === 'blockQuotePrefixWhitespace' || tailEvent[1].type === 'blockQuoteMarker' || tailEvent[1].type === 'listItemIndent') {// Empty\n            } else {\n              break;\n            }\n          }\n\n          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {\n            // @ts-expect-error Patched.\n            listItem._spread = true;\n          } // Fix position.\n\n\n          listItem.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);\n          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]]);\n          index++;\n          length++;\n        } // Create a new list item.\n\n\n        if (event[1].type === 'listItemPrefix') {\n          listItem = {\n            type: 'listItem',\n            // @ts-expect-error Patched\n            _spread: false,\n            start: Object.assign({}, event[1].start)\n          }; // @ts-expect-error: `listItem` is most definitely defined, TS...\n\n          events.splice(index, 0, ['enter', listItem, event[2]]);\n          index++;\n          length++;\n          firstBlankLineIndex = undefined;\n          atMarker = true;\n        }\n      }\n    } // @ts-expect-error Patched.\n\n\n    events[start][1]._spread = listSpread;\n    return length;\n  }\n  /**\n   * @type {CompileContext['setData']}\n   * @param [value]\n   */\n\n\n  function setData(key, value) {\n    data[key] = value;\n  }\n  /**\n   * @type {CompileContext['getData']}\n   * @template {string} K\n   * @param {K} key\n   * @returns {CompileData[K]}\n   */\n\n\n  function getData(key) {\n    return data[key];\n  }\n  /**\n   * @param {Point} d\n   * @returns {Point}\n   */\n\n\n  function point(d) {\n    return {\n      line: d.line,\n      column: d.column,\n      offset: d.offset\n    };\n  }\n  /**\n   * @param {(token: Token) => Node} create\n   * @param {Handle} [and]\n   * @returns {Handle}\n   */\n\n\n  function opener(create, and) {\n    return open;\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n\n    function open(token) {\n      enter.call(this, create(token), token);\n      if (and) and.call(this, token);\n    }\n  }\n  /** @type {CompileContext['buffer']} */\n\n\n  function buffer() {\n    this.stack.push({\n      type: 'fragment',\n      children: []\n    });\n  }\n  /**\n   * @type {CompileContext['enter']}\n   * @template {Node} N\n   * @this {CompileContext}\n   * @param {N} node\n   * @param {Token} token\n   * @param {OnEnterError} [errorHandler]\n   * @returns {N}\n   */\n\n\n  function enter(node, token, errorHandler) {\n    var parent = this.stack[this.stack.length - 1]; // @ts-expect-error: Assume `Node` can exist as a child of `parent`.\n\n    parent.children.push(node);\n    this.stack.push(node);\n    this.tokenStack.push([token, errorHandler]); // @ts-expect-error: `end` will be patched later.\n\n    node.position = {\n      start: point(token.start)\n    };\n    return node;\n  }\n  /**\n   * @param {Handle} [and]\n   * @returns {Handle}\n   */\n\n\n  function closer(and) {\n    return close;\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n\n    function close(token) {\n      if (and) and.call(this, token);\n      exit.call(this, token);\n    }\n  }\n  /**\n   * @type {CompileContext['exit']}\n   * @this {CompileContext}\n   * @param {Token} token\n   * @param {OnExitError} [onExitError]\n   * @returns {Node}\n   */\n\n\n  function exit(token, onExitError) {\n    var node = this.stack.pop();\n    var open = this.tokenStack.pop();\n\n    if (!open) {\n      throw new Error('Cannot close `' + token.type + '` (' + (0, _unistUtilStringifyPosition.stringifyPosition)({\n        start: token.start,\n        end: token.end\n      }) + '): it’s not open');\n    } else if (open[0].type !== token.type) {\n      if (onExitError) {\n        onExitError.call(this, token, open[0]);\n      } else {\n        var handler = open[1] || defaultOnError;\n        handler.call(this, token, open[0]);\n      }\n    }\n\n    node.position.end = point(token.end);\n    return node;\n  }\n  /**\n   * @this {CompileContext}\n   * @returns {string}\n   */\n\n\n  function resume() {\n    return (0, _mdastUtilToString.toString)(this.stack.pop());\n  } //\n  // Handlers.\n  //\n\n  /** @type {Handle} */\n\n\n  function onenterlistordered() {\n    setData('expectingFirstListItemValue', true);\n  }\n  /** @type {Handle} */\n\n\n  function onenterlistitemvalue(token) {\n    if (getData('expectingFirstListItemValue')) {\n      var ancestor =\n      /** @type {List} */\n      this.stack[this.stack.length - 2];\n      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);\n      setData('expectingFirstListItemValue');\n    }\n  }\n  /** @type {Handle} */\n\n\n  function onexitcodefencedfenceinfo() {\n    var data = this.resume();\n    var node =\n    /** @type {Code} */\n    this.stack[this.stack.length - 1];\n    node.lang = data;\n  }\n  /** @type {Handle} */\n\n\n  function onexitcodefencedfencemeta() {\n    var data = this.resume();\n    var node =\n    /** @type {Code} */\n    this.stack[this.stack.length - 1];\n    node.meta = data;\n  }\n  /** @type {Handle} */\n\n\n  function onexitcodefencedfence() {\n    // Exit if this is the closing fence.\n    if (getData('flowCodeInside')) return;\n    this.buffer();\n    setData('flowCodeInside', true);\n  }\n  /** @type {Handle} */\n\n\n  function onexitcodefenced() {\n    var data = this.resume();\n    var node =\n    /** @type {Code} */\n    this.stack[this.stack.length - 1];\n    node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '');\n    setData('flowCodeInside');\n  }\n  /** @type {Handle} */\n\n\n  function onexitcodeindented() {\n    var data = this.resume();\n    var node =\n    /** @type {Code} */\n    this.stack[this.stack.length - 1];\n    node.value = data.replace(/(\\r?\\n|\\r)$/g, '');\n  }\n  /** @type {Handle} */\n\n\n  function onexitdefinitionlabelstring(token) {\n    // Discard label, use the source content instead.\n    var label = this.resume();\n    var node =\n    /** @type {Definition} */\n    this.stack[this.stack.length - 1];\n    node.label = label;\n    node.identifier = (0, _micromarkUtilNormalizeIdentifier.normalizeIdentifier)(this.sliceSerialize(token)).toLowerCase();\n  }\n  /** @type {Handle} */\n\n\n  function onexitdefinitiontitlestring() {\n    var data = this.resume();\n    var node =\n    /** @type {Definition} */\n    this.stack[this.stack.length - 1];\n    node.title = data;\n  }\n  /** @type {Handle} */\n\n\n  function onexitdefinitiondestinationstring() {\n    var data = this.resume();\n    var node =\n    /** @type {Definition} */\n    this.stack[this.stack.length - 1];\n    node.url = data;\n  }\n  /** @type {Handle} */\n\n\n  function onexitatxheadingsequence(token) {\n    var node =\n    /** @type {Heading} */\n    this.stack[this.stack.length - 1];\n\n    if (!node.depth) {\n      var depth = this.sliceSerialize(token).length;\n      node.depth = depth;\n    }\n  }\n  /** @type {Handle} */\n\n\n  function onexitsetextheadingtext() {\n    setData('setextHeadingSlurpLineEnding', true);\n  }\n  /** @type {Handle} */\n\n\n  function onexitsetextheadinglinesequence(token) {\n    var node =\n    /** @type {Heading} */\n    this.stack[this.stack.length - 1];\n    node.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2;\n  }\n  /** @type {Handle} */\n\n\n  function onexitsetextheading() {\n    setData('setextHeadingSlurpLineEnding');\n  }\n  /** @type {Handle} */\n\n\n  function onenterdata(token) {\n    var parent =\n    /** @type {Parent} */\n    this.stack[this.stack.length - 1];\n    /** @type {Node} */\n\n    var tail = parent.children[parent.children.length - 1];\n\n    if (!tail || tail.type !== 'text') {\n      // Add a new text node.\n      tail = text(); // @ts-expect-error: we’ll add `end` later.\n\n      tail.position = {\n        start: point(token.start)\n      }; // @ts-expect-error: Assume `parent` accepts `text`.\n\n      parent.children.push(tail);\n    }\n\n    this.stack.push(tail);\n  }\n  /** @type {Handle} */\n\n\n  function onexitdata(token) {\n    var tail = this.stack.pop();\n    tail.value += this.sliceSerialize(token);\n    tail.position.end = point(token.end);\n  }\n  /** @type {Handle} */\n\n\n  function onexitlineending(token) {\n    var context = this.stack[this.stack.length - 1]; // If we’re at a hard break, include the line ending in there.\n\n    if (getData('atHardBreak')) {\n      var tail = context.children[context.children.length - 1];\n      tail.position.end = point(token.end);\n      setData('atHardBreak');\n      return;\n    }\n\n    if (!getData('setextHeadingSlurpLineEnding') && config.canContainEols.includes(context.type)) {\n      onenterdata.call(this, token);\n      onexitdata.call(this, token);\n    }\n  }\n  /** @type {Handle} */\n\n\n  function onexithardbreak() {\n    setData('atHardBreak', true);\n  }\n  /** @type {Handle} */\n\n\n  function onexithtmlflow() {\n    var data = this.resume();\n    var node =\n    /** @type {HTML} */\n    this.stack[this.stack.length - 1];\n    node.value = data;\n  }\n  /** @type {Handle} */\n\n\n  function onexithtmltext() {\n    var data = this.resume();\n    var node =\n    /** @type {HTML} */\n    this.stack[this.stack.length - 1];\n    node.value = data;\n  }\n  /** @type {Handle} */\n\n\n  function onexitcodetext() {\n    var data = this.resume();\n    var node =\n    /** @type {InlineCode} */\n    this.stack[this.stack.length - 1];\n    node.value = data;\n  }\n  /** @type {Handle} */\n\n\n  function onexitlink() {\n    var context =\n    /** @type {Link & {identifier: string, label: string}} */\n    this.stack[this.stack.length - 1]; // To do: clean.\n\n    if (getData('inReference')) {\n      context.type += 'Reference'; // @ts-expect-error: mutate.\n\n      context.referenceType = getData('referenceType') || 'shortcut'; // @ts-expect-error: mutate.\n\n      delete context.url;\n      delete context.title;\n    } else {\n      // @ts-expect-error: mutate.\n      delete context.identifier; // @ts-expect-error: mutate.\n\n      delete context.label;\n    }\n\n    setData('referenceType');\n  }\n  /** @type {Handle} */\n\n\n  function onexitimage() {\n    var context =\n    /** @type {Image & {identifier: string, label: string}} */\n    this.stack[this.stack.length - 1]; // To do: clean.\n\n    if (getData('inReference')) {\n      context.type += 'Reference'; // @ts-expect-error: mutate.\n\n      context.referenceType = getData('referenceType') || 'shortcut'; // @ts-expect-error: mutate.\n\n      delete context.url;\n      delete context.title;\n    } else {\n      // @ts-expect-error: mutate.\n      delete context.identifier; // @ts-expect-error: mutate.\n\n      delete context.label;\n    }\n\n    setData('referenceType');\n  }\n  /** @type {Handle} */\n\n\n  function onexitlabeltext(token) {\n    var ancestor =\n    /** @type {(Link|Image) & {identifier: string, label: string}} */\n    this.stack[this.stack.length - 2];\n    var string = this.sliceSerialize(token);\n    ancestor.label = (0, _micromarkUtilDecodeString.decodeString)(string);\n    ancestor.identifier = (0, _micromarkUtilNormalizeIdentifier.normalizeIdentifier)(string).toLowerCase();\n  }\n  /** @type {Handle} */\n\n\n  function onexitlabel() {\n    var fragment =\n    /** @type {Fragment} */\n    this.stack[this.stack.length - 1];\n    var value = this.resume();\n    var node =\n    /** @type {(Link|Image) & {identifier: string, label: string}} */\n    this.stack[this.stack.length - 1]; // Assume a reference.\n\n    setData('inReference', true);\n\n    if (node.type === 'link') {\n      // @ts-expect-error: Assume static phrasing content.\n      node.children = fragment.children;\n    } else {\n      node.alt = value;\n    }\n  }\n  /** @type {Handle} */\n\n\n  function onexitresourcedestinationstring() {\n    var data = this.resume();\n    var node =\n    /** @type {Link|Image} */\n    this.stack[this.stack.length - 1];\n    node.url = data;\n  }\n  /** @type {Handle} */\n\n\n  function onexitresourcetitlestring() {\n    var data = this.resume();\n    var node =\n    /** @type {Link|Image} */\n    this.stack[this.stack.length - 1];\n    node.title = data;\n  }\n  /** @type {Handle} */\n\n\n  function onexitresource() {\n    setData('inReference');\n  }\n  /** @type {Handle} */\n\n\n  function onenterreference() {\n    setData('referenceType', 'collapsed');\n  }\n  /** @type {Handle} */\n\n\n  function onexitreferencestring(token) {\n    var label = this.resume();\n    var node =\n    /** @type {LinkReference|ImageReference} */\n    this.stack[this.stack.length - 1];\n    node.label = label;\n    node.identifier = (0, _micromarkUtilNormalizeIdentifier.normalizeIdentifier)(this.sliceSerialize(token)).toLowerCase();\n    setData('referenceType', 'full');\n  }\n  /** @type {Handle} */\n\n\n  function onexitcharacterreferencemarker(token) {\n    setData('characterReferenceType', token.type);\n  }\n  /** @type {Handle} */\n\n\n  function onexitcharacterreferencevalue(token) {\n    var data = this.sliceSerialize(token);\n    var type = getData('characterReferenceType');\n    /** @type {string} */\n\n    var value;\n\n    if (type) {\n      value = (0, _micromarkUtilDecodeNumericCharacterReference.decodeNumericCharacterReference)(data, type === 'characterReferenceMarkerNumeric' ? 10 : 16);\n      setData('characterReferenceType');\n    } else {\n      // @ts-expect-error `decodeNamedCharacterReference` can return false for\n      // invalid named character references, but everything we’ve tokenized is\n      // valid.\n      value = (0, _decodeNamedCharacterReference.decodeNamedCharacterReference)(data);\n    }\n\n    var tail = this.stack.pop();\n    tail.value += value;\n    tail.position.end = point(token.end);\n  }\n  /** @type {Handle} */\n\n\n  function onexitautolinkprotocol(token) {\n    onexitdata.call(this, token);\n    var node =\n    /** @type {Link} */\n    this.stack[this.stack.length - 1];\n    node.url = this.sliceSerialize(token);\n  }\n  /** @type {Handle} */\n\n\n  function onexitautolinkemail(token) {\n    onexitdata.call(this, token);\n    var node =\n    /** @type {Link} */\n    this.stack[this.stack.length - 1];\n    node.url = 'mailto:' + this.sliceSerialize(token);\n  } //\n  // Creaters.\n  //\n\n  /** @returns {Blockquote} */\n\n\n  function blockQuote() {\n    return {\n      type: 'blockquote',\n      children: []\n    };\n  }\n  /** @returns {Code} */\n\n\n  function codeFlow() {\n    return {\n      type: 'code',\n      lang: null,\n      meta: null,\n      value: ''\n    };\n  }\n  /** @returns {InlineCode} */\n\n\n  function codeText() {\n    return {\n      type: 'inlineCode',\n      value: ''\n    };\n  }\n  /** @returns {Definition} */\n\n\n  function definition() {\n    return {\n      type: 'definition',\n      identifier: '',\n      label: null,\n      title: null,\n      url: ''\n    };\n  }\n  /** @returns {Emphasis} */\n\n\n  function emphasis() {\n    return {\n      type: 'emphasis',\n      children: []\n    };\n  }\n  /** @returns {Heading} */\n\n\n  function heading() {\n    // @ts-expect-error `depth` will be set later.\n    return {\n      type: 'heading',\n      depth: undefined,\n      children: []\n    };\n  }\n  /** @returns {Break} */\n\n\n  function hardBreak() {\n    return {\n      type: 'break'\n    };\n  }\n  /** @returns {HTML} */\n\n\n  function html() {\n    return {\n      type: 'html',\n      value: ''\n    };\n  }\n  /** @returns {Image} */\n\n\n  function image() {\n    return {\n      type: 'image',\n      title: null,\n      url: '',\n      alt: null\n    };\n  }\n  /** @returns {Link} */\n\n\n  function link() {\n    return {\n      type: 'link',\n      title: null,\n      url: '',\n      children: []\n    };\n  }\n  /**\n   * @param {Token} token\n   * @returns {List}\n   */\n\n\n  function list(token) {\n    return {\n      type: 'list',\n      ordered: token.type === 'listOrdered',\n      start: null,\n      // @ts-expect-error Patched.\n      spread: token._spread,\n      children: []\n    };\n  }\n  /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */\n\n\n  function listItem(token) {\n    return {\n      type: 'listItem',\n      // @ts-expect-error Patched.\n      spread: token._spread,\n      checked: null,\n      children: []\n    };\n  }\n  /** @returns {Paragraph} */\n\n\n  function paragraph() {\n    return {\n      type: 'paragraph',\n      children: []\n    };\n  }\n  /** @returns {Strong} */\n\n\n  function strong() {\n    return {\n      type: 'strong',\n      children: []\n    };\n  }\n  /** @returns {Text} */\n\n\n  function text() {\n    return {\n      type: 'text',\n      value: ''\n    };\n  }\n  /** @returns {ThematicBreak} */\n\n\n  function thematicBreak() {\n    return {\n      type: 'thematicBreak'\n    };\n  }\n}\n/**\n * @param {Extension} combined\n * @param {Array<Extension|Array<Extension>>} extensions\n * @returns {Extension}\n */\n\n\nfunction configure(combined, extensions) {\n  var index = -1;\n\n  while (++index < extensions.length) {\n    var value = extensions[index];\n\n    if (Array.isArray(value)) {\n      configure(combined, value);\n    } else {\n      extension(combined, value);\n    }\n  }\n\n  return combined;\n}\n/**\n * @param {Extension} combined\n * @param {Extension} extension\n * @returns {void}\n */\n\n\nfunction extension(combined, extension) {\n  /** @type {string} */\n  var key;\n\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      var list = key === 'canContainEols' || key === 'transforms';\n      var maybe = own.call(combined, key) ? combined[key] : undefined;\n      /* c8 ignore next */\n\n      var left = maybe || (combined[key] = list ? [] : {});\n      var right = extension[key];\n\n      if (right) {\n        if (list) {\n          // @ts-expect-error: `left` is an array.\n          combined[key] = [].concat(_toConsumableArray(left), _toConsumableArray(right));\n        } else {\n          Object.assign(left, right);\n        }\n      }\n    }\n  }\n}\n/** @type {OnEnterError} */\n\n\nfunction defaultOnError(left, right) {\n  if (left) {\n    throw new Error('Cannot close `' + left.type + '` (' + (0, _unistUtilStringifyPosition.stringifyPosition)({\n      start: left.start,\n      end: left.end\n    }) + '): a different token (`' + right.type + '`, ' + (0, _unistUtilStringifyPosition.stringifyPosition)({\n      start: right.start,\n      end: right.end\n    }) + ') is open');\n  } else {\n    throw new Error('Cannot close document, a token (`' + right.type + '`, ' + (0, _unistUtilStringifyPosition.stringifyPosition)({\n      start: right.start,\n      end: right.end\n    }) + ') is still open');\n  }\n}",
        "mapping": {
            "mdast-util-to-string": "{C1E6104B-7764-43B2-957C-EF4482518073}",
            "micromark/lib/parse.js": "{C56453B2-ECA5-4CFA-9368-92DBBB83B436}",
            "micromark/lib/preprocess.js": "{32A054D9-B22D-47BD-9453-523697AC14DE}",
            "micromark/lib/postprocess.js": "{52F31653-675A-4073-A033-71D7A003E18C}",
            "micromark-util-decode-numeric-character-reference": "{BCC305A4-BFB3-45F1-BFB8-CDDC7CDB946A}",
            "micromark-util-decode-string": "{AC9460D6-4D8A-4AAE-BC63-C5A4EBB5443E}",
            "micromark-util-normalize-identifier": "{2DCCC183-8747-4B15-B12E-8E8EF1049A0C}",
            "decode-named-character-reference": "{51DC88FA-8373-443C-BAA0-8A2EC6E4B846}",
            "unist-util-stringify-position": "{46A6F8FD-1366-4C78-B2BA-4EA6C61C83F5}"
        },
        "path": "{remark-parse}/../mdast-util-from-markdown/lib/index.js"
    },
    "{C1E6104B-7764-43B2-957C-EF4482518073}": {
        "source": "\"use strict\";\n/**\n* @typedef Options\n* @property {boolean} [includeImageAlt=true]\n*/\n\n/**\n * Get the text content of a node.\n * Prefer the node’s plain-text fields, otherwise serialize its children,\n * and if the given value is an array, serialize the nodes in it.\n *\n * @param {unknown} node\n * @param {Options} [options]\n * @returns {string}\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toString = toString;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction toString(node, options) {\n  var _ref = options || {},\n      _ref$includeImageAlt = _ref.includeImageAlt,\n      includeImageAlt = _ref$includeImageAlt === void 0 ? true : _ref$includeImageAlt;\n\n  return one(node, includeImageAlt);\n}\n/**\n * @param {unknown} node\n * @param {boolean} includeImageAlt\n * @returns {string}\n */\n\n\nfunction one(node, includeImageAlt) {\n  return node && _typeof(node) === 'object' && ( // @ts-ignore looks like a literal.\n  node.value || ( // @ts-ignore looks like an image.\n  includeImageAlt ? node.alt : '') || // @ts-ignore looks like a parent.\n  'children' in node && all(node.children, includeImageAlt) || Array.isArray(node) && all(node, includeImageAlt)) || '';\n}\n/**\n * @param {Array.<unknown>} values\n * @param {boolean} includeImageAlt\n * @returns {string}\n */\n\n\nfunction all(values, includeImageAlt) {\n  /** @type {Array.<string>} */\n  var result = [];\n  var index = -1;\n\n  while (++index < values.length) {\n    result[index] = one(values[index], includeImageAlt);\n  }\n\n  return result.join('');\n}",
        "mapping": {},
        "path": "{remark-parse}/../mdast-util-to-string/index.js"
    },
    "{C56453B2-ECA5-4CFA-9368-92DBBB83B436}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n* @typedef {import('micromark-util-types').FullNormalizedExtension} FullNormalizedExtension\n* @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n* @typedef {import('micromark-util-types').ParseContext} ParseContext\n* @typedef {import('micromark-util-types').Create} Create\n*/\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parse = parse;\n\nvar _micromarkUtilCombineExtensions = require(\"micromark-util-combine-extensions\");\n\nvar _content = require(\"./initialize/content.js\");\n\nvar _document = require(\"./initialize/document.js\");\n\nvar _flow = require(\"./initialize/flow.js\");\n\nvar _text = require(\"./initialize/text.js\");\n\nvar _createTokenizer = require(\"./create-tokenizer.js\");\n\nvar defaultConstructs = _interopRequireWildcard(require(\"./constructs.js\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n/**\n * @param {ParseOptions} [options]\n * @returns {ParseContext}\n */\nfunction parse() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  /** @type {FullNormalizedExtension} */\n  // @ts-expect-error `defaultConstructs` is full, so the result will be too.\n  var constructs = (0, _micromarkUtilCombineExtensions.combineExtensions)( // @ts-expect-error Same as above.\n  [defaultConstructs].concat(options.extensions || []));\n  /** @type {ParseContext} */\n\n  var parser = {\n    defined: [],\n    lazy: {},\n    constructs: constructs,\n    content: create(_content.content),\n    document: create(_document.document),\n    flow: create(_flow.flow),\n    string: create(_text.string),\n    text: create(_text.text)\n  };\n  return parser;\n  /**\n   * @param {InitialConstruct} initial\n   */\n\n  function create(initial) {\n    return creator;\n    /** @type {Create} */\n\n    function creator(from) {\n      return (0, _createTokenizer.createTokenizer)(parser, initial, from);\n    }\n  }\n}",
        "mapping": {
            "micromark-util-combine-extensions": "{EA524BFF-699C-44DE-8C0B-E6944B592F37}",
            "./initialize/content.js": "{814CE53A-8C55-4243-B446-F315375E6C42}",
            "./initialize/document.js": "{2012AD71-193C-4EFA-9D92-45B71E2A45D5}",
            "./initialize/flow.js": "{2ADC5173-D1E5-4159-B081-1084C77DC9A0}",
            "./initialize/text.js": "{FF987C0B-BAE7-47F7-AF87-D8CD3501D555}",
            "./create-tokenizer.js": "{17D6994B-1CC0-41E1-8099-C00E5D33ED1A}",
            "./constructs.js": "{AA5209E9-0519-40DE-A13F-890C3D505809}"
        },
        "path": "{remark-parse}/../micromark/lib/parse.js"
    },
    "{EA524BFF-699C-44DE-8C0B-E6944B592F37}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').NormalizedExtension} NormalizedExtension\n* @typedef {import('micromark-util-types').Extension} Extension\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.combineExtensions = combineExtensions;\nexports.combineHtmlExtensions = combineHtmlExtensions;\n\nvar _micromarkUtilChunked = require(\"micromark-util-chunked\");\n\nvar hasOwnProperty = {}.hasOwnProperty;\n/**\n * Combine several syntax extensions into one.\n *\n * @param {Extension[]} extensions List of syntax extensions.\n * @returns {NormalizedExtension} A single combined extension.\n */\n\nfunction combineExtensions(extensions) {\n  /** @type {NormalizedExtension} */\n  var all = {};\n  var index = -1;\n\n  while (++index < extensions.length) {\n    syntaxExtension(all, extensions[index]);\n  }\n\n  return all;\n}\n/**\n * Merge `extension` into `all`.\n *\n * @param {NormalizedExtension} all Extension to merge into.\n * @param {Extension} extension Extension to merge.\n * @returns {void}\n */\n\n\nfunction syntaxExtension(all, extension) {\n  /** @type {string} */\n  var hook;\n\n  for (hook in extension) {\n    var maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined;\n    var left = maybe || (all[hook] = {});\n    var right = extension[hook];\n    /** @type {string} */\n\n    var code = void 0;\n\n    for (code in right) {\n      if (!hasOwnProperty.call(left, code)) left[code] = [];\n      var value = right[code];\n      constructs( // @ts-expect-error Looks like a list.\n      left[code], Array.isArray(value) ? value : value ? [value] : []);\n    }\n  }\n}\n/**\n * Merge `list` into `existing` (both lists of constructs).\n * Mutates `existing`.\n *\n * @param {unknown[]} existing\n * @param {unknown[]} list\n * @returns {void}\n */\n\n\nfunction constructs(existing, list) {\n  var index = -1;\n  /** @type {unknown[]} */\n\n  var before = [];\n\n  while (++index < list.length) {\n    // @ts-expect-error Looks like an object.\n    ;\n    (list[index].add === 'after' ? existing : before).push(list[index]);\n  }\n\n  (0, _micromarkUtilChunked.splice)(existing, 0, 0, before);\n}\n/**\n * Combine several HTML extensions into one.\n *\n * @param {HtmlExtension[]} htmlExtensions List of HTML extensions.\n * @returns {HtmlExtension} A single combined extension.\n */\n\n\nfunction combineHtmlExtensions(htmlExtensions) {\n  /** @type {HtmlExtension} */\n  var handlers = {};\n  var index = -1;\n\n  while (++index < htmlExtensions.length) {\n    htmlExtension(handlers, htmlExtensions[index]);\n  }\n\n  return handlers;\n}\n/**\n * Merge `extension` into `all`.\n *\n * @param {HtmlExtension} all Extension to merge into.\n * @param {HtmlExtension} extension Extension to merge.\n * @returns {void}\n */\n\n\nfunction htmlExtension(all, extension) {\n  /** @type {string} */\n  var hook;\n\n  for (hook in extension) {\n    var maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined;\n    var left = maybe || (all[hook] = {});\n    var right = extension[hook];\n    /** @type {string} */\n\n    var type = void 0;\n\n    if (right) {\n      for (type in right) {\n        left[type] = right[type];\n      }\n    }\n  }\n}",
        "mapping": {
            "micromark-util-chunked": "{CF11B64D-9921-41EA-93DD-032CC6CE8CC9}"
        },
        "path": "{remark-parse}/../micromark-util-combine-extensions/index.js"
    },
    "{CF11B64D-9921-41EA-93DD-032CC6CE8CC9}": {
        "source": "\"use strict\";\n/**\n* Like `Array#splice`, but smarter for giant arrays.\n*\n* `Array#splice` takes all items to be inserted as individual argument which\n* causes a stack overflow in V8 when trying to insert 100k items for instance.\n*\n* Otherwise, this does not return the removed items, and takes `items` as an\n* array instead of rest parameters.\n*\n* @template {unknown} T\n* @param {T[]} list\n* @param {number} start\n* @param {number} remove\n* @param {T[]} items\n* @returns {void}\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.push = push;\nexports.splice = splice;\n\nfunction splice(list, start, remove, items) {\n  var end = list.length;\n  var chunkStart = 0;\n  /** @type {unknown[]} */\n\n  var parameters; // Make start between zero and `end` (included).\n\n  if (start < 0) {\n    start = -start > end ? 0 : end + start;\n  } else {\n    start = start > end ? end : start;\n  }\n\n  remove = remove > 0 ? remove : 0; // No need to chunk the items if there’s only a couple (10k) items.\n\n  if (items.length < 10000) {\n    parameters = Array.from(items);\n    parameters.unshift(start, remove) // @ts-expect-error Hush, it’s fine.\n    ;\n    [].splice.apply(list, parameters);\n  } else {\n    // Delete `remove` items starting from `start`\n    if (remove) [].splice.apply(list, [start, remove]); // Insert the items in chunks to not cause stack overflows.\n\n    while (chunkStart < items.length) {\n      parameters = items.slice(chunkStart, chunkStart + 10000);\n      parameters.unshift(start, 0) // @ts-expect-error Hush, it’s fine.\n      ;\n      [].splice.apply(list, parameters);\n      chunkStart += 10000;\n      start += 10000;\n    }\n  }\n}\n/**\n * Append `items` (an array) at the end of `list` (another array).\n * When `list` was empty, returns `items` instead.\n *\n * This prevents a potentially expensive operation when `list` is empty,\n * and adds items in batches to prevent V8 from hanging.\n *\n * @template {unknown} T\n * @param {T[]} list\n * @param {T[]} items\n * @returns {T[]}\n */\n\n\nfunction push(list, items) {\n  if (list.length > 0) {\n    splice(list, list.length, 0, items);\n    return list;\n  }\n\n  return items;\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-chunked/index.js"
    },
    "{814CE53A-8C55-4243-B446-F315375E6C42}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n* @typedef {import('micromark-util-types').Initializer} Initializer\n* @typedef {import('micromark-util-types').Token} Token\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.content = void 0;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/** @type {InitialConstruct} */\nvar content = {\n  tokenize: initializeContent\n};\n/** @type {Initializer} */\n\nexports.content = content;\n\nfunction initializeContent(effects) {\n  var contentStart = effects.attempt(this.parser.constructs.contentInitial, afterContentStartConstruct, paragraphInitial);\n  /** @type {Token} */\n\n  var previous;\n  return contentStart;\n  /** @type {State} */\n\n  function afterContentStartConstruct(code) {\n    if (code === null) {\n      effects.consume(code);\n      return;\n    }\n\n    effects.enter('lineEnding');\n    effects.consume(code);\n    effects.exit('lineEnding');\n    return (0, _micromarkFactorySpace.factorySpace)(effects, contentStart, 'linePrefix');\n  }\n  /** @type {State} */\n\n\n  function paragraphInitial(code) {\n    effects.enter('paragraph');\n    return lineStart(code);\n  }\n  /** @type {State} */\n\n\n  function lineStart(code) {\n    var token = effects.enter('chunkText', {\n      contentType: 'text',\n      previous: previous\n    });\n\n    if (previous) {\n      previous.next = token;\n    }\n\n    previous = token;\n    return data(code);\n  }\n  /** @type {State} */\n\n\n  function data(code) {\n    if (code === null) {\n      effects.exit('chunkText');\n      effects.exit('paragraph');\n      effects.consume(code);\n      return;\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.consume(code);\n      effects.exit('chunkText');\n      return lineStart;\n    } // Data.\n\n\n    effects.consume(code);\n    return data;\n  }\n}",
        "mapping": {
            "micromark-factory-space": "{53D6FE78-3E55-447B-BDEF-C8223F4A9E95}",
            "micromark-util-character": "{799E4069-CDF5-4BEB-8747-20AECB3BF441}"
        },
        "path": "{remark-parse}/../micromark/lib/initialize/content.js"
    },
    "{53D6FE78-3E55-447B-BDEF-C8223F4A9E95}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Effects} Effects\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factorySpace = factorySpace;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {string} type\n * @param {number} [max=Infinity]\n * @returns {State}\n */\nfunction factorySpace(effects, ok, type, max) {\n  var limit = max ? max - 1 : Number.POSITIVE_INFINITY;\n  var size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.enter(type);\n      return prefix(code);\n    }\n\n    return ok(code);\n  }\n  /** @type {State} */\n\n\n  function prefix(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code) && size++ < limit) {\n      effects.consume(code);\n      return prefix;\n    }\n\n    effects.exit(type);\n    return ok(code);\n  }\n}",
        "mapping": {
            "micromark-util-character": "{78E1EBE6-7465-4E40-816F-3D60F39E0CDD}"
        },
        "path": "{remark-parse}/../micromark-factory-space/index.js"
    },
    "{78E1EBE6-7465-4E40-816F-3D60F39E0CDD}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {
            "./lib/unicode-punctuation-regex.js": "{7AC81BF3-D023-4128-85D4-1B244797AAE2}"
        },
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{7AC81BF3-D023-4128-85D4-1B244797AAE2}": {
        "source": "\"use strict\"; // This module is generated by `script/`.\n//\n// CommonMark handles attention (emphasis, strong) markers based on what comes\n// before or after them.\n// One such difference is if those characters are Unicode punctuation.\n// This script is generated from the Unicode data.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unicodePunctuationRegex = void 0;\nvar unicodePunctuationRegex = /[!-/:-@[-`{-~\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u2E52\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\nexports.unicodePunctuationRegex = unicodePunctuationRegex;",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/lib/unicode-punctuation-regex.js"
    },
    "{799E4069-CDF5-4BEB-8747-20AECB3BF441}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{2012AD71-193C-4EFA-9D92-45B71E2A45D5}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n* @typedef {import('micromark-util-types').Initializer} Initializer\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n* @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n* @typedef {import('micromark-util-types').Token} Token\n* @typedef {import('micromark-util-types').State} State\n* @typedef {import('micromark-util-types').Point} Point\n*/\n\n/**\n * @typedef {Record<string, unknown>} StackState\n * @typedef {[Construct, StackState]} StackItem\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.document = void 0;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\nvar _micromarkUtilChunked = require(\"micromark-util-chunked\");\n\n/** @type {InitialConstruct} */\nvar document = {\n  tokenize: initializeDocument\n};\n/** @type {Construct} */\n\nexports.document = document;\nvar containerConstruct = {\n  tokenize: tokenizeContainer\n};\n/** @type {Initializer} */\n\nfunction initializeDocument(effects) {\n  var self = this;\n  /** @type {StackItem[]} */\n\n  var stack = [];\n  var continued = 0;\n  /** @type {TokenizeContext|undefined} */\n\n  var childFlow;\n  /** @type {Token|undefined} */\n\n  var childToken;\n  /** @type {number} */\n\n  var lineStartOffset;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    // First we iterate through the open blocks, starting with the root\n    // document, and descending through last children down to the last open\n    // block.\n    // Each block imposes a condition that the line must satisfy if the block is\n    // to remain open.\n    // For example, a block quote requires a `>` character.\n    // A paragraph requires a non-blank line.\n    // In this phase we may match all or just some of the open blocks.\n    // But we cannot close unmatched blocks yet, because we may have a lazy\n    // continuation line.\n    if (continued < stack.length) {\n      var item = stack[continued];\n      self.containerState = item[1];\n      return effects.attempt(item[0].continuation, documentContinue, checkNewContainers)(code);\n    } // Done.\n\n\n    return checkNewContainers(code);\n  }\n  /** @type {State} */\n\n\n  function documentContinue(code) {\n    continued++; // Note: this field is called `_closeFlow` but it also closes containers.\n    // Perhaps a good idea to rename it but it’s already used in the wild by\n    // extensions.\n\n    if (self.containerState._closeFlow) {\n      self.containerState._closeFlow = undefined;\n\n      if (childFlow) {\n        closeFlow();\n      } // Note: this algorithm for moving events around is similar to the\n      // algorithm when dealing with lazy lines in `writeToChild`.\n\n\n      var indexBeforeExits = self.events.length;\n      var indexBeforeFlow = indexBeforeExits;\n      /** @type {Point|undefined} */\n\n      var point; // Find the flow chunk.\n\n      while (indexBeforeFlow--) {\n        if (self.events[indexBeforeFlow][0] === 'exit' && self.events[indexBeforeFlow][1].type === 'chunkFlow') {\n          point = self.events[indexBeforeFlow][1].end;\n          break;\n        }\n      }\n\n      exitContainers(continued); // Fix positions.\n\n      var index = indexBeforeExits;\n\n      while (index < self.events.length) {\n        self.events[index][1].end = Object.assign({}, point);\n        index++;\n      } // Inject the exits earlier (they’re still also at the end).\n\n\n      (0, _micromarkUtilChunked.splice)(self.events, indexBeforeFlow + 1, 0, self.events.slice(indexBeforeExits)); // Discard the duplicate exits.\n\n      self.events.length = index;\n      return checkNewContainers(code);\n    }\n\n    return start(code);\n  }\n  /** @type {State} */\n\n\n  function checkNewContainers(code) {\n    // Next, after consuming the continuation markers for existing blocks, we\n    // look for new block starts (e.g. `>` for a block quote).\n    // If we encounter a new block start, we close any blocks unmatched in\n    // step 1 before creating the new block as a child of the last matched\n    // block.\n    if (continued === stack.length) {\n      // No need to `check` whether there’s a container, of `exitContainers`\n      // would be moot.\n      // We can instead immediately `attempt` to parse one.\n      if (!childFlow) {\n        return documentContinued(code);\n      } // If we have concrete content, such as block HTML or fenced code,\n      // we can’t have containers “pierce” into them, so we can immediately\n      // start.\n\n\n      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {\n        return flowStart(code);\n      } // If we do have flow, it could still be a blank line,\n      // but we’d be interrupting it w/ a new container if there’s a current\n      // construct.\n\n\n      self.interrupt = Boolean(childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack);\n    } // Check if there is a new container.\n\n\n    self.containerState = {};\n    return effects.check(containerConstruct, thereIsANewContainer, thereIsNoNewContainer)(code);\n  }\n  /** @type {State} */\n\n\n  function thereIsANewContainer(code) {\n    if (childFlow) closeFlow();\n    exitContainers(continued);\n    return documentContinued(code);\n  }\n  /** @type {State} */\n\n\n  function thereIsNoNewContainer(code) {\n    self.parser.lazy[self.now().line] = continued !== stack.length;\n    lineStartOffset = self.now().offset;\n    return flowStart(code);\n  }\n  /** @type {State} */\n\n\n  function documentContinued(code) {\n    // Try new containers.\n    self.containerState = {};\n    return effects.attempt(containerConstruct, containerContinue, flowStart)(code);\n  }\n  /** @type {State} */\n\n\n  function containerContinue(code) {\n    continued++;\n    stack.push([self.currentConstruct, self.containerState]); // Try another.\n\n    return documentContinued(code);\n  }\n  /** @type {State} */\n\n\n  function flowStart(code) {\n    if (code === null) {\n      if (childFlow) closeFlow();\n      exitContainers(0);\n      effects.consume(code);\n      return;\n    }\n\n    childFlow = childFlow || self.parser.flow(self.now());\n    effects.enter('chunkFlow', {\n      contentType: 'flow',\n      previous: childToken,\n      _tokenizer: childFlow\n    });\n    return flowContinue(code);\n  }\n  /** @type {State} */\n\n\n  function flowContinue(code) {\n    if (code === null) {\n      writeToChild(effects.exit('chunkFlow'), true);\n      exitContainers(0);\n      effects.consume(code);\n      return;\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.consume(code);\n      writeToChild(effects.exit('chunkFlow')); // Get ready for the next line.\n\n      continued = 0;\n      self.interrupt = undefined;\n      return start;\n    }\n\n    effects.consume(code);\n    return flowContinue;\n  }\n  /**\n   * @param {Token} token\n   * @param {boolean} [eof]\n   * @returns {void}\n   */\n\n\n  function writeToChild(token, eof) {\n    var stream = self.sliceStream(token);\n    if (eof) stream.push(null);\n    token.previous = childToken;\n    if (childToken) childToken.next = token;\n    childToken = token;\n    childFlow.defineSkip(token.start);\n    childFlow.write(stream); // Alright, so we just added a lazy line:\n    //\n    // ```markdown\n    // > a\n    // b.\n    //\n    // Or:\n    //\n    // > ~~~c\n    // d\n    //\n    // Or:\n    //\n    // > | e |\n    // f\n    // ```\n    //\n    // The construct in the second example (fenced code) does not accept lazy\n    // lines, so it marked itself as done at the end of its first line, and\n    // then the content construct parses `d`.\n    // Most constructs in markdown match on the first line: if the first line\n    // forms a construct, a non-lazy line can’t “unmake” it.\n    //\n    // The construct in the third example is potentially a GFM table, and\n    // those are *weird*.\n    // It *could* be a table, from the first line, if the following line\n    // matches a condition.\n    // In this case, that second line is lazy, which “unmakes” the first line\n    // and turns the whole into one content block.\n    //\n    // We’ve now parsed the non-lazy and the lazy line, and can figure out\n    // whether the lazy line started a new flow block.\n    // If it did, we exit the current containers between the two flow blocks.\n\n    if (self.parser.lazy[token.start.line]) {\n      var index = childFlow.events.length;\n\n      while (index--) {\n        if ( // The token starts before the line ending…\n        childFlow.events[index][1].start.offset < lineStartOffset && ( // …and either is not ended yet…\n        !childFlow.events[index][1].end || // …or ends after it.\n        childFlow.events[index][1].end.offset > lineStartOffset)) {\n          // Exit: there’s still something open, which means it’s a lazy line\n          // part of something.\n          return;\n        }\n      } // Note: this algorithm for moving events around is similar to the\n      // algorithm when closing flow in `documentContinue`.\n\n\n      var indexBeforeExits = self.events.length;\n      var indexBeforeFlow = indexBeforeExits;\n      /** @type {boolean|undefined} */\n\n      var seen;\n      /** @type {Point|undefined} */\n\n      var point; // Find the previous chunk (the one before the lazy line).\n\n      while (indexBeforeFlow--) {\n        if (self.events[indexBeforeFlow][0] === 'exit' && self.events[indexBeforeFlow][1].type === 'chunkFlow') {\n          if (seen) {\n            point = self.events[indexBeforeFlow][1].end;\n            break;\n          }\n\n          seen = true;\n        }\n      }\n\n      exitContainers(continued); // Fix positions.\n\n      index = indexBeforeExits;\n\n      while (index < self.events.length) {\n        self.events[index][1].end = Object.assign({}, point);\n        index++;\n      } // Inject the exits earlier (they’re still also at the end).\n\n\n      (0, _micromarkUtilChunked.splice)(self.events, indexBeforeFlow + 1, 0, self.events.slice(indexBeforeExits)); // Discard the duplicate exits.\n\n      self.events.length = index;\n    }\n  }\n  /**\n   * @param {number} size\n   * @returns {void}\n   */\n\n\n  function exitContainers(size) {\n    var index = stack.length; // Exit open containers.\n\n    while (index-- > size) {\n      var entry = stack[index];\n      self.containerState = entry[1];\n      entry[0].exit.call(self, effects);\n    }\n\n    stack.length = size;\n  }\n\n  function closeFlow() {\n    childFlow.write([null]);\n    childToken = undefined;\n    childFlow = undefined;\n    self.containerState._closeFlow = undefined;\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeContainer(effects, ok, nok) {\n  return (0, _micromarkFactorySpace.factorySpace)(effects, effects.attempt(this.parser.constructs.document, ok, nok), 'linePrefix', this.parser.constructs.disable[\"null\"].includes('codeIndented') ? undefined : 4);\n}",
        "mapping": {
            "micromark-factory-space": "{677231C9-FF8C-408C-A6F9-F6C45B888863}",
            "micromark-util-character": "{B33F0EBB-ED78-464C-955D-D64B634CD29B}",
            "micromark-util-chunked": "{508DE96B-96F5-454A-9766-2C4D5E6EFB28}"
        },
        "path": "{remark-parse}/../micromark/lib/initialize/document.js"
    },
    "{677231C9-FF8C-408C-A6F9-F6C45B888863}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Effects} Effects\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factorySpace = factorySpace;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {string} type\n * @param {number} [max=Infinity]\n * @returns {State}\n */\nfunction factorySpace(effects, ok, type, max) {\n  var limit = max ? max - 1 : Number.POSITIVE_INFINITY;\n  var size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.enter(type);\n      return prefix(code);\n    }\n\n    return ok(code);\n  }\n  /** @type {State} */\n\n\n  function prefix(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code) && size++ < limit) {\n      effects.consume(code);\n      return prefix;\n    }\n\n    effects.exit(type);\n    return ok(code);\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-factory-space/index.js"
    },
    "{B33F0EBB-ED78-464C-955D-D64B634CD29B}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{508DE96B-96F5-454A-9766-2C4D5E6EFB28}": {
        "source": "\"use strict\";\n/**\n* Like `Array#splice`, but smarter for giant arrays.\n*\n* `Array#splice` takes all items to be inserted as individual argument which\n* causes a stack overflow in V8 when trying to insert 100k items for instance.\n*\n* Otherwise, this does not return the removed items, and takes `items` as an\n* array instead of rest parameters.\n*\n* @template {unknown} T\n* @param {T[]} list\n* @param {number} start\n* @param {number} remove\n* @param {T[]} items\n* @returns {void}\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.push = push;\nexports.splice = splice;\n\nfunction splice(list, start, remove, items) {\n  var end = list.length;\n  var chunkStart = 0;\n  /** @type {unknown[]} */\n\n  var parameters; // Make start between zero and `end` (included).\n\n  if (start < 0) {\n    start = -start > end ? 0 : end + start;\n  } else {\n    start = start > end ? end : start;\n  }\n\n  remove = remove > 0 ? remove : 0; // No need to chunk the items if there’s only a couple (10k) items.\n\n  if (items.length < 10000) {\n    parameters = Array.from(items);\n    parameters.unshift(start, remove) // @ts-expect-error Hush, it’s fine.\n    ;\n    [].splice.apply(list, parameters);\n  } else {\n    // Delete `remove` items starting from `start`\n    if (remove) [].splice.apply(list, [start, remove]); // Insert the items in chunks to not cause stack overflows.\n\n    while (chunkStart < items.length) {\n      parameters = items.slice(chunkStart, chunkStart + 10000);\n      parameters.unshift(start, 0) // @ts-expect-error Hush, it’s fine.\n      ;\n      [].splice.apply(list, parameters);\n      chunkStart += 10000;\n      start += 10000;\n    }\n  }\n}\n/**\n * Append `items` (an array) at the end of `list` (another array).\n * When `list` was empty, returns `items` instead.\n *\n * This prevents a potentially expensive operation when `list` is empty,\n * and adds items in batches to prevent V8 from hanging.\n *\n * @template {unknown} T\n * @param {T[]} list\n * @param {T[]} items\n * @returns {T[]}\n */\n\n\nfunction push(list, items) {\n  if (list.length > 0) {\n    splice(list, list.length, 0, items);\n    return list;\n  }\n\n  return items;\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-chunked/index.js"
    },
    "{2ADC5173-D1E5-4159-B081-1084C77DC9A0}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n* @typedef {import('micromark-util-types').Initializer} Initializer\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.flow = void 0;\n\nvar _micromarkCoreCommonmark = require(\"micromark-core-commonmark\");\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/** @type {InitialConstruct} */\nvar flow = {\n  tokenize: initializeFlow\n};\n/** @type {Initializer} */\n\nexports.flow = flow;\n\nfunction initializeFlow(effects) {\n  var self = this;\n  var initial = effects.attempt( // Try to parse a blank line.\n  _micromarkCoreCommonmark.blankLine, atBlankEnding, // Try to parse initial flow (essentially, only code).\n  effects.attempt(this.parser.constructs.flowInitial, afterConstruct, (0, _micromarkFactorySpace.factorySpace)(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(_micromarkCoreCommonmark.content, afterConstruct)), 'linePrefix')));\n  return initial;\n  /** @type {State} */\n\n  function atBlankEnding(code) {\n    if (code === null) {\n      effects.consume(code);\n      return;\n    }\n\n    effects.enter('lineEndingBlank');\n    effects.consume(code);\n    effects.exit('lineEndingBlank');\n    self.currentConstruct = undefined;\n    return initial;\n  }\n  /** @type {State} */\n\n\n  function afterConstruct(code) {\n    if (code === null) {\n      effects.consume(code);\n      return;\n    }\n\n    effects.enter('lineEnding');\n    effects.consume(code);\n    effects.exit('lineEnding');\n    self.currentConstruct = undefined;\n    return initial;\n  }\n}",
        "mapping": {
            "micromark-core-commonmark": "{FCBCF778-0A0D-4B82-806D-610F27359AFC}",
            "micromark-factory-space": "{CB6FDCB5-B8E6-43E1-B8FC-5E7AAB4B43CF}",
            "micromark-util-character": "{F9A71FEF-AC56-4E24-A932-D0518F92A183}"
        },
        "path": "{remark-parse}/../micromark/lib/initialize/flow.js"
    },
    "{FCBCF778-0A0D-4B82-806D-610F27359AFC}": {
        "source": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"attention\", {\n  enumerable: true,\n  get: function get() {\n    return _attention.attention;\n  }\n});\nObject.defineProperty(exports, \"autolink\", {\n  enumerable: true,\n  get: function get() {\n    return _autolink.autolink;\n  }\n});\nObject.defineProperty(exports, \"blankLine\", {\n  enumerable: true,\n  get: function get() {\n    return _blankLine.blankLine;\n  }\n});\nObject.defineProperty(exports, \"blockQuote\", {\n  enumerable: true,\n  get: function get() {\n    return _blockQuote.blockQuote;\n  }\n});\nObject.defineProperty(exports, \"characterEscape\", {\n  enumerable: true,\n  get: function get() {\n    return _characterEscape.characterEscape;\n  }\n});\nObject.defineProperty(exports, \"characterReference\", {\n  enumerable: true,\n  get: function get() {\n    return _characterReference.characterReference;\n  }\n});\nObject.defineProperty(exports, \"codeFenced\", {\n  enumerable: true,\n  get: function get() {\n    return _codeFenced.codeFenced;\n  }\n});\nObject.defineProperty(exports, \"codeIndented\", {\n  enumerable: true,\n  get: function get() {\n    return _codeIndented.codeIndented;\n  }\n});\nObject.defineProperty(exports, \"codeText\", {\n  enumerable: true,\n  get: function get() {\n    return _codeText.codeText;\n  }\n});\nObject.defineProperty(exports, \"content\", {\n  enumerable: true,\n  get: function get() {\n    return _content.content;\n  }\n});\nObject.defineProperty(exports, \"definition\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.definition;\n  }\n});\nObject.defineProperty(exports, \"hardBreakEscape\", {\n  enumerable: true,\n  get: function get() {\n    return _hardBreakEscape.hardBreakEscape;\n  }\n});\nObject.defineProperty(exports, \"headingAtx\", {\n  enumerable: true,\n  get: function get() {\n    return _headingAtx.headingAtx;\n  }\n});\nObject.defineProperty(exports, \"htmlFlow\", {\n  enumerable: true,\n  get: function get() {\n    return _htmlFlow.htmlFlow;\n  }\n});\nObject.defineProperty(exports, \"htmlText\", {\n  enumerable: true,\n  get: function get() {\n    return _htmlText.htmlText;\n  }\n});\nObject.defineProperty(exports, \"labelEnd\", {\n  enumerable: true,\n  get: function get() {\n    return _labelEnd.labelEnd;\n  }\n});\nObject.defineProperty(exports, \"labelStartImage\", {\n  enumerable: true,\n  get: function get() {\n    return _labelStartImage.labelStartImage;\n  }\n});\nObject.defineProperty(exports, \"labelStartLink\", {\n  enumerable: true,\n  get: function get() {\n    return _labelStartLink.labelStartLink;\n  }\n});\nObject.defineProperty(exports, \"lineEnding\", {\n  enumerable: true,\n  get: function get() {\n    return _lineEnding.lineEnding;\n  }\n});\nObject.defineProperty(exports, \"list\", {\n  enumerable: true,\n  get: function get() {\n    return _list.list;\n  }\n});\nObject.defineProperty(exports, \"setextUnderline\", {\n  enumerable: true,\n  get: function get() {\n    return _setextUnderline.setextUnderline;\n  }\n});\nObject.defineProperty(exports, \"thematicBreak\", {\n  enumerable: true,\n  get: function get() {\n    return _thematicBreak.thematicBreak;\n  }\n});\n\nvar _attention = require(\"./lib/attention.js\");\n\nvar _autolink = require(\"./lib/autolink.js\");\n\nvar _blankLine = require(\"./lib/blank-line.js\");\n\nvar _blockQuote = require(\"./lib/block-quote.js\");\n\nvar _characterEscape = require(\"./lib/character-escape.js\");\n\nvar _characterReference = require(\"./lib/character-reference.js\");\n\nvar _codeFenced = require(\"./lib/code-fenced.js\");\n\nvar _codeIndented = require(\"./lib/code-indented.js\");\n\nvar _codeText = require(\"./lib/code-text.js\");\n\nvar _content = require(\"./lib/content.js\");\n\nvar _definition = require(\"./lib/definition.js\");\n\nvar _hardBreakEscape = require(\"./lib/hard-break-escape.js\");\n\nvar _headingAtx = require(\"./lib/heading-atx.js\");\n\nvar _htmlFlow = require(\"./lib/html-flow.js\");\n\nvar _htmlText = require(\"./lib/html-text.js\");\n\nvar _labelEnd = require(\"./lib/label-end.js\");\n\nvar _labelStartImage = require(\"./lib/label-start-image.js\");\n\nvar _labelStartLink = require(\"./lib/label-start-link.js\");\n\nvar _lineEnding = require(\"./lib/line-ending.js\");\n\nvar _list = require(\"./lib/list.js\");\n\nvar _setextUnderline = require(\"./lib/setext-underline.js\");\n\nvar _thematicBreak = require(\"./lib/thematic-break.js\");",
        "mapping": {
            "./lib/attention.js": "{EA761F27-A96E-4CF9-B54C-E515ABB2C928}",
            "./lib/autolink.js": "{0EFCC6EF-D1F6-4641-AB7F-DC326EC25D2F}",
            "./lib/blank-line.js": "{AFDCECAD-0F1B-4DDF-B8A0-4B7AEC622F46}",
            "./lib/block-quote.js": "{FEF7F1CF-DE90-4E69-A17E-AB9D9E82DECF}",
            "./lib/character-escape.js": "{7468AF02-F68C-4CF5-B314-8F9CB56BAFFB}",
            "./lib/character-reference.js": "{8FB5B85C-97FF-4C21-9F66-4FFB1596FA8A}",
            "./lib/code-fenced.js": "{655DC6E7-E843-4C16-9290-2D01C3971562}",
            "./lib/code-indented.js": "{391BB839-6E2A-4386-9063-B8B19EE026AC}",
            "./lib/code-text.js": "{B2A94881-A655-4F0D-8259-BF2567F4640F}",
            "./lib/content.js": "{E991CD05-54D8-40D0-8A78-D93F7EDACCAA}",
            "./lib/definition.js": "{F01E11B0-8D92-4F7A-AE5A-5DEA381DD726}",
            "./lib/hard-break-escape.js": "{3CB41A3F-E4A7-4697-A457-410156D2870F}",
            "./lib/heading-atx.js": "{868A9BF8-7966-4F0B-9DC0-98A0CB73FC54}",
            "./lib/html-flow.js": "{E4B39900-5EA8-45BF-917A-4668482B31F8}",
            "./lib/html-text.js": "{46EEFB01-D4D5-4B79-9696-D0AC21887895}",
            "./lib/label-end.js": "{0C59C510-54EE-4531-AA45-A15211DAD1C7}",
            "./lib/label-start-image.js": "{B5A9F5F4-875D-4BF6-BD87-2EE5DACF5BB7}",
            "./lib/label-start-link.js": "{523E41E5-5250-4860-85F4-CE0DCE6317FC}",
            "./lib/line-ending.js": "{C3B770E0-46C7-45B2-9DDB-59E6FC7EA737}",
            "./lib/list.js": "{EB5C361A-188D-4874-8B96-DB139A77064A}",
            "./lib/setext-underline.js": "{A3B1EC3F-0E1E-48B8-B12E-4F17035FCB3E}",
            "./lib/thematic-break.js": "{4652C076-8C94-47B7-8F76-81F1E94A9D65}"
        },
        "path": "{remark-parse}/../micromark-core-commonmark/index.js"
    },
    "{EA761F27-A96E-4CF9-B54C-E515ABB2C928}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n* @typedef {import('micromark-util-types').Resolver} Resolver\n* @typedef {import('micromark-util-types').State} State\n* @typedef {import('micromark-util-types').Token} Token\n* @typedef {import('micromark-util-types').Event} Event\n* @typedef {import('micromark-util-types').Code} Code\n* @typedef {import('micromark-util-types').Point} Point\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.attention = void 0;\n\nvar _micromarkUtilChunked = require(\"micromark-util-chunked\");\n\nvar _micromarkUtilClassifyCharacter = require(\"micromark-util-classify-character\");\n\nvar _micromarkUtilResolveAll = require(\"micromark-util-resolve-all\");\n\n/** @type {Construct} */\nvar attention = {\n  name: 'attention',\n  tokenize: tokenizeAttention,\n  resolveAll: resolveAllAttention\n};\n/**\n * Take all events and resolve attention to emphasis or strong.\n *\n * @type {Resolver}\n */\n\nexports.attention = attention;\n\nfunction resolveAllAttention(events, context) {\n  var index = -1;\n  /** @type {number} */\n\n  var open;\n  /** @type {Token} */\n\n  var group;\n  /** @type {Token} */\n\n  var text;\n  /** @type {Token} */\n\n  var openingSequence;\n  /** @type {Token} */\n\n  var closingSequence;\n  /** @type {number} */\n\n  var use;\n  /** @type {Event[]} */\n\n  var nextEvents;\n  /** @type {number} */\n\n  var offset; // Walk through all events.\n  //\n  // Note: performance of this is fine on an mb of normal markdown, but it’s\n  // a bottleneck for malicious stuff.\n\n  while (++index < events.length) {\n    // Find a token that can close.\n    if (events[index][0] === 'enter' && events[index][1].type === 'attentionSequence' && events[index][1]._close) {\n      open = index; // Now walk back to find an opener.\n\n      while (open--) {\n        // Find a token that can open the closer.\n        if (events[open][0] === 'exit' && events[open][1].type === 'attentionSequence' && events[open][1]._open && // If the markers are the same:\n        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index][1]).charCodeAt(0)) {\n          // If the opening can close or the closing can open,\n          // and the close size *is not* a multiple of three,\n          // but the sum of the opening and closing size *is* multiple of three,\n          // then don’t match.\n          if ((events[open][1]._close || events[index][1]._open) && (events[index][1].end.offset - events[index][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index][1].end.offset - events[index][1].start.offset) % 3)) {\n            continue;\n          } // Number of markers to use from the sequence.\n\n\n          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index][1].end.offset - events[index][1].start.offset > 1 ? 2 : 1;\n          var start = Object.assign({}, events[open][1].end);\n          var end = Object.assign({}, events[index][1].start);\n          movePoint(start, -use);\n          movePoint(end, use);\n          openingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start: start,\n            end: Object.assign({}, events[open][1].end)\n          };\n          closingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start: Object.assign({}, events[index][1].start),\n            end: end\n          };\n          text = {\n            type: use > 1 ? 'strongText' : 'emphasisText',\n            start: Object.assign({}, events[open][1].end),\n            end: Object.assign({}, events[index][1].start)\n          };\n          group = {\n            type: use > 1 ? 'strong' : 'emphasis',\n            start: Object.assign({}, openingSequence.start),\n            end: Object.assign({}, closingSequence.end)\n          };\n          events[open][1].end = Object.assign({}, openingSequence.start);\n          events[index][1].start = Object.assign({}, closingSequence.end);\n          nextEvents = []; // If there are more markers in the opening, add them before.\n\n          if (events[open][1].end.offset - events[open][1].start.offset) {\n            nextEvents = (0, _micromarkUtilChunked.push)(nextEvents, [['enter', events[open][1], context], ['exit', events[open][1], context]]);\n          } // Opening.\n\n\n          nextEvents = (0, _micromarkUtilChunked.push)(nextEvents, [['enter', group, context], ['enter', openingSequence, context], ['exit', openingSequence, context], ['enter', text, context]]); // Between.\n\n          nextEvents = (0, _micromarkUtilChunked.push)(nextEvents, (0, _micromarkUtilResolveAll.resolveAll)(context.parser.constructs.insideSpan[\"null\"], events.slice(open + 1, index), context)); // Closing.\n\n          nextEvents = (0, _micromarkUtilChunked.push)(nextEvents, [['exit', text, context], ['enter', closingSequence, context], ['exit', closingSequence, context], ['exit', group, context]]); // If there are more markers in the closing, add them after.\n\n          if (events[index][1].end.offset - events[index][1].start.offset) {\n            offset = 2;\n            nextEvents = (0, _micromarkUtilChunked.push)(nextEvents, [['enter', events[index][1], context], ['exit', events[index][1], context]]);\n          } else {\n            offset = 0;\n          }\n\n          (0, _micromarkUtilChunked.splice)(events, open - 1, index - open + 3, nextEvents);\n          index = open + nextEvents.length - offset - 2;\n          break;\n        }\n      }\n    }\n  } // Remove remaining sequences.\n\n\n  index = -1;\n\n  while (++index < events.length) {\n    if (events[index][1].type === 'attentionSequence') {\n      events[index][1].type = 'data';\n    }\n  }\n\n  return events;\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeAttention(effects, ok) {\n  var attentionMarkers = this.parser.constructs.attentionMarkers[\"null\"];\n  var previous = this.previous;\n  var before = (0, _micromarkUtilClassifyCharacter.classifyCharacter)(previous);\n  /** @type {NonNullable<Code>} */\n\n  var marker;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('attentionSequence');\n    marker = code;\n    return sequence(code);\n  }\n  /** @type {State} */\n\n\n  function sequence(code) {\n    if (code === marker) {\n      effects.consume(code);\n      return sequence;\n    }\n\n    var token = effects.exit('attentionSequence');\n    var after = (0, _micromarkUtilClassifyCharacter.classifyCharacter)(code);\n    var open = !after || after === 2 && before || attentionMarkers.includes(code);\n    var close = !before || before === 2 && after || attentionMarkers.includes(previous);\n    token._open = Boolean(marker === 42 ? open : open && (before || !close));\n    token._close = Boolean(marker === 42 ? close : close && (after || !open));\n    return ok(code);\n  }\n}\n/**\n * Move a point a bit.\n *\n * Note: `move` only works inside lines! It’s not possible to move past other\n * chunks (replacement characters, tabs, or line endings).\n *\n * @param {Point} point\n * @param {number} offset\n * @returns {void}\n */\n\n\nfunction movePoint(point, offset) {\n  point.column += offset;\n  point.offset += offset;\n  point._bufferIndex += offset;\n}",
        "mapping": {
            "micromark-util-chunked": "{DA3AC250-FB2D-4EA8-B5A2-B12E0F526D22}",
            "micromark-util-classify-character": "{5AF47AB7-D29D-456E-9777-523499E15590}",
            "micromark-util-resolve-all": "{5B730BE2-E6CB-4970-8601-A6942F482240}"
        },
        "path": "{remark-parse}/../micromark-core-commonmark/lib/attention.js"
    },
    "{DA3AC250-FB2D-4EA8-B5A2-B12E0F526D22}": {
        "source": "\"use strict\";\n/**\n* Like `Array#splice`, but smarter for giant arrays.\n*\n* `Array#splice` takes all items to be inserted as individual argument which\n* causes a stack overflow in V8 when trying to insert 100k items for instance.\n*\n* Otherwise, this does not return the removed items, and takes `items` as an\n* array instead of rest parameters.\n*\n* @template {unknown} T\n* @param {T[]} list\n* @param {number} start\n* @param {number} remove\n* @param {T[]} items\n* @returns {void}\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.push = push;\nexports.splice = splice;\n\nfunction splice(list, start, remove, items) {\n  var end = list.length;\n  var chunkStart = 0;\n  /** @type {unknown[]} */\n\n  var parameters; // Make start between zero and `end` (included).\n\n  if (start < 0) {\n    start = -start > end ? 0 : end + start;\n  } else {\n    start = start > end ? end : start;\n  }\n\n  remove = remove > 0 ? remove : 0; // No need to chunk the items if there’s only a couple (10k) items.\n\n  if (items.length < 10000) {\n    parameters = Array.from(items);\n    parameters.unshift(start, remove) // @ts-expect-error Hush, it’s fine.\n    ;\n    [].splice.apply(list, parameters);\n  } else {\n    // Delete `remove` items starting from `start`\n    if (remove) [].splice.apply(list, [start, remove]); // Insert the items in chunks to not cause stack overflows.\n\n    while (chunkStart < items.length) {\n      parameters = items.slice(chunkStart, chunkStart + 10000);\n      parameters.unshift(start, 0) // @ts-expect-error Hush, it’s fine.\n      ;\n      [].splice.apply(list, parameters);\n      chunkStart += 10000;\n      start += 10000;\n    }\n  }\n}\n/**\n * Append `items` (an array) at the end of `list` (another array).\n * When `list` was empty, returns `items` instead.\n *\n * This prevents a potentially expensive operation when `list` is empty,\n * and adds items in batches to prevent V8 from hanging.\n *\n * @template {unknown} T\n * @param {T[]} list\n * @param {T[]} items\n * @returns {T[]}\n */\n\n\nfunction push(list, items) {\n  if (list.length > 0) {\n    splice(list, list.length, 0, items);\n    return list;\n  }\n\n  return items;\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-chunked/index.js"
    },
    "{5AF47AB7-D29D-456E-9777-523499E15590}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.classifyCharacter = classifyCharacter;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * Classify whether a character code represents whitespace, punctuation, or\n * something else.\n *\n * Used for attention (emphasis, strong), whose sequences can open or close\n * based on the class of surrounding characters.\n *\n * Note that eof (`null`) is seen as whitespace.\n *\n * @param {Code} code\n * @returns {number|undefined}\n */\nfunction classifyCharacter(code) {\n  if (code === null || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code) || (0, _micromarkUtilCharacter.unicodeWhitespace)(code)) {\n    return 1;\n  }\n\n  if ((0, _micromarkUtilCharacter.unicodePunctuation)(code)) {\n    return 2;\n  }\n}",
        "mapping": {
            "micromark-util-character": "{7403F759-92D8-42CD-8306-90B219CFAC2C}"
        },
        "path": "{remark-parse}/../micromark-util-classify-character/index.js"
    },
    "{7403F759-92D8-42CD-8306-90B219CFAC2C}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{5B730BE2-E6CB-4970-8601-A6942F482240}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n* @typedef {import('micromark-util-types').Event} Event\n* @typedef {import('micromark-util-types').Resolver} Resolver\n*/\n\n/**\n * Call all `resolveAll`s.\n *\n * @param {{resolveAll?: Resolver}[]} constructs\n * @param {Event[]} events\n * @param {TokenizeContext} context\n * @returns {Event[]}\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveAll = resolveAll;\n\nfunction resolveAll(constructs, events, context) {\n  /** @type {Resolver[]} */\n  var called = [];\n  var index = -1;\n\n  while (++index < constructs.length) {\n    var resolve = constructs[index].resolveAll;\n\n    if (resolve && !called.includes(resolve)) {\n      events = resolve(events, context);\n      called.push(resolve);\n    }\n  }\n\n  return events;\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-resolve-all/index.js"
    },
    "{0EFCC6EF-D1F6-4641-AB7F-DC326EC25D2F}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.autolink = void 0;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/** @type {Construct} */\nvar autolink = {\n  name: 'autolink',\n  tokenize: tokenizeAutolink\n};\n/** @type {Tokenizer} */\n\nexports.autolink = autolink;\n\nfunction tokenizeAutolink(effects, ok, nok) {\n  var size = 1;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('autolink');\n    effects.enter('autolinkMarker');\n    effects.consume(code);\n    effects.exit('autolinkMarker');\n    effects.enter('autolinkProtocol');\n    return open;\n  }\n  /** @type {State} */\n\n\n  function open(code) {\n    if ((0, _micromarkUtilCharacter.asciiAlpha)(code)) {\n      effects.consume(code);\n      return schemeOrEmailAtext;\n    }\n\n    return (0, _micromarkUtilCharacter.asciiAtext)(code) ? emailAtext(code) : nok(code);\n  }\n  /** @type {State} */\n\n\n  function schemeOrEmailAtext(code) {\n    return code === 43 || code === 45 || code === 46 || (0, _micromarkUtilCharacter.asciiAlphanumeric)(code) ? schemeInsideOrEmailAtext(code) : emailAtext(code);\n  }\n  /** @type {State} */\n\n\n  function schemeInsideOrEmailAtext(code) {\n    if (code === 58) {\n      effects.consume(code);\n      return urlInside;\n    }\n\n    if ((code === 43 || code === 45 || code === 46 || (0, _micromarkUtilCharacter.asciiAlphanumeric)(code)) && size++ < 32) {\n      effects.consume(code);\n      return schemeInsideOrEmailAtext;\n    }\n\n    return emailAtext(code);\n  }\n  /** @type {State} */\n\n\n  function urlInside(code) {\n    if (code === 62) {\n      effects.exit('autolinkProtocol');\n      return end(code);\n    }\n\n    if (code === null || code === 32 || code === 60 || (0, _micromarkUtilCharacter.asciiControl)(code)) {\n      return nok(code);\n    }\n\n    effects.consume(code);\n    return urlInside;\n  }\n  /** @type {State} */\n\n\n  function emailAtext(code) {\n    if (code === 64) {\n      effects.consume(code);\n      size = 0;\n      return emailAtSignOrDot;\n    }\n\n    if ((0, _micromarkUtilCharacter.asciiAtext)(code)) {\n      effects.consume(code);\n      return emailAtext;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function emailAtSignOrDot(code) {\n    return (0, _micromarkUtilCharacter.asciiAlphanumeric)(code) ? emailLabel(code) : nok(code);\n  }\n  /** @type {State} */\n\n\n  function emailLabel(code) {\n    if (code === 46) {\n      effects.consume(code);\n      size = 0;\n      return emailAtSignOrDot;\n    }\n\n    if (code === 62) {\n      // Exit, then change the type.\n      effects.exit('autolinkProtocol').type = 'autolinkEmail';\n      return end(code);\n    }\n\n    return emailValue(code);\n  }\n  /** @type {State} */\n\n\n  function emailValue(code) {\n    if ((code === 45 || (0, _micromarkUtilCharacter.asciiAlphanumeric)(code)) && size++ < 63) {\n      effects.consume(code);\n      return code === 45 ? emailValue : emailLabel;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function end(code) {\n    effects.enter('autolinkMarker');\n    effects.consume(code);\n    effects.exit('autolinkMarker');\n    effects.exit('autolink');\n    return ok;\n  }\n}",
        "mapping": {
            "micromark-util-character": "{2408E2DF-EE33-47AD-B054-C3AC9E3A5003}"
        },
        "path": "{remark-parse}/../micromark-core-commonmark/lib/autolink.js"
    },
    "{2408E2DF-EE33-47AD-B054-C3AC9E3A5003}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{AFDCECAD-0F1B-4DDF-B8A0-4B7AEC622F46}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.blankLine = void 0;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/** @type {Construct} */\nvar blankLine = {\n  tokenize: tokenizeBlankLine,\n  partial: true\n};\n/** @type {Tokenizer} */\n\nexports.blankLine = blankLine;\n\nfunction tokenizeBlankLine(effects, ok, nok) {\n  return (0, _micromarkFactorySpace.factorySpace)(effects, afterWhitespace, 'linePrefix');\n  /** @type {State} */\n\n  function afterWhitespace(code) {\n    return code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code) ? ok(code) : nok(code);\n  }\n}",
        "mapping": {
            "micromark-factory-space": "{ED5D709A-8208-4EF3-9C62-9E618BEAF460}",
            "micromark-util-character": "{31FF3714-52F1-4D6E-9FAF-8A5701A1D282}"
        },
        "path": "{remark-parse}/../micromark-core-commonmark/lib/blank-line.js"
    },
    "{ED5D709A-8208-4EF3-9C62-9E618BEAF460}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Effects} Effects\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factorySpace = factorySpace;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {string} type\n * @param {number} [max=Infinity]\n * @returns {State}\n */\nfunction factorySpace(effects, ok, type, max) {\n  var limit = max ? max - 1 : Number.POSITIVE_INFINITY;\n  var size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.enter(type);\n      return prefix(code);\n    }\n\n    return ok(code);\n  }\n  /** @type {State} */\n\n\n  function prefix(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code) && size++ < limit) {\n      effects.consume(code);\n      return prefix;\n    }\n\n    effects.exit(type);\n    return ok(code);\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-factory-space/index.js"
    },
    "{31FF3714-52F1-4D6E-9FAF-8A5701A1D282}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{FEF7F1CF-DE90-4E69-A17E-AB9D9E82DECF}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n* @typedef {import('micromark-util-types').Exiter} Exiter\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.blockQuote = void 0;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/** @type {Construct} */\nvar blockQuote = {\n  name: 'blockQuote',\n  tokenize: tokenizeBlockQuoteStart,\n  continuation: {\n    tokenize: tokenizeBlockQuoteContinuation\n  },\n  exit: exit\n};\n/** @type {Tokenizer} */\n\nexports.blockQuote = blockQuote;\n\nfunction tokenizeBlockQuoteStart(effects, ok, nok) {\n  var self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (code === 62) {\n      var state = self.containerState;\n\n      if (!state.open) {\n        effects.enter('blockQuote', {\n          _container: true\n        });\n        state.open = true;\n      }\n\n      effects.enter('blockQuotePrefix');\n      effects.enter('blockQuoteMarker');\n      effects.consume(code);\n      effects.exit('blockQuoteMarker');\n      return after;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.enter('blockQuotePrefixWhitespace');\n      effects.consume(code);\n      effects.exit('blockQuotePrefixWhitespace');\n      effects.exit('blockQuotePrefix');\n      return ok;\n    }\n\n    effects.exit('blockQuotePrefix');\n    return ok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeBlockQuoteContinuation(effects, ok, nok) {\n  return (0, _micromarkFactorySpace.factorySpace)(effects, effects.attempt(blockQuote, ok, nok), 'linePrefix', this.parser.constructs.disable[\"null\"].includes('codeIndented') ? undefined : 4);\n}\n/** @type {Exiter} */\n\n\nfunction exit(effects) {\n  effects.exit('blockQuote');\n}",
        "mapping": {
            "micromark-factory-space": "{13B50BD3-C1AC-4792-B57E-27A870D97934}",
            "micromark-util-character": "{2DE5CBD2-3F10-4154-B286-B169D4C6CB92}"
        },
        "path": "{remark-parse}/../micromark-core-commonmark/lib/block-quote.js"
    },
    "{13B50BD3-C1AC-4792-B57E-27A870D97934}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Effects} Effects\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factorySpace = factorySpace;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {string} type\n * @param {number} [max=Infinity]\n * @returns {State}\n */\nfunction factorySpace(effects, ok, type, max) {\n  var limit = max ? max - 1 : Number.POSITIVE_INFINITY;\n  var size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.enter(type);\n      return prefix(code);\n    }\n\n    return ok(code);\n  }\n  /** @type {State} */\n\n\n  function prefix(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code) && size++ < limit) {\n      effects.consume(code);\n      return prefix;\n    }\n\n    effects.exit(type);\n    return ok(code);\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-factory-space/index.js"
    },
    "{2DE5CBD2-3F10-4154-B286-B169D4C6CB92}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{7468AF02-F68C-4CF5-B314-8F9CB56BAFFB}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.characterEscape = void 0;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/** @type {Construct} */\nvar characterEscape = {\n  name: 'characterEscape',\n  tokenize: tokenizeCharacterEscape\n};\n/** @type {Tokenizer} */\n\nexports.characterEscape = characterEscape;\n\nfunction tokenizeCharacterEscape(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('characterEscape');\n    effects.enter('escapeMarker');\n    effects.consume(code);\n    effects.exit('escapeMarker');\n    return open;\n  }\n  /** @type {State} */\n\n\n  function open(code) {\n    if ((0, _micromarkUtilCharacter.asciiPunctuation)(code)) {\n      effects.enter('characterEscapeValue');\n      effects.consume(code);\n      effects.exit('characterEscapeValue');\n      effects.exit('characterEscape');\n      return ok;\n    }\n\n    return nok(code);\n  }\n}",
        "mapping": {
            "micromark-util-character": "{CEE14100-70CA-498B-9E97-8477057517DC}"
        },
        "path": "{remark-parse}/../micromark-core-commonmark/lib/character-escape.js"
    },
    "{CEE14100-70CA-498B-9E97-8477057517DC}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{8FB5B85C-97FF-4C21-9F66-4FFB1596FA8A}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n* @typedef {import('micromark-util-types').Token} Token\n* @typedef {import('micromark-util-types').State} State\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.characterReference = void 0;\n\nvar _decodeNamedCharacterReference = require(\"decode-named-character-reference\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/** @type {Construct} */\nvar characterReference = {\n  name: 'characterReference',\n  tokenize: tokenizeCharacterReference\n};\n/** @type {Tokenizer} */\n\nexports.characterReference = characterReference;\n\nfunction tokenizeCharacterReference(effects, ok, nok) {\n  var self = this;\n  var size = 0;\n  /** @type {number} */\n\n  var max;\n  /** @type {(code: Code) => code is number} */\n\n  var test;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('characterReference');\n    effects.enter('characterReferenceMarker');\n    effects.consume(code);\n    effects.exit('characterReferenceMarker');\n    return open;\n  }\n  /** @type {State} */\n\n\n  function open(code) {\n    if (code === 35) {\n      effects.enter('characterReferenceMarkerNumeric');\n      effects.consume(code);\n      effects.exit('characterReferenceMarkerNumeric');\n      return numeric;\n    }\n\n    effects.enter('characterReferenceValue');\n    max = 31;\n    test = _micromarkUtilCharacter.asciiAlphanumeric;\n    return value(code);\n  }\n  /** @type {State} */\n\n\n  function numeric(code) {\n    if (code === 88 || code === 120) {\n      effects.enter('characterReferenceMarkerHexadecimal');\n      effects.consume(code);\n      effects.exit('characterReferenceMarkerHexadecimal');\n      effects.enter('characterReferenceValue');\n      max = 6;\n      test = _micromarkUtilCharacter.asciiHexDigit;\n      return value;\n    }\n\n    effects.enter('characterReferenceValue');\n    max = 7;\n    test = _micromarkUtilCharacter.asciiDigit;\n    return value(code);\n  }\n  /** @type {State} */\n\n\n  function value(code) {\n    /** @type {Token} */\n    var token;\n\n    if (code === 59 && size) {\n      token = effects.exit('characterReferenceValue');\n\n      if (test === _micromarkUtilCharacter.asciiAlphanumeric && !(0, _decodeNamedCharacterReference.decodeNamedCharacterReference)(self.sliceSerialize(token))) {\n        return nok(code);\n      }\n\n      effects.enter('characterReferenceMarker');\n      effects.consume(code);\n      effects.exit('characterReferenceMarker');\n      effects.exit('characterReference');\n      return ok;\n    }\n\n    if (test(code) && size++ < max) {\n      effects.consume(code);\n      return value;\n    }\n\n    return nok(code);\n  }\n}",
        "mapping": {
            "decode-named-character-reference": "{B44B4CAB-08DD-4FCF-B189-7A420E66537B}",
            "micromark-util-character": "{6475C042-06C8-43EA-B92B-CCA5DA746811}"
        },
        "path": "{remark-parse}/../micromark-core-commonmark/lib/character-reference.js"
    },
    "{B44B4CAB-08DD-4FCF-B189-7A420E66537B}": {
        "source": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeNamedCharacterReference = decodeNamedCharacterReference;\n\nvar _characterEntities = require(\"character-entities\");\n\nvar own = {}.hasOwnProperty;\n/**\n * Decode a single character reference (without the `&` or `;`).\n * You probably only need this when you’re building parsers yourself that follow\n * different rules compared to HTML.\n * This is optimized to be tiny in browsers.\n *\n * @param {string} value\n *   `notin` (named), `#123` (deci), `#x123` (hexa).\n * @returns {string|false}\n *   Decoded reference.\n */\n\nfunction decodeNamedCharacterReference(value) {\n  return own.call(_characterEntities.characterEntities, value) ? _characterEntities.characterEntities[value] : false;\n}",
        "mapping": {
            "character-entities": "{7085CCFD-F3E9-49EC-85E9-EAB6491C2A32}"
        },
        "path": "{remark-parse}/../decode-named-character-reference/index.js"
    },
    "{7085CCFD-F3E9-49EC-85E9-EAB6491C2A32}": {
        "source": "\"use strict\";\n/**\n* Map of named character references.\n*\n* @type {Record<string, string>}\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.characterEntities = void 0;\nvar characterEntities = {\n  AEli: 'Æ',\n  AElig: 'Æ',\n  AM: '&',\n  AMP: '&',\n  Aacut: 'Á',\n  Aacute: 'Á',\n  Abreve: 'Ă',\n  Acir: 'Â',\n  Acirc: 'Â',\n  Acy: 'А',\n  Afr: '𝔄',\n  Agrav: 'À',\n  Agrave: 'À',\n  Alpha: 'Α',\n  Amacr: 'Ā',\n  And: '⩓',\n  Aogon: 'Ą',\n  Aopf: '𝔸',\n  ApplyFunction: '⁡',\n  Arin: 'Å',\n  Aring: 'Å',\n  Ascr: '𝒜',\n  Assign: '≔',\n  Atild: 'Ã',\n  Atilde: 'Ã',\n  Aum: 'Ä',\n  Auml: 'Ä',\n  Backslash: '∖',\n  Barv: '⫧',\n  Barwed: '⌆',\n  Bcy: 'Б',\n  Because: '∵',\n  Bernoullis: 'ℬ',\n  Beta: 'Β',\n  Bfr: '𝔅',\n  Bopf: '𝔹',\n  Breve: '˘',\n  Bscr: 'ℬ',\n  Bumpeq: '≎',\n  CHcy: 'Ч',\n  COP: '©',\n  COPY: '©',\n  Cacute: 'Ć',\n  Cap: '⋒',\n  CapitalDifferentialD: 'ⅅ',\n  Cayleys: 'ℭ',\n  Ccaron: 'Č',\n  Ccedi: 'Ç',\n  Ccedil: 'Ç',\n  Ccirc: 'Ĉ',\n  Cconint: '∰',\n  Cdot: 'Ċ',\n  Cedilla: '¸',\n  CenterDot: '·',\n  Cfr: 'ℭ',\n  Chi: 'Χ',\n  CircleDot: '⊙',\n  CircleMinus: '⊖',\n  CirclePlus: '⊕',\n  CircleTimes: '⊗',\n  ClockwiseContourIntegral: '∲',\n  CloseCurlyDoubleQuote: '”',\n  CloseCurlyQuote: '’',\n  Colon: '∷',\n  Colone: '⩴',\n  Congruent: '≡',\n  Conint: '∯',\n  ContourIntegral: '∮',\n  Copf: 'ℂ',\n  Coproduct: '∐',\n  CounterClockwiseContourIntegral: '∳',\n  Cross: '⨯',\n  Cscr: '𝒞',\n  Cup: '⋓',\n  CupCap: '≍',\n  DD: 'ⅅ',\n  DDotrahd: '⤑',\n  DJcy: 'Ђ',\n  DScy: 'Ѕ',\n  DZcy: 'Џ',\n  Dagger: '‡',\n  Darr: '↡',\n  Dashv: '⫤',\n  Dcaron: 'Ď',\n  Dcy: 'Д',\n  Del: '∇',\n  Delta: 'Δ',\n  Dfr: '𝔇',\n  DiacriticalAcute: '´',\n  DiacriticalDot: '˙',\n  DiacriticalDoubleAcute: '˝',\n  DiacriticalGrave: '`',\n  DiacriticalTilde: '˜',\n  Diamond: '⋄',\n  DifferentialD: 'ⅆ',\n  Dopf: '𝔻',\n  Dot: '¨',\n  DotDot: '⃜',\n  DotEqual: '≐',\n  DoubleContourIntegral: '∯',\n  DoubleDot: '¨',\n  DoubleDownArrow: '⇓',\n  DoubleLeftArrow: '⇐',\n  DoubleLeftRightArrow: '⇔',\n  DoubleLeftTee: '⫤',\n  DoubleLongLeftArrow: '⟸',\n  DoubleLongLeftRightArrow: '⟺',\n  DoubleLongRightArrow: '⟹',\n  DoubleRightArrow: '⇒',\n  DoubleRightTee: '⊨',\n  DoubleUpArrow: '⇑',\n  DoubleUpDownArrow: '⇕',\n  DoubleVerticalBar: '∥',\n  DownArrow: '↓',\n  DownArrowBar: '⤓',\n  DownArrowUpArrow: '⇵',\n  DownBreve: '̑',\n  DownLeftRightVector: '⥐',\n  DownLeftTeeVector: '⥞',\n  DownLeftVector: '↽',\n  DownLeftVectorBar: '⥖',\n  DownRightTeeVector: '⥟',\n  DownRightVector: '⇁',\n  DownRightVectorBar: '⥗',\n  DownTee: '⊤',\n  DownTeeArrow: '↧',\n  Downarrow: '⇓',\n  Dscr: '𝒟',\n  Dstrok: 'Đ',\n  ENG: 'Ŋ',\n  ET: 'Ð',\n  ETH: 'Ð',\n  Eacut: 'É',\n  Eacute: 'É',\n  Ecaron: 'Ě',\n  Ecir: 'Ê',\n  Ecirc: 'Ê',\n  Ecy: 'Э',\n  Edot: 'Ė',\n  Efr: '𝔈',\n  Egrav: 'È',\n  Egrave: 'È',\n  Element: '∈',\n  Emacr: 'Ē',\n  EmptySmallSquare: '◻',\n  EmptyVerySmallSquare: '▫',\n  Eogon: 'Ę',\n  Eopf: '𝔼',\n  Epsilon: 'Ε',\n  Equal: '⩵',\n  EqualTilde: '≂',\n  Equilibrium: '⇌',\n  Escr: 'ℰ',\n  Esim: '⩳',\n  Eta: 'Η',\n  Eum: 'Ë',\n  Euml: 'Ë',\n  Exists: '∃',\n  ExponentialE: 'ⅇ',\n  Fcy: 'Ф',\n  Ffr: '𝔉',\n  FilledSmallSquare: '◼',\n  FilledVerySmallSquare: '▪',\n  Fopf: '𝔽',\n  ForAll: '∀',\n  Fouriertrf: 'ℱ',\n  Fscr: 'ℱ',\n  GJcy: 'Ѓ',\n  G: '>',\n  GT: '>',\n  Gamma: 'Γ',\n  Gammad: 'Ϝ',\n  Gbreve: 'Ğ',\n  Gcedil: 'Ģ',\n  Gcirc: 'Ĝ',\n  Gcy: 'Г',\n  Gdot: 'Ġ',\n  Gfr: '𝔊',\n  Gg: '⋙',\n  Gopf: '𝔾',\n  GreaterEqual: '≥',\n  GreaterEqualLess: '⋛',\n  GreaterFullEqual: '≧',\n  GreaterGreater: '⪢',\n  GreaterLess: '≷',\n  GreaterSlantEqual: '⩾',\n  GreaterTilde: '≳',\n  Gscr: '𝒢',\n  Gt: '≫',\n  HARDcy: 'Ъ',\n  Hacek: 'ˇ',\n  Hat: '^',\n  Hcirc: 'Ĥ',\n  Hfr: 'ℌ',\n  HilbertSpace: 'ℋ',\n  Hopf: 'ℍ',\n  HorizontalLine: '─',\n  Hscr: 'ℋ',\n  Hstrok: 'Ħ',\n  HumpDownHump: '≎',\n  HumpEqual: '≏',\n  IEcy: 'Е',\n  IJlig: 'Ĳ',\n  IOcy: 'Ё',\n  Iacut: 'Í',\n  Iacute: 'Í',\n  Icir: 'Î',\n  Icirc: 'Î',\n  Icy: 'И',\n  Idot: 'İ',\n  Ifr: 'ℑ',\n  Igrav: 'Ì',\n  Igrave: 'Ì',\n  Im: 'ℑ',\n  Imacr: 'Ī',\n  ImaginaryI: 'ⅈ',\n  Implies: '⇒',\n  Int: '∬',\n  Integral: '∫',\n  Intersection: '⋂',\n  InvisibleComma: '⁣',\n  InvisibleTimes: '⁢',\n  Iogon: 'Į',\n  Iopf: '𝕀',\n  Iota: 'Ι',\n  Iscr: 'ℐ',\n  Itilde: 'Ĩ',\n  Iukcy: 'І',\n  Ium: 'Ï',\n  Iuml: 'Ï',\n  Jcirc: 'Ĵ',\n  Jcy: 'Й',\n  Jfr: '𝔍',\n  Jopf: '𝕁',\n  Jscr: '𝒥',\n  Jsercy: 'Ј',\n  Jukcy: 'Є',\n  KHcy: 'Х',\n  KJcy: 'Ќ',\n  Kappa: 'Κ',\n  Kcedil: 'Ķ',\n  Kcy: 'К',\n  Kfr: '𝔎',\n  Kopf: '𝕂',\n  Kscr: '𝒦',\n  LJcy: 'Љ',\n  L: '<',\n  LT: '<',\n  Lacute: 'Ĺ',\n  Lambda: 'Λ',\n  Lang: '⟪',\n  Laplacetrf: 'ℒ',\n  Larr: '↞',\n  Lcaron: 'Ľ',\n  Lcedil: 'Ļ',\n  Lcy: 'Л',\n  LeftAngleBracket: '⟨',\n  LeftArrow: '←',\n  LeftArrowBar: '⇤',\n  LeftArrowRightArrow: '⇆',\n  LeftCeiling: '⌈',\n  LeftDoubleBracket: '⟦',\n  LeftDownTeeVector: '⥡',\n  LeftDownVector: '⇃',\n  LeftDownVectorBar: '⥙',\n  LeftFloor: '⌊',\n  LeftRightArrow: '↔',\n  LeftRightVector: '⥎',\n  LeftTee: '⊣',\n  LeftTeeArrow: '↤',\n  LeftTeeVector: '⥚',\n  LeftTriangle: '⊲',\n  LeftTriangleBar: '⧏',\n  LeftTriangleEqual: '⊴',\n  LeftUpDownVector: '⥑',\n  LeftUpTeeVector: '⥠',\n  LeftUpVector: '↿',\n  LeftUpVectorBar: '⥘',\n  LeftVector: '↼',\n  LeftVectorBar: '⥒',\n  Leftarrow: '⇐',\n  Leftrightarrow: '⇔',\n  LessEqualGreater: '⋚',\n  LessFullEqual: '≦',\n  LessGreater: '≶',\n  LessLess: '⪡',\n  LessSlantEqual: '⩽',\n  LessTilde: '≲',\n  Lfr: '𝔏',\n  Ll: '⋘',\n  Lleftarrow: '⇚',\n  Lmidot: 'Ŀ',\n  LongLeftArrow: '⟵',\n  LongLeftRightArrow: '⟷',\n  LongRightArrow: '⟶',\n  Longleftarrow: '⟸',\n  Longleftrightarrow: '⟺',\n  Longrightarrow: '⟹',\n  Lopf: '𝕃',\n  LowerLeftArrow: '↙',\n  LowerRightArrow: '↘',\n  Lscr: 'ℒ',\n  Lsh: '↰',\n  Lstrok: 'Ł',\n  Lt: '≪',\n  Map: '⤅',\n  Mcy: 'М',\n  MediumSpace: ' ',\n  Mellintrf: 'ℳ',\n  Mfr: '𝔐',\n  MinusPlus: '∓',\n  Mopf: '𝕄',\n  Mscr: 'ℳ',\n  Mu: 'Μ',\n  NJcy: 'Њ',\n  Nacute: 'Ń',\n  Ncaron: 'Ň',\n  Ncedil: 'Ņ',\n  Ncy: 'Н',\n  NegativeMediumSpace: '​',\n  NegativeThickSpace: '​',\n  NegativeThinSpace: '​',\n  NegativeVeryThinSpace: '​',\n  NestedGreaterGreater: '≫',\n  NestedLessLess: '≪',\n  NewLine: '\\n',\n  Nfr: '𝔑',\n  NoBreak: '⁠',\n  NonBreakingSpace: ' ',\n  Nopf: 'ℕ',\n  Not: '⫬',\n  NotCongruent: '≢',\n  NotCupCap: '≭',\n  NotDoubleVerticalBar: '∦',\n  NotElement: '∉',\n  NotEqual: '≠',\n  NotEqualTilde: '≂̸',\n  NotExists: '∄',\n  NotGreater: '≯',\n  NotGreaterEqual: '≱',\n  NotGreaterFullEqual: '≧̸',\n  NotGreaterGreater: '≫̸',\n  NotGreaterLess: '≹',\n  NotGreaterSlantEqual: '⩾̸',\n  NotGreaterTilde: '≵',\n  NotHumpDownHump: '≎̸',\n  NotHumpEqual: '≏̸',\n  NotLeftTriangle: '⋪',\n  NotLeftTriangleBar: '⧏̸',\n  NotLeftTriangleEqual: '⋬',\n  NotLess: '≮',\n  NotLessEqual: '≰',\n  NotLessGreater: '≸',\n  NotLessLess: '≪̸',\n  NotLessSlantEqual: '⩽̸',\n  NotLessTilde: '≴',\n  NotNestedGreaterGreater: '⪢̸',\n  NotNestedLessLess: '⪡̸',\n  NotPrecedes: '⊀',\n  NotPrecedesEqual: '⪯̸',\n  NotPrecedesSlantEqual: '⋠',\n  NotReverseElement: '∌',\n  NotRightTriangle: '⋫',\n  NotRightTriangleBar: '⧐̸',\n  NotRightTriangleEqual: '⋭',\n  NotSquareSubset: '⊏̸',\n  NotSquareSubsetEqual: '⋢',\n  NotSquareSuperset: '⊐̸',\n  NotSquareSupersetEqual: '⋣',\n  NotSubset: '⊂⃒',\n  NotSubsetEqual: '⊈',\n  NotSucceeds: '⊁',\n  NotSucceedsEqual: '⪰̸',\n  NotSucceedsSlantEqual: '⋡',\n  NotSucceedsTilde: '≿̸',\n  NotSuperset: '⊃⃒',\n  NotSupersetEqual: '⊉',\n  NotTilde: '≁',\n  NotTildeEqual: '≄',\n  NotTildeFullEqual: '≇',\n  NotTildeTilde: '≉',\n  NotVerticalBar: '∤',\n  Nscr: '𝒩',\n  Ntild: 'Ñ',\n  Ntilde: 'Ñ',\n  Nu: 'Ν',\n  OElig: 'Œ',\n  Oacut: 'Ó',\n  Oacute: 'Ó',\n  Ocir: 'Ô',\n  Ocirc: 'Ô',\n  Ocy: 'О',\n  Odblac: 'Ő',\n  Ofr: '𝔒',\n  Ograv: 'Ò',\n  Ograve: 'Ò',\n  Omacr: 'Ō',\n  Omega: 'Ω',\n  Omicron: 'Ο',\n  Oopf: '𝕆',\n  OpenCurlyDoubleQuote: '“',\n  OpenCurlyQuote: '‘',\n  Or: '⩔',\n  Oscr: '𝒪',\n  Oslas: 'Ø',\n  Oslash: 'Ø',\n  Otild: 'Õ',\n  Otilde: 'Õ',\n  Otimes: '⨷',\n  Oum: 'Ö',\n  Ouml: 'Ö',\n  OverBar: '‾',\n  OverBrace: '⏞',\n  OverBracket: '⎴',\n  OverParenthesis: '⏜',\n  PartialD: '∂',\n  Pcy: 'П',\n  Pfr: '𝔓',\n  Phi: 'Φ',\n  Pi: 'Π',\n  PlusMinus: '±',\n  Poincareplane: 'ℌ',\n  Popf: 'ℙ',\n  Pr: '⪻',\n  Precedes: '≺',\n  PrecedesEqual: '⪯',\n  PrecedesSlantEqual: '≼',\n  PrecedesTilde: '≾',\n  Prime: '″',\n  Product: '∏',\n  Proportion: '∷',\n  Proportional: '∝',\n  Pscr: '𝒫',\n  Psi: 'Ψ',\n  QUO: '\"',\n  QUOT: '\"',\n  Qfr: '𝔔',\n  Qopf: 'ℚ',\n  Qscr: '𝒬',\n  RBarr: '⤐',\n  RE: '®',\n  REG: '®',\n  Racute: 'Ŕ',\n  Rang: '⟫',\n  Rarr: '↠',\n  Rarrtl: '⤖',\n  Rcaron: 'Ř',\n  Rcedil: 'Ŗ',\n  Rcy: 'Р',\n  Re: 'ℜ',\n  ReverseElement: '∋',\n  ReverseEquilibrium: '⇋',\n  ReverseUpEquilibrium: '⥯',\n  Rfr: 'ℜ',\n  Rho: 'Ρ',\n  RightAngleBracket: '⟩',\n  RightArrow: '→',\n  RightArrowBar: '⇥',\n  RightArrowLeftArrow: '⇄',\n  RightCeiling: '⌉',\n  RightDoubleBracket: '⟧',\n  RightDownTeeVector: '⥝',\n  RightDownVector: '⇂',\n  RightDownVectorBar: '⥕',\n  RightFloor: '⌋',\n  RightTee: '⊢',\n  RightTeeArrow: '↦',\n  RightTeeVector: '⥛',\n  RightTriangle: '⊳',\n  RightTriangleBar: '⧐',\n  RightTriangleEqual: '⊵',\n  RightUpDownVector: '⥏',\n  RightUpTeeVector: '⥜',\n  RightUpVector: '↾',\n  RightUpVectorBar: '⥔',\n  RightVector: '⇀',\n  RightVectorBar: '⥓',\n  Rightarrow: '⇒',\n  Ropf: 'ℝ',\n  RoundImplies: '⥰',\n  Rrightarrow: '⇛',\n  Rscr: 'ℛ',\n  Rsh: '↱',\n  RuleDelayed: '⧴',\n  SHCHcy: 'Щ',\n  SHcy: 'Ш',\n  SOFTcy: 'Ь',\n  Sacute: 'Ś',\n  Sc: '⪼',\n  Scaron: 'Š',\n  Scedil: 'Ş',\n  Scirc: 'Ŝ',\n  Scy: 'С',\n  Sfr: '𝔖',\n  ShortDownArrow: '↓',\n  ShortLeftArrow: '←',\n  ShortRightArrow: '→',\n  ShortUpArrow: '↑',\n  Sigma: 'Σ',\n  SmallCircle: '∘',\n  Sopf: '𝕊',\n  Sqrt: '√',\n  Square: '□',\n  SquareIntersection: '⊓',\n  SquareSubset: '⊏',\n  SquareSubsetEqual: '⊑',\n  SquareSuperset: '⊐',\n  SquareSupersetEqual: '⊒',\n  SquareUnion: '⊔',\n  Sscr: '𝒮',\n  Star: '⋆',\n  Sub: '⋐',\n  Subset: '⋐',\n  SubsetEqual: '⊆',\n  Succeeds: '≻',\n  SucceedsEqual: '⪰',\n  SucceedsSlantEqual: '≽',\n  SucceedsTilde: '≿',\n  SuchThat: '∋',\n  Sum: '∑',\n  Sup: '⋑',\n  Superset: '⊃',\n  SupersetEqual: '⊇',\n  Supset: '⋑',\n  THOR: 'Þ',\n  THORN: 'Þ',\n  TRADE: '™',\n  TSHcy: 'Ћ',\n  TScy: 'Ц',\n  Tab: '\\t',\n  Tau: 'Τ',\n  Tcaron: 'Ť',\n  Tcedil: 'Ţ',\n  Tcy: 'Т',\n  Tfr: '𝔗',\n  Therefore: '∴',\n  Theta: 'Θ',\n  ThickSpace: '  ',\n  ThinSpace: ' ',\n  Tilde: '∼',\n  TildeEqual: '≃',\n  TildeFullEqual: '≅',\n  TildeTilde: '≈',\n  Topf: '𝕋',\n  TripleDot: '⃛',\n  Tscr: '𝒯',\n  Tstrok: 'Ŧ',\n  Uacut: 'Ú',\n  Uacute: 'Ú',\n  Uarr: '↟',\n  Uarrocir: '⥉',\n  Ubrcy: 'Ў',\n  Ubreve: 'Ŭ',\n  Ucir: 'Û',\n  Ucirc: 'Û',\n  Ucy: 'У',\n  Udblac: 'Ű',\n  Ufr: '𝔘',\n  Ugrav: 'Ù',\n  Ugrave: 'Ù',\n  Umacr: 'Ū',\n  UnderBar: '_',\n  UnderBrace: '⏟',\n  UnderBracket: '⎵',\n  UnderParenthesis: '⏝',\n  Union: '⋃',\n  UnionPlus: '⊎',\n  Uogon: 'Ų',\n  Uopf: '𝕌',\n  UpArrow: '↑',\n  UpArrowBar: '⤒',\n  UpArrowDownArrow: '⇅',\n  UpDownArrow: '↕',\n  UpEquilibrium: '⥮',\n  UpTee: '⊥',\n  UpTeeArrow: '↥',\n  Uparrow: '⇑',\n  Updownarrow: '⇕',\n  UpperLeftArrow: '↖',\n  UpperRightArrow: '↗',\n  Upsi: 'ϒ',\n  Upsilon: 'Υ',\n  Uring: 'Ů',\n  Uscr: '𝒰',\n  Utilde: 'Ũ',\n  Uum: 'Ü',\n  Uuml: 'Ü',\n  VDash: '⊫',\n  Vbar: '⫫',\n  Vcy: 'В',\n  Vdash: '⊩',\n  Vdashl: '⫦',\n  Vee: '⋁',\n  Verbar: '‖',\n  Vert: '‖',\n  VerticalBar: '∣',\n  VerticalLine: '|',\n  VerticalSeparator: '❘',\n  VerticalTilde: '≀',\n  VeryThinSpace: ' ',\n  Vfr: '𝔙',\n  Vopf: '𝕍',\n  Vscr: '𝒱',\n  Vvdash: '⊪',\n  Wcirc: 'Ŵ',\n  Wedge: '⋀',\n  Wfr: '𝔚',\n  Wopf: '𝕎',\n  Wscr: '𝒲',\n  Xfr: '𝔛',\n  Xi: 'Ξ',\n  Xopf: '𝕏',\n  Xscr: '𝒳',\n  YAcy: 'Я',\n  YIcy: 'Ї',\n  YUcy: 'Ю',\n  Yacut: 'Ý',\n  Yacute: 'Ý',\n  Ycirc: 'Ŷ',\n  Ycy: 'Ы',\n  Yfr: '𝔜',\n  Yopf: '𝕐',\n  Yscr: '𝒴',\n  Yuml: 'Ÿ',\n  ZHcy: 'Ж',\n  Zacute: 'Ź',\n  Zcaron: 'Ž',\n  Zcy: 'З',\n  Zdot: 'Ż',\n  ZeroWidthSpace: '​',\n  Zeta: 'Ζ',\n  Zfr: 'ℨ',\n  Zopf: 'ℤ',\n  Zscr: '𝒵',\n  aacut: 'á',\n  aacute: 'á',\n  abreve: 'ă',\n  ac: '∾',\n  acE: '∾̳',\n  acd: '∿',\n  acir: 'â',\n  acirc: 'â',\n  acut: '´',\n  acute: '´',\n  acy: 'а',\n  aeli: 'æ',\n  aelig: 'æ',\n  af: '⁡',\n  afr: '𝔞',\n  agrav: 'à',\n  agrave: 'à',\n  alefsym: 'ℵ',\n  aleph: 'ℵ',\n  alpha: 'α',\n  amacr: 'ā',\n  amalg: '⨿',\n  am: '&',\n  amp: '&',\n  and: '∧',\n  andand: '⩕',\n  andd: '⩜',\n  andslope: '⩘',\n  andv: '⩚',\n  ang: '∠',\n  ange: '⦤',\n  angle: '∠',\n  angmsd: '∡',\n  angmsdaa: '⦨',\n  angmsdab: '⦩',\n  angmsdac: '⦪',\n  angmsdad: '⦫',\n  angmsdae: '⦬',\n  angmsdaf: '⦭',\n  angmsdag: '⦮',\n  angmsdah: '⦯',\n  angrt: '∟',\n  angrtvb: '⊾',\n  angrtvbd: '⦝',\n  angsph: '∢',\n  angst: 'Å',\n  angzarr: '⍼',\n  aogon: 'ą',\n  aopf: '𝕒',\n  ap: '≈',\n  apE: '⩰',\n  apacir: '⩯',\n  ape: '≊',\n  apid: '≋',\n  apos: \"'\",\n  approx: '≈',\n  approxeq: '≊',\n  arin: 'å',\n  aring: 'å',\n  ascr: '𝒶',\n  ast: '*',\n  asymp: '≈',\n  asympeq: '≍',\n  atild: 'ã',\n  atilde: 'ã',\n  aum: 'ä',\n  auml: 'ä',\n  awconint: '∳',\n  awint: '⨑',\n  bNot: '⫭',\n  backcong: '≌',\n  backepsilon: '϶',\n  backprime: '‵',\n  backsim: '∽',\n  backsimeq: '⋍',\n  barvee: '⊽',\n  barwed: '⌅',\n  barwedge: '⌅',\n  bbrk: '⎵',\n  bbrktbrk: '⎶',\n  bcong: '≌',\n  bcy: 'б',\n  bdquo: '„',\n  becaus: '∵',\n  because: '∵',\n  bemptyv: '⦰',\n  bepsi: '϶',\n  bernou: 'ℬ',\n  beta: 'β',\n  beth: 'ℶ',\n  between: '≬',\n  bfr: '𝔟',\n  bigcap: '⋂',\n  bigcirc: '◯',\n  bigcup: '⋃',\n  bigodot: '⨀',\n  bigoplus: '⨁',\n  bigotimes: '⨂',\n  bigsqcup: '⨆',\n  bigstar: '★',\n  bigtriangledown: '▽',\n  bigtriangleup: '△',\n  biguplus: '⨄',\n  bigvee: '⋁',\n  bigwedge: '⋀',\n  bkarow: '⤍',\n  blacklozenge: '⧫',\n  blacksquare: '▪',\n  blacktriangle: '▴',\n  blacktriangledown: '▾',\n  blacktriangleleft: '◂',\n  blacktriangleright: '▸',\n  blank: '␣',\n  blk12: '▒',\n  blk14: '░',\n  blk34: '▓',\n  block: '█',\n  bne: '=⃥',\n  bnequiv: '≡⃥',\n  bnot: '⌐',\n  bopf: '𝕓',\n  bot: '⊥',\n  bottom: '⊥',\n  bowtie: '⋈',\n  boxDL: '╗',\n  boxDR: '╔',\n  boxDl: '╖',\n  boxDr: '╓',\n  boxH: '═',\n  boxHD: '╦',\n  boxHU: '╩',\n  boxHd: '╤',\n  boxHu: '╧',\n  boxUL: '╝',\n  boxUR: '╚',\n  boxUl: '╜',\n  boxUr: '╙',\n  boxV: '║',\n  boxVH: '╬',\n  boxVL: '╣',\n  boxVR: '╠',\n  boxVh: '╫',\n  boxVl: '╢',\n  boxVr: '╟',\n  boxbox: '⧉',\n  boxdL: '╕',\n  boxdR: '╒',\n  boxdl: '┐',\n  boxdr: '┌',\n  boxh: '─',\n  boxhD: '╥',\n  boxhU: '╨',\n  boxhd: '┬',\n  boxhu: '┴',\n  boxminus: '⊟',\n  boxplus: '⊞',\n  boxtimes: '⊠',\n  boxuL: '╛',\n  boxuR: '╘',\n  boxul: '┘',\n  boxur: '└',\n  boxv: '│',\n  boxvH: '╪',\n  boxvL: '╡',\n  boxvR: '╞',\n  boxvh: '┼',\n  boxvl: '┤',\n  boxvr: '├',\n  bprime: '‵',\n  breve: '˘',\n  brvba: '¦',\n  brvbar: '¦',\n  bscr: '𝒷',\n  bsemi: '⁏',\n  bsim: '∽',\n  bsime: '⋍',\n  bsol: '\\\\',\n  bsolb: '⧅',\n  bsolhsub: '⟈',\n  bull: '•',\n  bullet: '•',\n  bump: '≎',\n  bumpE: '⪮',\n  bumpe: '≏',\n  bumpeq: '≏',\n  cacute: 'ć',\n  cap: '∩',\n  capand: '⩄',\n  capbrcup: '⩉',\n  capcap: '⩋',\n  capcup: '⩇',\n  capdot: '⩀',\n  caps: '∩︀',\n  caret: '⁁',\n  caron: 'ˇ',\n  ccaps: '⩍',\n  ccaron: 'č',\n  ccedi: 'ç',\n  ccedil: 'ç',\n  ccirc: 'ĉ',\n  ccups: '⩌',\n  ccupssm: '⩐',\n  cdot: 'ċ',\n  cedi: '¸',\n  cedil: '¸',\n  cemptyv: '⦲',\n  cen: '¢',\n  cent: '¢',\n  centerdot: '·',\n  cfr: '𝔠',\n  chcy: 'ч',\n  check: '✓',\n  checkmark: '✓',\n  chi: 'χ',\n  cir: '○',\n  cirE: '⧃',\n  circ: 'ˆ',\n  circeq: '≗',\n  circlearrowleft: '↺',\n  circlearrowright: '↻',\n  circledR: '®',\n  circledS: 'Ⓢ',\n  circledast: '⊛',\n  circledcirc: '⊚',\n  circleddash: '⊝',\n  cire: '≗',\n  cirfnint: '⨐',\n  cirmid: '⫯',\n  cirscir: '⧂',\n  clubs: '♣',\n  clubsuit: '♣',\n  colon: ':',\n  colone: '≔',\n  coloneq: '≔',\n  comma: ',',\n  commat: '@',\n  comp: '∁',\n  compfn: '∘',\n  complement: '∁',\n  complexes: 'ℂ',\n  cong: '≅',\n  congdot: '⩭',\n  conint: '∮',\n  copf: '𝕔',\n  coprod: '∐',\n  cop: '©',\n  copy: '©',\n  copysr: '℗',\n  crarr: '↵',\n  cross: '✗',\n  cscr: '𝒸',\n  csub: '⫏',\n  csube: '⫑',\n  csup: '⫐',\n  csupe: '⫒',\n  ctdot: '⋯',\n  cudarrl: '⤸',\n  cudarrr: '⤵',\n  cuepr: '⋞',\n  cuesc: '⋟',\n  cularr: '↶',\n  cularrp: '⤽',\n  cup: '∪',\n  cupbrcap: '⩈',\n  cupcap: '⩆',\n  cupcup: '⩊',\n  cupdot: '⊍',\n  cupor: '⩅',\n  cups: '∪︀',\n  curarr: '↷',\n  curarrm: '⤼',\n  curlyeqprec: '⋞',\n  curlyeqsucc: '⋟',\n  curlyvee: '⋎',\n  curlywedge: '⋏',\n  curre: '¤',\n  curren: '¤',\n  curvearrowleft: '↶',\n  curvearrowright: '↷',\n  cuvee: '⋎',\n  cuwed: '⋏',\n  cwconint: '∲',\n  cwint: '∱',\n  cylcty: '⌭',\n  dArr: '⇓',\n  dHar: '⥥',\n  dagger: '†',\n  daleth: 'ℸ',\n  darr: '↓',\n  dash: '‐',\n  dashv: '⊣',\n  dbkarow: '⤏',\n  dblac: '˝',\n  dcaron: 'ď',\n  dcy: 'д',\n  dd: 'ⅆ',\n  ddagger: '‡',\n  ddarr: '⇊',\n  ddotseq: '⩷',\n  de: '°',\n  deg: '°',\n  delta: 'δ',\n  demptyv: '⦱',\n  dfisht: '⥿',\n  dfr: '𝔡',\n  dharl: '⇃',\n  dharr: '⇂',\n  diam: '⋄',\n  diamond: '⋄',\n  diamondsuit: '♦',\n  diams: '♦',\n  die: '¨',\n  digamma: 'ϝ',\n  disin: '⋲',\n  div: '÷',\n  divid: '÷',\n  divide: '÷',\n  divideontimes: '⋇',\n  divonx: '⋇',\n  djcy: 'ђ',\n  dlcorn: '⌞',\n  dlcrop: '⌍',\n  dollar: '$',\n  dopf: '𝕕',\n  dot: '˙',\n  doteq: '≐',\n  doteqdot: '≑',\n  dotminus: '∸',\n  dotplus: '∔',\n  dotsquare: '⊡',\n  doublebarwedge: '⌆',\n  downarrow: '↓',\n  downdownarrows: '⇊',\n  downharpoonleft: '⇃',\n  downharpoonright: '⇂',\n  drbkarow: '⤐',\n  drcorn: '⌟',\n  drcrop: '⌌',\n  dscr: '𝒹',\n  dscy: 'ѕ',\n  dsol: '⧶',\n  dstrok: 'đ',\n  dtdot: '⋱',\n  dtri: '▿',\n  dtrif: '▾',\n  duarr: '⇵',\n  duhar: '⥯',\n  dwangle: '⦦',\n  dzcy: 'џ',\n  dzigrarr: '⟿',\n  eDDot: '⩷',\n  eDot: '≑',\n  eacut: 'é',\n  eacute: 'é',\n  easter: '⩮',\n  ecaron: 'ě',\n  ecir: 'ê',\n  ecirc: 'ê',\n  ecolon: '≕',\n  ecy: 'э',\n  edot: 'ė',\n  ee: 'ⅇ',\n  efDot: '≒',\n  efr: '𝔢',\n  eg: '⪚',\n  egrav: 'è',\n  egrave: 'è',\n  egs: '⪖',\n  egsdot: '⪘',\n  el: '⪙',\n  elinters: '⏧',\n  ell: 'ℓ',\n  els: '⪕',\n  elsdot: '⪗',\n  emacr: 'ē',\n  empty: '∅',\n  emptyset: '∅',\n  emptyv: '∅',\n  emsp13: ' ',\n  emsp14: ' ',\n  emsp: ' ',\n  eng: 'ŋ',\n  ensp: ' ',\n  eogon: 'ę',\n  eopf: '𝕖',\n  epar: '⋕',\n  eparsl: '⧣',\n  eplus: '⩱',\n  epsi: 'ε',\n  epsilon: 'ε',\n  epsiv: 'ϵ',\n  eqcirc: '≖',\n  eqcolon: '≕',\n  eqsim: '≂',\n  eqslantgtr: '⪖',\n  eqslantless: '⪕',\n  equals: '=',\n  equest: '≟',\n  equiv: '≡',\n  equivDD: '⩸',\n  eqvparsl: '⧥',\n  erDot: '≓',\n  erarr: '⥱',\n  escr: 'ℯ',\n  esdot: '≐',\n  esim: '≂',\n  eta: 'η',\n  et: 'ð',\n  eth: 'ð',\n  eum: 'ë',\n  euml: 'ë',\n  euro: '€',\n  excl: '!',\n  exist: '∃',\n  expectation: 'ℰ',\n  exponentiale: 'ⅇ',\n  fallingdotseq: '≒',\n  fcy: 'ф',\n  female: '♀',\n  ffilig: 'ﬃ',\n  fflig: 'ﬀ',\n  ffllig: 'ﬄ',\n  ffr: '𝔣',\n  filig: 'ﬁ',\n  fjlig: 'fj',\n  flat: '♭',\n  fllig: 'ﬂ',\n  fltns: '▱',\n  fnof: 'ƒ',\n  fopf: '𝕗',\n  forall: '∀',\n  fork: '⋔',\n  forkv: '⫙',\n  fpartint: '⨍',\n  frac1: '¼',\n  frac12: '½',\n  frac13: '⅓',\n  frac14: '¼',\n  frac15: '⅕',\n  frac16: '⅙',\n  frac18: '⅛',\n  frac23: '⅔',\n  frac25: '⅖',\n  frac3: '¾',\n  frac34: '¾',\n  frac35: '⅗',\n  frac38: '⅜',\n  frac45: '⅘',\n  frac56: '⅚',\n  frac58: '⅝',\n  frac78: '⅞',\n  frasl: '⁄',\n  frown: '⌢',\n  fscr: '𝒻',\n  gE: '≧',\n  gEl: '⪌',\n  gacute: 'ǵ',\n  gamma: 'γ',\n  gammad: 'ϝ',\n  gap: '⪆',\n  gbreve: 'ğ',\n  gcirc: 'ĝ',\n  gcy: 'г',\n  gdot: 'ġ',\n  ge: '≥',\n  gel: '⋛',\n  geq: '≥',\n  geqq: '≧',\n  geqslant: '⩾',\n  ges: '⩾',\n  gescc: '⪩',\n  gesdot: '⪀',\n  gesdoto: '⪂',\n  gesdotol: '⪄',\n  gesl: '⋛︀',\n  gesles: '⪔',\n  gfr: '𝔤',\n  gg: '≫',\n  ggg: '⋙',\n  gimel: 'ℷ',\n  gjcy: 'ѓ',\n  gl: '≷',\n  glE: '⪒',\n  gla: '⪥',\n  glj: '⪤',\n  gnE: '≩',\n  gnap: '⪊',\n  gnapprox: '⪊',\n  gne: '⪈',\n  gneq: '⪈',\n  gneqq: '≩',\n  gnsim: '⋧',\n  gopf: '𝕘',\n  grave: '`',\n  gscr: 'ℊ',\n  gsim: '≳',\n  gsime: '⪎',\n  gsiml: '⪐',\n  g: '>',\n  gt: '>',\n  gtcc: '⪧',\n  gtcir: '⩺',\n  gtdot: '⋗',\n  gtlPar: '⦕',\n  gtquest: '⩼',\n  gtrapprox: '⪆',\n  gtrarr: '⥸',\n  gtrdot: '⋗',\n  gtreqless: '⋛',\n  gtreqqless: '⪌',\n  gtrless: '≷',\n  gtrsim: '≳',\n  gvertneqq: '≩︀',\n  gvnE: '≩︀',\n  hArr: '⇔',\n  hairsp: ' ',\n  half: '½',\n  hamilt: 'ℋ',\n  hardcy: 'ъ',\n  harr: '↔',\n  harrcir: '⥈',\n  harrw: '↭',\n  hbar: 'ℏ',\n  hcirc: 'ĥ',\n  hearts: '♥',\n  heartsuit: '♥',\n  hellip: '…',\n  hercon: '⊹',\n  hfr: '𝔥',\n  hksearow: '⤥',\n  hkswarow: '⤦',\n  hoarr: '⇿',\n  homtht: '∻',\n  hookleftarrow: '↩',\n  hookrightarrow: '↪',\n  hopf: '𝕙',\n  horbar: '―',\n  hscr: '𝒽',\n  hslash: 'ℏ',\n  hstrok: 'ħ',\n  hybull: '⁃',\n  hyphen: '‐',\n  iacut: 'í',\n  iacute: 'í',\n  ic: '⁣',\n  icir: 'î',\n  icirc: 'î',\n  icy: 'и',\n  iecy: 'е',\n  iexc: '¡',\n  iexcl: '¡',\n  iff: '⇔',\n  ifr: '𝔦',\n  igrav: 'ì',\n  igrave: 'ì',\n  ii: 'ⅈ',\n  iiiint: '⨌',\n  iiint: '∭',\n  iinfin: '⧜',\n  iiota: '℩',\n  ijlig: 'ĳ',\n  imacr: 'ī',\n  image: 'ℑ',\n  imagline: 'ℐ',\n  imagpart: 'ℑ',\n  imath: 'ı',\n  imof: '⊷',\n  imped: 'Ƶ',\n  \"in\": '∈',\n  incare: '℅',\n  infin: '∞',\n  infintie: '⧝',\n  inodot: 'ı',\n  \"int\": '∫',\n  intcal: '⊺',\n  integers: 'ℤ',\n  intercal: '⊺',\n  intlarhk: '⨗',\n  intprod: '⨼',\n  iocy: 'ё',\n  iogon: 'į',\n  iopf: '𝕚',\n  iota: 'ι',\n  iprod: '⨼',\n  iques: '¿',\n  iquest: '¿',\n  iscr: '𝒾',\n  isin: '∈',\n  isinE: '⋹',\n  isindot: '⋵',\n  isins: '⋴',\n  isinsv: '⋳',\n  isinv: '∈',\n  it: '⁢',\n  itilde: 'ĩ',\n  iukcy: 'і',\n  ium: 'ï',\n  iuml: 'ï',\n  jcirc: 'ĵ',\n  jcy: 'й',\n  jfr: '𝔧',\n  jmath: 'ȷ',\n  jopf: '𝕛',\n  jscr: '𝒿',\n  jsercy: 'ј',\n  jukcy: 'є',\n  kappa: 'κ',\n  kappav: 'ϰ',\n  kcedil: 'ķ',\n  kcy: 'к',\n  kfr: '𝔨',\n  kgreen: 'ĸ',\n  khcy: 'х',\n  kjcy: 'ќ',\n  kopf: '𝕜',\n  kscr: '𝓀',\n  lAarr: '⇚',\n  lArr: '⇐',\n  lAtail: '⤛',\n  lBarr: '⤎',\n  lE: '≦',\n  lEg: '⪋',\n  lHar: '⥢',\n  lacute: 'ĺ',\n  laemptyv: '⦴',\n  lagran: 'ℒ',\n  lambda: 'λ',\n  lang: '⟨',\n  langd: '⦑',\n  langle: '⟨',\n  lap: '⪅',\n  laqu: '«',\n  laquo: '«',\n  larr: '←',\n  larrb: '⇤',\n  larrbfs: '⤟',\n  larrfs: '⤝',\n  larrhk: '↩',\n  larrlp: '↫',\n  larrpl: '⤹',\n  larrsim: '⥳',\n  larrtl: '↢',\n  lat: '⪫',\n  latail: '⤙',\n  late: '⪭',\n  lates: '⪭︀',\n  lbarr: '⤌',\n  lbbrk: '❲',\n  lbrace: '{',\n  lbrack: '[',\n  lbrke: '⦋',\n  lbrksld: '⦏',\n  lbrkslu: '⦍',\n  lcaron: 'ľ',\n  lcedil: 'ļ',\n  lceil: '⌈',\n  lcub: '{',\n  lcy: 'л',\n  ldca: '⤶',\n  ldquo: '“',\n  ldquor: '„',\n  ldrdhar: '⥧',\n  ldrushar: '⥋',\n  ldsh: '↲',\n  le: '≤',\n  leftarrow: '←',\n  leftarrowtail: '↢',\n  leftharpoondown: '↽',\n  leftharpoonup: '↼',\n  leftleftarrows: '⇇',\n  leftrightarrow: '↔',\n  leftrightarrows: '⇆',\n  leftrightharpoons: '⇋',\n  leftrightsquigarrow: '↭',\n  leftthreetimes: '⋋',\n  leg: '⋚',\n  leq: '≤',\n  leqq: '≦',\n  leqslant: '⩽',\n  les: '⩽',\n  lescc: '⪨',\n  lesdot: '⩿',\n  lesdoto: '⪁',\n  lesdotor: '⪃',\n  lesg: '⋚︀',\n  lesges: '⪓',\n  lessapprox: '⪅',\n  lessdot: '⋖',\n  lesseqgtr: '⋚',\n  lesseqqgtr: '⪋',\n  lessgtr: '≶',\n  lesssim: '≲',\n  lfisht: '⥼',\n  lfloor: '⌊',\n  lfr: '𝔩',\n  lg: '≶',\n  lgE: '⪑',\n  lhard: '↽',\n  lharu: '↼',\n  lharul: '⥪',\n  lhblk: '▄',\n  ljcy: 'љ',\n  ll: '≪',\n  llarr: '⇇',\n  llcorner: '⌞',\n  llhard: '⥫',\n  lltri: '◺',\n  lmidot: 'ŀ',\n  lmoust: '⎰',\n  lmoustache: '⎰',\n  lnE: '≨',\n  lnap: '⪉',\n  lnapprox: '⪉',\n  lne: '⪇',\n  lneq: '⪇',\n  lneqq: '≨',\n  lnsim: '⋦',\n  loang: '⟬',\n  loarr: '⇽',\n  lobrk: '⟦',\n  longleftarrow: '⟵',\n  longleftrightarrow: '⟷',\n  longmapsto: '⟼',\n  longrightarrow: '⟶',\n  looparrowleft: '↫',\n  looparrowright: '↬',\n  lopar: '⦅',\n  lopf: '𝕝',\n  loplus: '⨭',\n  lotimes: '⨴',\n  lowast: '∗',\n  lowbar: '_',\n  loz: '◊',\n  lozenge: '◊',\n  lozf: '⧫',\n  lpar: '(',\n  lparlt: '⦓',\n  lrarr: '⇆',\n  lrcorner: '⌟',\n  lrhar: '⇋',\n  lrhard: '⥭',\n  lrm: '‎',\n  lrtri: '⊿',\n  lsaquo: '‹',\n  lscr: '𝓁',\n  lsh: '↰',\n  lsim: '≲',\n  lsime: '⪍',\n  lsimg: '⪏',\n  lsqb: '[',\n  lsquo: '‘',\n  lsquor: '‚',\n  lstrok: 'ł',\n  l: '<',\n  lt: '<',\n  ltcc: '⪦',\n  ltcir: '⩹',\n  ltdot: '⋖',\n  lthree: '⋋',\n  ltimes: '⋉',\n  ltlarr: '⥶',\n  ltquest: '⩻',\n  ltrPar: '⦖',\n  ltri: '◃',\n  ltrie: '⊴',\n  ltrif: '◂',\n  lurdshar: '⥊',\n  luruhar: '⥦',\n  lvertneqq: '≨︀',\n  lvnE: '≨︀',\n  mDDot: '∺',\n  mac: '¯',\n  macr: '¯',\n  male: '♂',\n  malt: '✠',\n  maltese: '✠',\n  map: '↦',\n  mapsto: '↦',\n  mapstodown: '↧',\n  mapstoleft: '↤',\n  mapstoup: '↥',\n  marker: '▮',\n  mcomma: '⨩',\n  mcy: 'м',\n  mdash: '—',\n  measuredangle: '∡',\n  mfr: '𝔪',\n  mho: '℧',\n  micr: 'µ',\n  micro: 'µ',\n  mid: '∣',\n  midast: '*',\n  midcir: '⫰',\n  middo: '·',\n  middot: '·',\n  minus: '−',\n  minusb: '⊟',\n  minusd: '∸',\n  minusdu: '⨪',\n  mlcp: '⫛',\n  mldr: '…',\n  mnplus: '∓',\n  models: '⊧',\n  mopf: '𝕞',\n  mp: '∓',\n  mscr: '𝓂',\n  mstpos: '∾',\n  mu: 'μ',\n  multimap: '⊸',\n  mumap: '⊸',\n  nGg: '⋙̸',\n  nGt: '≫⃒',\n  nGtv: '≫̸',\n  nLeftarrow: '⇍',\n  nLeftrightarrow: '⇎',\n  nLl: '⋘̸',\n  nLt: '≪⃒',\n  nLtv: '≪̸',\n  nRightarrow: '⇏',\n  nVDash: '⊯',\n  nVdash: '⊮',\n  nabla: '∇',\n  nacute: 'ń',\n  nang: '∠⃒',\n  nap: '≉',\n  napE: '⩰̸',\n  napid: '≋̸',\n  napos: 'ŉ',\n  napprox: '≉',\n  natur: '♮',\n  natural: '♮',\n  naturals: 'ℕ',\n  nbs: ' ',\n  nbsp: ' ',\n  nbump: '≎̸',\n  nbumpe: '≏̸',\n  ncap: '⩃',\n  ncaron: 'ň',\n  ncedil: 'ņ',\n  ncong: '≇',\n  ncongdot: '⩭̸',\n  ncup: '⩂',\n  ncy: 'н',\n  ndash: '–',\n  ne: '≠',\n  neArr: '⇗',\n  nearhk: '⤤',\n  nearr: '↗',\n  nearrow: '↗',\n  nedot: '≐̸',\n  nequiv: '≢',\n  nesear: '⤨',\n  nesim: '≂̸',\n  nexist: '∄',\n  nexists: '∄',\n  nfr: '𝔫',\n  ngE: '≧̸',\n  nge: '≱',\n  ngeq: '≱',\n  ngeqq: '≧̸',\n  ngeqslant: '⩾̸',\n  nges: '⩾̸',\n  ngsim: '≵',\n  ngt: '≯',\n  ngtr: '≯',\n  nhArr: '⇎',\n  nharr: '↮',\n  nhpar: '⫲',\n  ni: '∋',\n  nis: '⋼',\n  nisd: '⋺',\n  niv: '∋',\n  njcy: 'њ',\n  nlArr: '⇍',\n  nlE: '≦̸',\n  nlarr: '↚',\n  nldr: '‥',\n  nle: '≰',\n  nleftarrow: '↚',\n  nleftrightarrow: '↮',\n  nleq: '≰',\n  nleqq: '≦̸',\n  nleqslant: '⩽̸',\n  nles: '⩽̸',\n  nless: '≮',\n  nlsim: '≴',\n  nlt: '≮',\n  nltri: '⋪',\n  nltrie: '⋬',\n  nmid: '∤',\n  nopf: '𝕟',\n  no: '¬',\n  not: '¬',\n  notin: '∉',\n  notinE: '⋹̸',\n  notindot: '⋵̸',\n  notinva: '∉',\n  notinvb: '⋷',\n  notinvc: '⋶',\n  notni: '∌',\n  notniva: '∌',\n  notnivb: '⋾',\n  notnivc: '⋽',\n  npar: '∦',\n  nparallel: '∦',\n  nparsl: '⫽⃥',\n  npart: '∂̸',\n  npolint: '⨔',\n  npr: '⊀',\n  nprcue: '⋠',\n  npre: '⪯̸',\n  nprec: '⊀',\n  npreceq: '⪯̸',\n  nrArr: '⇏',\n  nrarr: '↛',\n  nrarrc: '⤳̸',\n  nrarrw: '↝̸',\n  nrightarrow: '↛',\n  nrtri: '⋫',\n  nrtrie: '⋭',\n  nsc: '⊁',\n  nsccue: '⋡',\n  nsce: '⪰̸',\n  nscr: '𝓃',\n  nshortmid: '∤',\n  nshortparallel: '∦',\n  nsim: '≁',\n  nsime: '≄',\n  nsimeq: '≄',\n  nsmid: '∤',\n  nspar: '∦',\n  nsqsube: '⋢',\n  nsqsupe: '⋣',\n  nsub: '⊄',\n  nsubE: '⫅̸',\n  nsube: '⊈',\n  nsubset: '⊂⃒',\n  nsubseteq: '⊈',\n  nsubseteqq: '⫅̸',\n  nsucc: '⊁',\n  nsucceq: '⪰̸',\n  nsup: '⊅',\n  nsupE: '⫆̸',\n  nsupe: '⊉',\n  nsupset: '⊃⃒',\n  nsupseteq: '⊉',\n  nsupseteqq: '⫆̸',\n  ntgl: '≹',\n  ntild: 'ñ',\n  ntilde: 'ñ',\n  ntlg: '≸',\n  ntriangleleft: '⋪',\n  ntrianglelefteq: '⋬',\n  ntriangleright: '⋫',\n  ntrianglerighteq: '⋭',\n  nu: 'ν',\n  num: '#',\n  numero: '№',\n  numsp: ' ',\n  nvDash: '⊭',\n  nvHarr: '⤄',\n  nvap: '≍⃒',\n  nvdash: '⊬',\n  nvge: '≥⃒',\n  nvgt: '>⃒',\n  nvinfin: '⧞',\n  nvlArr: '⤂',\n  nvle: '≤⃒',\n  nvlt: '<⃒',\n  nvltrie: '⊴⃒',\n  nvrArr: '⤃',\n  nvrtrie: '⊵⃒',\n  nvsim: '∼⃒',\n  nwArr: '⇖',\n  nwarhk: '⤣',\n  nwarr: '↖',\n  nwarrow: '↖',\n  nwnear: '⤧',\n  oS: 'Ⓢ',\n  oacut: 'ó',\n  oacute: 'ó',\n  oast: '⊛',\n  ocir: 'ô',\n  ocirc: 'ô',\n  ocy: 'о',\n  odash: '⊝',\n  odblac: 'ő',\n  odiv: '⨸',\n  odot: '⊙',\n  odsold: '⦼',\n  oelig: 'œ',\n  ofcir: '⦿',\n  ofr: '𝔬',\n  ogon: '˛',\n  ograv: 'ò',\n  ograve: 'ò',\n  ogt: '⧁',\n  ohbar: '⦵',\n  ohm: 'Ω',\n  oint: '∮',\n  olarr: '↺',\n  olcir: '⦾',\n  olcross: '⦻',\n  oline: '‾',\n  olt: '⧀',\n  omacr: 'ō',\n  omega: 'ω',\n  omicron: 'ο',\n  omid: '⦶',\n  ominus: '⊖',\n  oopf: '𝕠',\n  opar: '⦷',\n  operp: '⦹',\n  oplus: '⊕',\n  or: '∨',\n  orarr: '↻',\n  ord: 'º',\n  order: 'ℴ',\n  orderof: 'ℴ',\n  ordf: 'ª',\n  ordm: 'º',\n  origof: '⊶',\n  oror: '⩖',\n  orslope: '⩗',\n  orv: '⩛',\n  oscr: 'ℴ',\n  oslas: 'ø',\n  oslash: 'ø',\n  osol: '⊘',\n  otild: 'õ',\n  otilde: 'õ',\n  otimes: '⊗',\n  otimesas: '⨶',\n  oum: 'ö',\n  ouml: 'ö',\n  ovbar: '⌽',\n  par: '¶',\n  para: '¶',\n  parallel: '∥',\n  parsim: '⫳',\n  parsl: '⫽',\n  part: '∂',\n  pcy: 'п',\n  percnt: '%',\n  period: '.',\n  permil: '‰',\n  perp: '⊥',\n  pertenk: '‱',\n  pfr: '𝔭',\n  phi: 'φ',\n  phiv: 'ϕ',\n  phmmat: 'ℳ',\n  phone: '☎',\n  pi: 'π',\n  pitchfork: '⋔',\n  piv: 'ϖ',\n  planck: 'ℏ',\n  planckh: 'ℎ',\n  plankv: 'ℏ',\n  plus: '+',\n  plusacir: '⨣',\n  plusb: '⊞',\n  pluscir: '⨢',\n  plusdo: '∔',\n  plusdu: '⨥',\n  pluse: '⩲',\n  plusm: '±',\n  plusmn: '±',\n  plussim: '⨦',\n  plustwo: '⨧',\n  pm: '±',\n  pointint: '⨕',\n  popf: '𝕡',\n  poun: '£',\n  pound: '£',\n  pr: '≺',\n  prE: '⪳',\n  prap: '⪷',\n  prcue: '≼',\n  pre: '⪯',\n  prec: '≺',\n  precapprox: '⪷',\n  preccurlyeq: '≼',\n  preceq: '⪯',\n  precnapprox: '⪹',\n  precneqq: '⪵',\n  precnsim: '⋨',\n  precsim: '≾',\n  prime: '′',\n  primes: 'ℙ',\n  prnE: '⪵',\n  prnap: '⪹',\n  prnsim: '⋨',\n  prod: '∏',\n  profalar: '⌮',\n  profline: '⌒',\n  profsurf: '⌓',\n  prop: '∝',\n  propto: '∝',\n  prsim: '≾',\n  prurel: '⊰',\n  pscr: '𝓅',\n  psi: 'ψ',\n  puncsp: ' ',\n  qfr: '𝔮',\n  qint: '⨌',\n  qopf: '𝕢',\n  qprime: '⁗',\n  qscr: '𝓆',\n  quaternions: 'ℍ',\n  quatint: '⨖',\n  quest: '?',\n  questeq: '≟',\n  quo: '\"',\n  quot: '\"',\n  rAarr: '⇛',\n  rArr: '⇒',\n  rAtail: '⤜',\n  rBarr: '⤏',\n  rHar: '⥤',\n  race: '∽̱',\n  racute: 'ŕ',\n  radic: '√',\n  raemptyv: '⦳',\n  rang: '⟩',\n  rangd: '⦒',\n  range: '⦥',\n  rangle: '⟩',\n  raqu: '»',\n  raquo: '»',\n  rarr: '→',\n  rarrap: '⥵',\n  rarrb: '⇥',\n  rarrbfs: '⤠',\n  rarrc: '⤳',\n  rarrfs: '⤞',\n  rarrhk: '↪',\n  rarrlp: '↬',\n  rarrpl: '⥅',\n  rarrsim: '⥴',\n  rarrtl: '↣',\n  rarrw: '↝',\n  ratail: '⤚',\n  ratio: '∶',\n  rationals: 'ℚ',\n  rbarr: '⤍',\n  rbbrk: '❳',\n  rbrace: '}',\n  rbrack: ']',\n  rbrke: '⦌',\n  rbrksld: '⦎',\n  rbrkslu: '⦐',\n  rcaron: 'ř',\n  rcedil: 'ŗ',\n  rceil: '⌉',\n  rcub: '}',\n  rcy: 'р',\n  rdca: '⤷',\n  rdldhar: '⥩',\n  rdquo: '”',\n  rdquor: '”',\n  rdsh: '↳',\n  real: 'ℜ',\n  realine: 'ℛ',\n  realpart: 'ℜ',\n  reals: 'ℝ',\n  rect: '▭',\n  re: '®',\n  reg: '®',\n  rfisht: '⥽',\n  rfloor: '⌋',\n  rfr: '𝔯',\n  rhard: '⇁',\n  rharu: '⇀',\n  rharul: '⥬',\n  rho: 'ρ',\n  rhov: 'ϱ',\n  rightarrow: '→',\n  rightarrowtail: '↣',\n  rightharpoondown: '⇁',\n  rightharpoonup: '⇀',\n  rightleftarrows: '⇄',\n  rightleftharpoons: '⇌',\n  rightrightarrows: '⇉',\n  rightsquigarrow: '↝',\n  rightthreetimes: '⋌',\n  ring: '˚',\n  risingdotseq: '≓',\n  rlarr: '⇄',\n  rlhar: '⇌',\n  rlm: '‏',\n  rmoust: '⎱',\n  rmoustache: '⎱',\n  rnmid: '⫮',\n  roang: '⟭',\n  roarr: '⇾',\n  robrk: '⟧',\n  ropar: '⦆',\n  ropf: '𝕣',\n  roplus: '⨮',\n  rotimes: '⨵',\n  rpar: ')',\n  rpargt: '⦔',\n  rppolint: '⨒',\n  rrarr: '⇉',\n  rsaquo: '›',\n  rscr: '𝓇',\n  rsh: '↱',\n  rsqb: ']',\n  rsquo: '’',\n  rsquor: '’',\n  rthree: '⋌',\n  rtimes: '⋊',\n  rtri: '▹',\n  rtrie: '⊵',\n  rtrif: '▸',\n  rtriltri: '⧎',\n  ruluhar: '⥨',\n  rx: '℞',\n  sacute: 'ś',\n  sbquo: '‚',\n  sc: '≻',\n  scE: '⪴',\n  scap: '⪸',\n  scaron: 'š',\n  sccue: '≽',\n  sce: '⪰',\n  scedil: 'ş',\n  scirc: 'ŝ',\n  scnE: '⪶',\n  scnap: '⪺',\n  scnsim: '⋩',\n  scpolint: '⨓',\n  scsim: '≿',\n  scy: 'с',\n  sdot: '⋅',\n  sdotb: '⊡',\n  sdote: '⩦',\n  seArr: '⇘',\n  searhk: '⤥',\n  searr: '↘',\n  searrow: '↘',\n  sec: '§',\n  sect: '§',\n  semi: ';',\n  seswar: '⤩',\n  setminus: '∖',\n  setmn: '∖',\n  sext: '✶',\n  sfr: '𝔰',\n  sfrown: '⌢',\n  sharp: '♯',\n  shchcy: 'щ',\n  shcy: 'ш',\n  shortmid: '∣',\n  shortparallel: '∥',\n  sh: '­',\n  shy: '­',\n  sigma: 'σ',\n  sigmaf: 'ς',\n  sigmav: 'ς',\n  sim: '∼',\n  simdot: '⩪',\n  sime: '≃',\n  simeq: '≃',\n  simg: '⪞',\n  simgE: '⪠',\n  siml: '⪝',\n  simlE: '⪟',\n  simne: '≆',\n  simplus: '⨤',\n  simrarr: '⥲',\n  slarr: '←',\n  smallsetminus: '∖',\n  smashp: '⨳',\n  smeparsl: '⧤',\n  smid: '∣',\n  smile: '⌣',\n  smt: '⪪',\n  smte: '⪬',\n  smtes: '⪬︀',\n  softcy: 'ь',\n  sol: '/',\n  solb: '⧄',\n  solbar: '⌿',\n  sopf: '𝕤',\n  spades: '♠',\n  spadesuit: '♠',\n  spar: '∥',\n  sqcap: '⊓',\n  sqcaps: '⊓︀',\n  sqcup: '⊔',\n  sqcups: '⊔︀',\n  sqsub: '⊏',\n  sqsube: '⊑',\n  sqsubset: '⊏',\n  sqsubseteq: '⊑',\n  sqsup: '⊐',\n  sqsupe: '⊒',\n  sqsupset: '⊐',\n  sqsupseteq: '⊒',\n  squ: '□',\n  square: '□',\n  squarf: '▪',\n  squf: '▪',\n  srarr: '→',\n  sscr: '𝓈',\n  ssetmn: '∖',\n  ssmile: '⌣',\n  sstarf: '⋆',\n  star: '☆',\n  starf: '★',\n  straightepsilon: 'ϵ',\n  straightphi: 'ϕ',\n  strns: '¯',\n  sub: '⊂',\n  subE: '⫅',\n  subdot: '⪽',\n  sube: '⊆',\n  subedot: '⫃',\n  submult: '⫁',\n  subnE: '⫋',\n  subne: '⊊',\n  subplus: '⪿',\n  subrarr: '⥹',\n  subset: '⊂',\n  subseteq: '⊆',\n  subseteqq: '⫅',\n  subsetneq: '⊊',\n  subsetneqq: '⫋',\n  subsim: '⫇',\n  subsub: '⫕',\n  subsup: '⫓',\n  succ: '≻',\n  succapprox: '⪸',\n  succcurlyeq: '≽',\n  succeq: '⪰',\n  succnapprox: '⪺',\n  succneqq: '⪶',\n  succnsim: '⋩',\n  succsim: '≿',\n  sum: '∑',\n  sung: '♪',\n  sup: '⊃',\n  sup1: '¹',\n  sup2: '²',\n  sup3: '³',\n  supE: '⫆',\n  supdot: '⪾',\n  supdsub: '⫘',\n  supe: '⊇',\n  supedot: '⫄',\n  suphsol: '⟉',\n  suphsub: '⫗',\n  suplarr: '⥻',\n  supmult: '⫂',\n  supnE: '⫌',\n  supne: '⊋',\n  supplus: '⫀',\n  supset: '⊃',\n  supseteq: '⊇',\n  supseteqq: '⫆',\n  supsetneq: '⊋',\n  supsetneqq: '⫌',\n  supsim: '⫈',\n  supsub: '⫔',\n  supsup: '⫖',\n  swArr: '⇙',\n  swarhk: '⤦',\n  swarr: '↙',\n  swarrow: '↙',\n  swnwar: '⤪',\n  szli: 'ß',\n  szlig: 'ß',\n  target: '⌖',\n  tau: 'τ',\n  tbrk: '⎴',\n  tcaron: 'ť',\n  tcedil: 'ţ',\n  tcy: 'т',\n  tdot: '⃛',\n  telrec: '⌕',\n  tfr: '𝔱',\n  there4: '∴',\n  therefore: '∴',\n  theta: 'θ',\n  thetasym: 'ϑ',\n  thetav: 'ϑ',\n  thickapprox: '≈',\n  thicksim: '∼',\n  thinsp: ' ',\n  thkap: '≈',\n  thksim: '∼',\n  thor: 'þ',\n  thorn: 'þ',\n  tilde: '˜',\n  time: '×',\n  times: '×',\n  timesb: '⊠',\n  timesbar: '⨱',\n  timesd: '⨰',\n  tint: '∭',\n  toea: '⤨',\n  top: '⊤',\n  topbot: '⌶',\n  topcir: '⫱',\n  topf: '𝕥',\n  topfork: '⫚',\n  tosa: '⤩',\n  tprime: '‴',\n  trade: '™',\n  triangle: '▵',\n  triangledown: '▿',\n  triangleleft: '◃',\n  trianglelefteq: '⊴',\n  triangleq: '≜',\n  triangleright: '▹',\n  trianglerighteq: '⊵',\n  tridot: '◬',\n  trie: '≜',\n  triminus: '⨺',\n  triplus: '⨹',\n  trisb: '⧍',\n  tritime: '⨻',\n  trpezium: '⏢',\n  tscr: '𝓉',\n  tscy: 'ц',\n  tshcy: 'ћ',\n  tstrok: 'ŧ',\n  twixt: '≬',\n  twoheadleftarrow: '↞',\n  twoheadrightarrow: '↠',\n  uArr: '⇑',\n  uHar: '⥣',\n  uacut: 'ú',\n  uacute: 'ú',\n  uarr: '↑',\n  ubrcy: 'ў',\n  ubreve: 'ŭ',\n  ucir: 'û',\n  ucirc: 'û',\n  ucy: 'у',\n  udarr: '⇅',\n  udblac: 'ű',\n  udhar: '⥮',\n  ufisht: '⥾',\n  ufr: '𝔲',\n  ugrav: 'ù',\n  ugrave: 'ù',\n  uharl: '↿',\n  uharr: '↾',\n  uhblk: '▀',\n  ulcorn: '⌜',\n  ulcorner: '⌜',\n  ulcrop: '⌏',\n  ultri: '◸',\n  umacr: 'ū',\n  um: '¨',\n  uml: '¨',\n  uogon: 'ų',\n  uopf: '𝕦',\n  uparrow: '↑',\n  updownarrow: '↕',\n  upharpoonleft: '↿',\n  upharpoonright: '↾',\n  uplus: '⊎',\n  upsi: 'υ',\n  upsih: 'ϒ',\n  upsilon: 'υ',\n  upuparrows: '⇈',\n  urcorn: '⌝',\n  urcorner: '⌝',\n  urcrop: '⌎',\n  uring: 'ů',\n  urtri: '◹',\n  uscr: '𝓊',\n  utdot: '⋰',\n  utilde: 'ũ',\n  utri: '▵',\n  utrif: '▴',\n  uuarr: '⇈',\n  uum: 'ü',\n  uuml: 'ü',\n  uwangle: '⦧',\n  vArr: '⇕',\n  vBar: '⫨',\n  vBarv: '⫩',\n  vDash: '⊨',\n  vangrt: '⦜',\n  varepsilon: 'ϵ',\n  varkappa: 'ϰ',\n  varnothing: '∅',\n  varphi: 'ϕ',\n  varpi: 'ϖ',\n  varpropto: '∝',\n  varr: '↕',\n  varrho: 'ϱ',\n  varsigma: 'ς',\n  varsubsetneq: '⊊︀',\n  varsubsetneqq: '⫋︀',\n  varsupsetneq: '⊋︀',\n  varsupsetneqq: '⫌︀',\n  vartheta: 'ϑ',\n  vartriangleleft: '⊲',\n  vartriangleright: '⊳',\n  vcy: 'в',\n  vdash: '⊢',\n  vee: '∨',\n  veebar: '⊻',\n  veeeq: '≚',\n  vellip: '⋮',\n  verbar: '|',\n  vert: '|',\n  vfr: '𝔳',\n  vltri: '⊲',\n  vnsub: '⊂⃒',\n  vnsup: '⊃⃒',\n  vopf: '𝕧',\n  vprop: '∝',\n  vrtri: '⊳',\n  vscr: '𝓋',\n  vsubnE: '⫋︀',\n  vsubne: '⊊︀',\n  vsupnE: '⫌︀',\n  vsupne: '⊋︀',\n  vzigzag: '⦚',\n  wcirc: 'ŵ',\n  wedbar: '⩟',\n  wedge: '∧',\n  wedgeq: '≙',\n  weierp: '℘',\n  wfr: '𝔴',\n  wopf: '𝕨',\n  wp: '℘',\n  wr: '≀',\n  wreath: '≀',\n  wscr: '𝓌',\n  xcap: '⋂',\n  xcirc: '◯',\n  xcup: '⋃',\n  xdtri: '▽',\n  xfr: '𝔵',\n  xhArr: '⟺',\n  xharr: '⟷',\n  xi: 'ξ',\n  xlArr: '⟸',\n  xlarr: '⟵',\n  xmap: '⟼',\n  xnis: '⋻',\n  xodot: '⨀',\n  xopf: '𝕩',\n  xoplus: '⨁',\n  xotime: '⨂',\n  xrArr: '⟹',\n  xrarr: '⟶',\n  xscr: '𝓍',\n  xsqcup: '⨆',\n  xuplus: '⨄',\n  xutri: '△',\n  xvee: '⋁',\n  xwedge: '⋀',\n  yacut: 'ý',\n  yacute: 'ý',\n  yacy: 'я',\n  ycirc: 'ŷ',\n  ycy: 'ы',\n  ye: '¥',\n  yen: '¥',\n  yfr: '𝔶',\n  yicy: 'ї',\n  yopf: '𝕪',\n  yscr: '𝓎',\n  yucy: 'ю',\n  yum: 'ÿ',\n  yuml: 'ÿ',\n  zacute: 'ź',\n  zcaron: 'ž',\n  zcy: 'з',\n  zdot: 'ż',\n  zeetrf: 'ℨ',\n  zeta: 'ζ',\n  zfr: '𝔷',\n  zhcy: 'ж',\n  zigrarr: '⇝',\n  zopf: '𝕫',\n  zscr: '𝓏',\n  zwj: '‍',\n  zwnj: '‌'\n};\nexports.characterEntities = characterEntities;",
        "mapping": {},
        "path": "{remark-parse}/../character-entities/index.js"
    },
    "{6475C042-06C8-43EA-B92B-CCA5DA746811}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{655DC6E7-E843-4C16-9290-2D01C3971562}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n* @typedef {import('micromark-util-types').State} State\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.codeFenced = void 0;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/** @type {Construct} */\nvar codeFenced = {\n  name: 'codeFenced',\n  tokenize: tokenizeCodeFenced,\n  concrete: true\n};\n/** @type {Tokenizer} */\n\nexports.codeFenced = codeFenced;\n\nfunction tokenizeCodeFenced(effects, ok, nok) {\n  var self = this;\n  /** @type {Construct} */\n\n  var closingFenceConstruct = {\n    tokenize: tokenizeClosingFence,\n    partial: true\n  };\n  /** @type {Construct} */\n\n  var nonLazyLine = {\n    tokenize: tokenizeNonLazyLine,\n    partial: true\n  };\n  var tail = this.events[this.events.length - 1];\n  var initialPrefix = tail && tail[1].type === 'linePrefix' ? tail[2].sliceSerialize(tail[1], true).length : 0;\n  var sizeOpen = 0;\n  /** @type {NonNullable<Code>} */\n\n  var marker;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('codeFenced');\n    effects.enter('codeFencedFence');\n    effects.enter('codeFencedFenceSequence');\n    marker = code;\n    return sequenceOpen(code);\n  }\n  /** @type {State} */\n\n\n  function sequenceOpen(code) {\n    if (code === marker) {\n      effects.consume(code);\n      sizeOpen++;\n      return sequenceOpen;\n    }\n\n    effects.exit('codeFencedFenceSequence');\n    return sizeOpen < 3 ? nok(code) : (0, _micromarkFactorySpace.factorySpace)(effects, infoOpen, 'whitespace')(code);\n  }\n  /** @type {State} */\n\n\n  function infoOpen(code) {\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      return openAfter(code);\n    }\n\n    effects.enter('codeFencedFenceInfo');\n    effects.enter('chunkString', {\n      contentType: 'string'\n    });\n    return info(code);\n  }\n  /** @type {State} */\n\n\n  function info(code) {\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code)) {\n      effects.exit('chunkString');\n      effects.exit('codeFencedFenceInfo');\n      return (0, _micromarkFactorySpace.factorySpace)(effects, infoAfter, 'whitespace')(code);\n    }\n\n    if (code === 96 && code === marker) return nok(code);\n    effects.consume(code);\n    return info;\n  }\n  /** @type {State} */\n\n\n  function infoAfter(code) {\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      return openAfter(code);\n    }\n\n    effects.enter('codeFencedFenceMeta');\n    effects.enter('chunkString', {\n      contentType: 'string'\n    });\n    return meta(code);\n  }\n  /** @type {State} */\n\n\n  function meta(code) {\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.exit('chunkString');\n      effects.exit('codeFencedFenceMeta');\n      return openAfter(code);\n    }\n\n    if (code === 96 && code === marker) return nok(code);\n    effects.consume(code);\n    return meta;\n  }\n  /** @type {State} */\n\n\n  function openAfter(code) {\n    effects.exit('codeFencedFence');\n    return self.interrupt ? ok(code) : contentStart(code);\n  }\n  /** @type {State} */\n\n\n  function contentStart(code) {\n    if (code === null) {\n      return after(code);\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      return effects.attempt(nonLazyLine, effects.attempt(closingFenceConstruct, after, initialPrefix ? (0, _micromarkFactorySpace.factorySpace)(effects, contentStart, 'linePrefix', initialPrefix + 1) : contentStart), after)(code);\n    }\n\n    effects.enter('codeFlowValue');\n    return contentContinue(code);\n  }\n  /** @type {State} */\n\n\n  function contentContinue(code) {\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.exit('codeFlowValue');\n      return contentStart(code);\n    }\n\n    effects.consume(code);\n    return contentContinue;\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    effects.exit('codeFenced');\n    return ok(code);\n  }\n  /** @type {Tokenizer} */\n\n\n  function tokenizeNonLazyLine(effects, ok, nok) {\n    var self = this;\n    return start;\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return lineStart;\n    }\n    /** @type {State} */\n\n\n    function lineStart(code) {\n      return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n    }\n  }\n  /** @type {Tokenizer} */\n\n\n  function tokenizeClosingFence(effects, ok, nok) {\n    var size = 0;\n    return (0, _micromarkFactorySpace.factorySpace)(effects, closingSequenceStart, 'linePrefix', this.parser.constructs.disable[\"null\"].includes('codeIndented') ? undefined : 4);\n    /** @type {State} */\n\n    function closingSequenceStart(code) {\n      effects.enter('codeFencedFence');\n      effects.enter('codeFencedFenceSequence');\n      return closingSequence(code);\n    }\n    /** @type {State} */\n\n\n    function closingSequence(code) {\n      if (code === marker) {\n        effects.consume(code);\n        size++;\n        return closingSequence;\n      }\n\n      if (size < sizeOpen) return nok(code);\n      effects.exit('codeFencedFenceSequence');\n      return (0, _micromarkFactorySpace.factorySpace)(effects, closingSequenceEnd, 'whitespace')(code);\n    }\n    /** @type {State} */\n\n\n    function closingSequenceEnd(code) {\n      if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n        effects.exit('codeFencedFence');\n        return ok(code);\n      }\n\n      return nok(code);\n    }\n  }\n}",
        "mapping": {
            "micromark-factory-space": "{E0E988E7-8E66-43F0-929F-249A02885E51}",
            "micromark-util-character": "{064CF63B-1998-4C80-885B-D83129FA50A9}"
        },
        "path": "{remark-parse}/../micromark-core-commonmark/lib/code-fenced.js"
    },
    "{E0E988E7-8E66-43F0-929F-249A02885E51}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Effects} Effects\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factorySpace = factorySpace;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {string} type\n * @param {number} [max=Infinity]\n * @returns {State}\n */\nfunction factorySpace(effects, ok, type, max) {\n  var limit = max ? max - 1 : Number.POSITIVE_INFINITY;\n  var size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.enter(type);\n      return prefix(code);\n    }\n\n    return ok(code);\n  }\n  /** @type {State} */\n\n\n  function prefix(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code) && size++ < limit) {\n      effects.consume(code);\n      return prefix;\n    }\n\n    effects.exit(type);\n    return ok(code);\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-factory-space/index.js"
    },
    "{064CF63B-1998-4C80-885B-D83129FA50A9}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{391BB839-6E2A-4386-9063-B8B19EE026AC}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n* @typedef {import('micromark-util-types').Resolver} Resolver\n* @typedef {import('micromark-util-types').Token} Token\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.codeIndented = void 0;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/** @type {Construct} */\nvar codeIndented = {\n  name: 'codeIndented',\n  tokenize: tokenizeCodeIndented\n};\n/** @type {Construct} */\n\nexports.codeIndented = codeIndented;\nvar indentedContent = {\n  tokenize: tokenizeIndentedContent,\n  partial: true\n};\n/** @type {Tokenizer} */\n\nfunction tokenizeCodeIndented(effects, ok, nok) {\n  var self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('codeIndented');\n    return (0, _micromarkFactorySpace.factorySpace)(effects, afterStartPrefix, 'linePrefix', 4 + 1)(code);\n  }\n  /** @type {State} */\n\n\n  function afterStartPrefix(code) {\n    var tail = self.events[self.events.length - 1];\n    return tail && tail[1].type === 'linePrefix' && tail[2].sliceSerialize(tail[1], true).length >= 4 ? afterPrefix(code) : nok(code);\n  }\n  /** @type {State} */\n\n\n  function afterPrefix(code) {\n    if (code === null) {\n      return after(code);\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      return effects.attempt(indentedContent, afterPrefix, after)(code);\n    }\n\n    effects.enter('codeFlowValue');\n    return content(code);\n  }\n  /** @type {State} */\n\n\n  function content(code) {\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.exit('codeFlowValue');\n      return afterPrefix(code);\n    }\n\n    effects.consume(code);\n    return content;\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    effects.exit('codeIndented');\n    return ok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeIndentedContent(effects, ok, nok) {\n  var self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    // If this is a lazy line, it can’t be code.\n    if (self.parser.lazy[self.now().line]) {\n      return nok(code);\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return start;\n    }\n\n    return (0, _micromarkFactorySpace.factorySpace)(effects, afterPrefix, 'linePrefix', 4 + 1)(code);\n  }\n  /** @type {State} */\n\n\n  function afterPrefix(code) {\n    var tail = self.events[self.events.length - 1];\n    return tail && tail[1].type === 'linePrefix' && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok(code) : (0, _micromarkUtilCharacter.markdownLineEnding)(code) ? start(code) : nok(code);\n  }\n}",
        "mapping": {
            "micromark-factory-space": "{4768B0C0-AD58-4ED2-A24F-70121C4BE9EA}",
            "micromark-util-character": "{7D1721A6-75B7-4722-B552-8EDAE85868D8}"
        },
        "path": "{remark-parse}/../micromark-core-commonmark/lib/code-indented.js"
    },
    "{4768B0C0-AD58-4ED2-A24F-70121C4BE9EA}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Effects} Effects\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factorySpace = factorySpace;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {string} type\n * @param {number} [max=Infinity]\n * @returns {State}\n */\nfunction factorySpace(effects, ok, type, max) {\n  var limit = max ? max - 1 : Number.POSITIVE_INFINITY;\n  var size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.enter(type);\n      return prefix(code);\n    }\n\n    return ok(code);\n  }\n  /** @type {State} */\n\n\n  function prefix(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code) && size++ < limit) {\n      effects.consume(code);\n      return prefix;\n    }\n\n    effects.exit(type);\n    return ok(code);\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-factory-space/index.js"
    },
    "{7D1721A6-75B7-4722-B552-8EDAE85868D8}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{B2A94881-A655-4F0D-8259-BF2567F4640F}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').Resolver} Resolver\n* @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n* @typedef {import('micromark-util-types').Previous} Previous\n* @typedef {import('micromark-util-types').Token} Token\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.codeText = void 0;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/** @type {Construct} */\nvar codeText = {\n  name: 'codeText',\n  tokenize: tokenizeCodeText,\n  resolve: resolveCodeText,\n  previous: previous\n};\n/** @type {Resolver} */\n\nexports.codeText = codeText;\n\nfunction resolveCodeText(events) {\n  var tailExitIndex = events.length - 4;\n  var headEnterIndex = 3;\n  /** @type {number} */\n\n  var index;\n  /** @type {number|undefined} */\n\n  var enter; // If we start and end with an EOL or a space.\n\n  if ((events[headEnterIndex][1].type === 'lineEnding' || events[headEnterIndex][1].type === 'space') && (events[tailExitIndex][1].type === 'lineEnding' || events[tailExitIndex][1].type === 'space')) {\n    index = headEnterIndex; // And we have data.\n\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'codeTextData') {\n        // Then we have padding.\n        events[headEnterIndex][1].type = 'codeTextPadding';\n        events[tailExitIndex][1].type = 'codeTextPadding';\n        headEnterIndex += 2;\n        tailExitIndex -= 2;\n        break;\n      }\n    }\n  } // Merge adjacent spaces and data.\n\n\n  index = headEnterIndex - 1;\n  tailExitIndex++;\n\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {\n        enter = index;\n      }\n    } else if (index === tailExitIndex || events[index][1].type === 'lineEnding') {\n      events[enter][1].type = 'codeTextData';\n\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end;\n        events.splice(enter + 2, index - enter - 2);\n        tailExitIndex -= index - enter - 2;\n        index = enter + 2;\n      }\n\n      enter = undefined;\n    }\n  }\n\n  return events;\n}\n/** @type {Previous} */\n\n\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return code !== 96 || this.events[this.events.length - 1][1].type === 'characterEscape';\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeCodeText(effects, ok, nok) {\n  var self = this;\n  var sizeOpen = 0;\n  /** @type {number} */\n\n  var size;\n  /** @type {Token} */\n\n  var token;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('codeText');\n    effects.enter('codeTextSequence');\n    return openingSequence(code);\n  }\n  /** @type {State} */\n\n\n  function openingSequence(code) {\n    if (code === 96) {\n      effects.consume(code);\n      sizeOpen++;\n      return openingSequence;\n    }\n\n    effects.exit('codeTextSequence');\n    return gap(code);\n  }\n  /** @type {State} */\n\n\n  function gap(code) {\n    // EOF.\n    if (code === null) {\n      return nok(code);\n    } // Closing fence?\n    // Could also be data.\n\n\n    if (code === 96) {\n      token = effects.enter('codeTextSequence');\n      size = 0;\n      return closingSequence(code);\n    } // Tabs don’t work, and virtual spaces don’t make sense.\n\n\n    if (code === 32) {\n      effects.enter('space');\n      effects.consume(code);\n      effects.exit('space');\n      return gap;\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return gap;\n    } // Data.\n\n\n    effects.enter('codeTextData');\n    return data(code);\n  } // In code.\n\n  /** @type {State} */\n\n\n  function data(code) {\n    if (code === null || code === 32 || code === 96 || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.exit('codeTextData');\n      return gap(code);\n    }\n\n    effects.consume(code);\n    return data;\n  } // Closing fence.\n\n  /** @type {State} */\n\n\n  function closingSequence(code) {\n    // More.\n    if (code === 96) {\n      effects.consume(code);\n      size++;\n      return closingSequence;\n    } // Done!\n\n\n    if (size === sizeOpen) {\n      effects.exit('codeTextSequence');\n      effects.exit('codeText');\n      return ok(code);\n    } // More or less accents: mark as data.\n\n\n    token.type = 'codeTextData';\n    return data(code);\n  }\n}",
        "mapping": {
            "micromark-util-character": "{15E45B81-36F9-4208-A3AF-BB30405B614F}"
        },
        "path": "{remark-parse}/../micromark-core-commonmark/lib/code-text.js"
    },
    "{15E45B81-36F9-4208-A3AF-BB30405B614F}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{E991CD05-54D8-40D0-8A78-D93F7EDACCAA}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').Resolver} Resolver\n* @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n* @typedef {import('micromark-util-types').Token} Token\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.content = void 0;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\nvar _micromarkUtilSubtokenize = require(\"micromark-util-subtokenize\");\n\n/**\n * No name because it must not be turned off.\n * @type {Construct}\n */\nvar content = {\n  tokenize: tokenizeContent,\n  resolve: resolveContent\n};\n/** @type {Construct} */\n\nexports.content = content;\nvar continuationConstruct = {\n  tokenize: tokenizeContinuation,\n  partial: true\n};\n/**\n * Content is transparent: it’s parsed right now. That way, definitions are also\n * parsed right now: before text in paragraphs (specifically, media) are parsed.\n *\n * @type {Resolver}\n */\n\nfunction resolveContent(events) {\n  (0, _micromarkUtilSubtokenize.subtokenize)(events);\n  return events;\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeContent(effects, ok) {\n  /** @type {Token} */\n  var previous;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('content');\n    previous = effects.enter('chunkContent', {\n      contentType: 'content'\n    });\n    return data(code);\n  }\n  /** @type {State} */\n\n\n  function data(code) {\n    if (code === null) {\n      return contentEnd(code);\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      return effects.check(continuationConstruct, contentContinue, contentEnd)(code);\n    } // Data.\n\n\n    effects.consume(code);\n    return data;\n  }\n  /** @type {State} */\n\n\n  function contentEnd(code) {\n    effects.exit('chunkContent');\n    effects.exit('content');\n    return ok(code);\n  }\n  /** @type {State} */\n\n\n  function contentContinue(code) {\n    effects.consume(code);\n    effects.exit('chunkContent');\n    previous.next = effects.enter('chunkContent', {\n      contentType: 'content',\n      previous: previous\n    });\n    previous = previous.next;\n    return data;\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeContinuation(effects, ok, nok) {\n  var self = this;\n  return startLookahead;\n  /** @type {State} */\n\n  function startLookahead(code) {\n    effects.exit('chunkContent');\n    effects.enter('lineEnding');\n    effects.consume(code);\n    effects.exit('lineEnding');\n    return (0, _micromarkFactorySpace.factorySpace)(effects, prefixed, 'linePrefix');\n  }\n  /** @type {State} */\n\n\n  function prefixed(code) {\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      return nok(code);\n    }\n\n    var tail = self.events[self.events.length - 1];\n\n    if (!self.parser.constructs.disable[\"null\"].includes('codeIndented') && tail && tail[1].type === 'linePrefix' && tail[2].sliceSerialize(tail[1], true).length >= 4) {\n      return ok(code);\n    }\n\n    return effects.interrupt(self.parser.constructs.flow, nok, ok)(code);\n  }\n}",
        "mapping": {
            "micromark-factory-space": "{4C31240F-727E-4F2A-A2BB-23421FBA52BF}",
            "micromark-util-character": "{D26AD92B-065A-44E8-AC73-48E3968177D5}",
            "micromark-util-subtokenize": "{FD6725B6-F315-4A36-BEA3-BA3C5CAB7B07}"
        },
        "path": "{remark-parse}/../micromark-core-commonmark/lib/content.js"
    },
    "{4C31240F-727E-4F2A-A2BB-23421FBA52BF}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Effects} Effects\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factorySpace = factorySpace;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {string} type\n * @param {number} [max=Infinity]\n * @returns {State}\n */\nfunction factorySpace(effects, ok, type, max) {\n  var limit = max ? max - 1 : Number.POSITIVE_INFINITY;\n  var size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.enter(type);\n      return prefix(code);\n    }\n\n    return ok(code);\n  }\n  /** @type {State} */\n\n\n  function prefix(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code) && size++ < limit) {\n      effects.consume(code);\n      return prefix;\n    }\n\n    effects.exit(type);\n    return ok(code);\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-factory-space/index.js"
    },
    "{D26AD92B-065A-44E8-AC73-48E3968177D5}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{FD6725B6-F315-4A36-BEA3-BA3C5CAB7B07}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Token} Token\n* @typedef {import('micromark-util-types').Chunk} Chunk\n* @typedef {import('micromark-util-types').Event} Event\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.subtokenize = subtokenize;\n\nvar _micromarkUtilChunked = require(\"micromark-util-chunked\");\n\n/**\n * Tokenize subcontent.\n *\n * @param {Event[]} events\n * @returns {boolean}\n */\nfunction subtokenize(events) {\n  /** @type {Record<string, number>} */\n  var jumps = {};\n  var index = -1;\n  /** @type {Event} */\n\n  var event;\n  /** @type {number|undefined} */\n\n  var lineIndex;\n  /** @type {number} */\n\n  var otherIndex;\n  /** @type {Event} */\n\n  var otherEvent;\n  /** @type {Event[]} */\n\n  var parameters;\n  /** @type {Event[]} */\n\n  var subevents;\n  /** @type {boolean|undefined} */\n\n  var more;\n\n  while (++index < events.length) {\n    while (index in jumps) {\n      index = jumps[index];\n    }\n\n    event = events[index]; // Add a hook for the GFM tasklist extension, which needs to know if text\n    // is in the first content of a list item.\n\n    if (index && event[1].type === 'chunkFlow' && events[index - 1][1].type === 'listItemPrefix') {\n      subevents = event[1]._tokenizer.events;\n      otherIndex = 0;\n\n      if (otherIndex < subevents.length && subevents[otherIndex][1].type === 'lineEndingBlank') {\n        otherIndex += 2;\n      }\n\n      if (otherIndex < subevents.length && subevents[otherIndex][1].type === 'content') {\n        while (++otherIndex < subevents.length) {\n          if (subevents[otherIndex][1].type === 'content') {\n            break;\n          }\n\n          if (subevents[otherIndex][1].type === 'chunkText') {\n            subevents[otherIndex][1]._isInFirstContentOfListItem = true;\n            otherIndex++;\n          }\n        }\n      }\n    } // Enter.\n\n\n    if (event[0] === 'enter') {\n      if (event[1].contentType) {\n        Object.assign(jumps, subcontent(events, index));\n        index = jumps[index];\n        more = true;\n      }\n    } // Exit.\n    else if (event[1]._container) {\n      otherIndex = index;\n      lineIndex = undefined;\n\n      while (otherIndex--) {\n        otherEvent = events[otherIndex];\n\n        if (otherEvent[1].type === 'lineEnding' || otherEvent[1].type === 'lineEndingBlank') {\n          if (otherEvent[0] === 'enter') {\n            if (lineIndex) {\n              events[lineIndex][1].type = 'lineEndingBlank';\n            }\n\n            otherEvent[1].type = 'lineEnding';\n            lineIndex = otherIndex;\n          }\n        } else {\n          break;\n        }\n      }\n\n      if (lineIndex) {\n        // Fix position.\n        event[1].end = Object.assign({}, events[lineIndex][1].start); // Switch container exit w/ line endings.\n\n        parameters = events.slice(lineIndex, index);\n        parameters.unshift(event);\n        (0, _micromarkUtilChunked.splice)(events, lineIndex, index - lineIndex + 1, parameters);\n      }\n    }\n  }\n\n  return !more;\n}\n/**\n * Tokenize embedded tokens.\n *\n * @param {Event[]} events\n * @param {number} eventIndex\n * @returns {Record<string, number>}\n */\n\n\nfunction subcontent(events, eventIndex) {\n  var token = events[eventIndex][1];\n  var context = events[eventIndex][2];\n  var startPosition = eventIndex - 1;\n  /** @type {number[]} */\n\n  var startPositions = [];\n  var tokenizer = token._tokenizer || context.parser[token.contentType](token.start);\n  var childEvents = tokenizer.events;\n  /** @type {[number, number][]} */\n\n  var jumps = [];\n  /** @type {Record<string, number>} */\n\n  var gaps = {};\n  /** @type {Chunk[]} */\n\n  var stream;\n  /** @type {Token|undefined} */\n\n  var previous;\n  var index = -1;\n  /** @type {Token|undefined} */\n\n  var current = token;\n  var adjust = 0;\n  var start = 0;\n  var breaks = [start]; // Loop forward through the linked tokens to pass them in order to the\n  // subtokenizer.\n\n  while (current) {\n    // Find the position of the event for this token.\n    while (events[++startPosition][1] !== current) {// Empty.\n    }\n\n    startPositions.push(startPosition);\n\n    if (!current._tokenizer) {\n      stream = context.sliceStream(current);\n\n      if (!current.next) {\n        stream.push(null);\n      }\n\n      if (previous) {\n        tokenizer.defineSkip(current.start);\n      }\n\n      if (current._isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = true;\n      }\n\n      tokenizer.write(stream);\n\n      if (current._isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = undefined;\n      }\n    } // Unravel the next token.\n\n\n    previous = current;\n    current = current.next;\n  } // Now, loop back through all events (and linked tokens), to figure out which\n  // parts belong where.\n\n\n  current = token;\n\n  while (++index < childEvents.length) {\n    if ( // Find a void token that includes a break.\n    childEvents[index][0] === 'exit' && childEvents[index - 1][0] === 'enter' && childEvents[index][1].type === childEvents[index - 1][1].type && childEvents[index][1].start.line !== childEvents[index][1].end.line) {\n      start = index + 1;\n      breaks.push(start); // Help GC.\n\n      current._tokenizer = undefined;\n      current.previous = undefined;\n      current = current.next;\n    }\n  } // Help GC.\n\n\n  tokenizer.events = []; // If there’s one more token (which is the cases for lines that end in an\n  // EOF), that’s perfect: the last point we found starts it.\n  // If there isn’t then make sure any remaining content is added to it.\n\n  if (current) {\n    // Help GC.\n    current._tokenizer = undefined;\n    current.previous = undefined;\n  } else {\n    breaks.pop();\n  } // Now splice the events from the subtokenizer into the current events,\n  // moving back to front so that splice indices aren’t affected.\n\n\n  index = breaks.length;\n\n  while (index--) {\n    var slice = childEvents.slice(breaks[index], breaks[index + 1]);\n\n    var _start = startPositions.pop();\n\n    jumps.unshift([_start, _start + slice.length - 1]);\n    (0, _micromarkUtilChunked.splice)(events, _start, 2, slice);\n  }\n\n  index = -1;\n\n  while (++index < jumps.length) {\n    gaps[adjust + jumps[index][0]] = adjust + jumps[index][1];\n    adjust += jumps[index][1] - jumps[index][0] - 1;\n  }\n\n  return gaps;\n}",
        "mapping": {
            "micromark-util-chunked": "{7C0CCA9C-B1AE-47A1-BE51-BFBAE2EA3A82}"
        },
        "path": "{remark-parse}/../micromark-util-subtokenize/index.js"
    },
    "{7C0CCA9C-B1AE-47A1-BE51-BFBAE2EA3A82}": {
        "source": "\"use strict\";\n/**\n* Like `Array#splice`, but smarter for giant arrays.\n*\n* `Array#splice` takes all items to be inserted as individual argument which\n* causes a stack overflow in V8 when trying to insert 100k items for instance.\n*\n* Otherwise, this does not return the removed items, and takes `items` as an\n* array instead of rest parameters.\n*\n* @template {unknown} T\n* @param {T[]} list\n* @param {number} start\n* @param {number} remove\n* @param {T[]} items\n* @returns {void}\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.push = push;\nexports.splice = splice;\n\nfunction splice(list, start, remove, items) {\n  var end = list.length;\n  var chunkStart = 0;\n  /** @type {unknown[]} */\n\n  var parameters; // Make start between zero and `end` (included).\n\n  if (start < 0) {\n    start = -start > end ? 0 : end + start;\n  } else {\n    start = start > end ? end : start;\n  }\n\n  remove = remove > 0 ? remove : 0; // No need to chunk the items if there’s only a couple (10k) items.\n\n  if (items.length < 10000) {\n    parameters = Array.from(items);\n    parameters.unshift(start, remove) // @ts-expect-error Hush, it’s fine.\n    ;\n    [].splice.apply(list, parameters);\n  } else {\n    // Delete `remove` items starting from `start`\n    if (remove) [].splice.apply(list, [start, remove]); // Insert the items in chunks to not cause stack overflows.\n\n    while (chunkStart < items.length) {\n      parameters = items.slice(chunkStart, chunkStart + 10000);\n      parameters.unshift(start, 0) // @ts-expect-error Hush, it’s fine.\n      ;\n      [].splice.apply(list, parameters);\n      chunkStart += 10000;\n      start += 10000;\n    }\n  }\n}\n/**\n * Append `items` (an array) at the end of `list` (another array).\n * When `list` was empty, returns `items` instead.\n *\n * This prevents a potentially expensive operation when `list` is empty,\n * and adds items in batches to prevent V8 from hanging.\n *\n * @template {unknown} T\n * @param {T[]} list\n * @param {T[]} items\n * @returns {T[]}\n */\n\n\nfunction push(list, items) {\n  if (list.length > 0) {\n    splice(list, list.length, 0, items);\n    return list;\n  }\n\n  return items;\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-chunked/index.js"
    },
    "{F01E11B0-8D92-4F7A-AE5A-5DEA381DD726}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.definition = void 0;\n\nvar _micromarkFactoryDestination = require(\"micromark-factory-destination\");\n\nvar _micromarkFactoryLabel = require(\"micromark-factory-label\");\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkFactoryTitle = require(\"micromark-factory-title\");\n\nvar _micromarkFactoryWhitespace = require(\"micromark-factory-whitespace\");\n\nvar _micromarkUtilNormalizeIdentifier = require(\"micromark-util-normalize-identifier\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/** @type {Construct} */\nvar definition = {\n  name: 'definition',\n  tokenize: tokenizeDefinition\n};\n/** @type {Construct} */\n\nexports.definition = definition;\nvar titleConstruct = {\n  tokenize: tokenizeTitle,\n  partial: true\n};\n/** @type {Tokenizer} */\n\nfunction tokenizeDefinition(effects, ok, nok) {\n  var self = this;\n  /** @type {string} */\n\n  var identifier;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('definition');\n    return _micromarkFactoryLabel.factoryLabel.call(self, effects, labelAfter, nok, 'definitionLabel', 'definitionLabelMarker', 'definitionLabelString')(code);\n  }\n  /** @type {State} */\n\n\n  function labelAfter(code) {\n    identifier = (0, _micromarkUtilNormalizeIdentifier.normalizeIdentifier)(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1));\n\n    if (code === 58) {\n      effects.enter('definitionMarker');\n      effects.consume(code);\n      effects.exit('definitionMarker'); // Note: blank lines can’t exist in content.\n\n      return (0, _micromarkFactoryWhitespace.factoryWhitespace)(effects, (0, _micromarkFactoryDestination.factoryDestination)(effects, effects.attempt(titleConstruct, (0, _micromarkFactorySpace.factorySpace)(effects, after, 'whitespace'), (0, _micromarkFactorySpace.factorySpace)(effects, after, 'whitespace')), nok, 'definitionDestination', 'definitionDestinationLiteral', 'definitionDestinationLiteralMarker', 'definitionDestinationRaw', 'definitionDestinationString'));\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.exit('definition');\n\n      if (!self.parser.defined.includes(identifier)) {\n        self.parser.defined.push(identifier);\n      }\n\n      return ok(code);\n    }\n\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeTitle(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    return (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code) ? (0, _micromarkFactoryWhitespace.factoryWhitespace)(effects, before)(code) : nok(code);\n  }\n  /** @type {State} */\n\n\n  function before(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return (0, _micromarkFactoryTitle.factoryTitle)(effects, (0, _micromarkFactorySpace.factorySpace)(effects, after, 'whitespace'), nok, 'definitionTitle', 'definitionTitleMarker', 'definitionTitleString')(code);\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    return code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code) ? ok(code) : nok(code);\n  }\n}",
        "mapping": {
            "micromark-factory-destination": "{A7F523FD-0975-4816-B2E6-448BF5C1DA75}",
            "micromark-factory-label": "{7A09ED77-B208-4859-8B28-2454F02A3A4B}",
            "micromark-factory-space": "{870B892C-1B68-4645-8E6B-991BB9509BA6}",
            "micromark-factory-title": "{FCFADE69-0D35-442D-8804-2E673498B0D8}",
            "micromark-factory-whitespace": "{515B7D2E-3D73-46CE-B62B-88D5514E3CC4}",
            "micromark-util-normalize-identifier": "{368A39C8-1A55-4D5E-87C7-A166FC94B851}",
            "micromark-util-character": "{48F67EDE-62C6-4AAD-A74F-F3E688A8F346}"
        },
        "path": "{remark-parse}/../micromark-core-commonmark/lib/definition.js"
    },
    "{A7F523FD-0975-4816-B2E6-448BF5C1DA75}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Effects} Effects\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factoryDestination = factoryDestination;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {State} nok\n * @param {string} type\n * @param {string} literalType\n * @param {string} literalMarkerType\n * @param {string} rawType\n * @param {string} stringType\n * @param {number} [max=Infinity]\n * @returns {State}\n */\n// eslint-disable-next-line max-params\nfunction factoryDestination(effects, ok, nok, type, literalType, literalMarkerType, rawType, stringType, max) {\n  var limit = max || Number.POSITIVE_INFINITY;\n  var balance = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (code === 60) {\n      effects.enter(type);\n      effects.enter(literalType);\n      effects.enter(literalMarkerType);\n      effects.consume(code);\n      effects.exit(literalMarkerType);\n      return destinationEnclosedBefore;\n    }\n\n    if (code === null || code === 41 || (0, _micromarkUtilCharacter.asciiControl)(code)) {\n      return nok(code);\n    }\n\n    effects.enter(type);\n    effects.enter(rawType);\n    effects.enter(stringType);\n    effects.enter('chunkString', {\n      contentType: 'string'\n    });\n    return destinationRaw(code);\n  }\n  /** @type {State} */\n\n\n  function destinationEnclosedBefore(code) {\n    if (code === 62) {\n      effects.enter(literalMarkerType);\n      effects.consume(code);\n      effects.exit(literalMarkerType);\n      effects.exit(literalType);\n      effects.exit(type);\n      return ok;\n    }\n\n    effects.enter(stringType);\n    effects.enter('chunkString', {\n      contentType: 'string'\n    });\n    return destinationEnclosed(code);\n  }\n  /** @type {State} */\n\n\n  function destinationEnclosed(code) {\n    if (code === 62) {\n      effects.exit('chunkString');\n      effects.exit(stringType);\n      return destinationEnclosedBefore(code);\n    }\n\n    if (code === null || code === 60 || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      return nok(code);\n    }\n\n    effects.consume(code);\n    return code === 92 ? destinationEnclosedEscape : destinationEnclosed;\n  }\n  /** @type {State} */\n\n\n  function destinationEnclosedEscape(code) {\n    if (code === 60 || code === 62 || code === 92) {\n      effects.consume(code);\n      return destinationEnclosed;\n    }\n\n    return destinationEnclosed(code);\n  }\n  /** @type {State} */\n\n\n  function destinationRaw(code) {\n    if (code === 40) {\n      if (++balance > limit) return nok(code);\n      effects.consume(code);\n      return destinationRaw;\n    }\n\n    if (code === 41) {\n      if (!balance--) {\n        effects.exit('chunkString');\n        effects.exit(stringType);\n        effects.exit(rawType);\n        effects.exit(type);\n        return ok(code);\n      }\n\n      effects.consume(code);\n      return destinationRaw;\n    }\n\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code)) {\n      if (balance) return nok(code);\n      effects.exit('chunkString');\n      effects.exit(stringType);\n      effects.exit(rawType);\n      effects.exit(type);\n      return ok(code);\n    }\n\n    if ((0, _micromarkUtilCharacter.asciiControl)(code)) return nok(code);\n    effects.consume(code);\n    return code === 92 ? destinationRawEscape : destinationRaw;\n  }\n  /** @type {State} */\n\n\n  function destinationRawEscape(code) {\n    if (code === 40 || code === 41 || code === 92) {\n      effects.consume(code);\n      return destinationRaw;\n    }\n\n    return destinationRaw(code);\n  }\n}",
        "mapping": {
            "micromark-util-character": "{976A9EF9-3C27-4A01-9B6B-4DBC67004447}"
        },
        "path": "{remark-parse}/../micromark-factory-destination/index.js"
    },
    "{976A9EF9-3C27-4A01-9B6B-4DBC67004447}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{7A09ED77-B208-4859-8B28-2454F02A3A4B}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Effects} Effects\n* @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factoryLabel = factoryLabel;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @this {TokenizeContext}\n * @param {Effects} effects\n * @param {State} ok\n * @param {State} nok\n * @param {string} type\n * @param {string} markerType\n * @param {string} stringType\n * @returns {State}\n */\n// eslint-disable-next-line max-params\nfunction factoryLabel(effects, ok, nok, type, markerType, stringType) {\n  var self = this;\n  var size = 0;\n  /** @type {boolean} */\n\n  var data;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter(type);\n    effects.enter(markerType);\n    effects.consume(code);\n    effects.exit(markerType);\n    effects.enter(stringType);\n    return atBreak;\n  }\n  /** @type {State} */\n\n\n  function atBreak(code) {\n    if (code === null || code === 91 || code === 93 && !data ||\n    /* To do: remove in the future once we’ve switched from\n     * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,\n     * which doesn’t need this */\n\n    /* Hidden footnotes hook */\n\n    /* c8 ignore next 3 */\n    code === 94 && !size && '_hiddenFootnoteSupport' in self.parser.constructs || size > 999) {\n      return nok(code);\n    }\n\n    if (code === 93) {\n      effects.exit(stringType);\n      effects.enter(markerType);\n      effects.consume(code);\n      effects.exit(markerType);\n      effects.exit(type);\n      return ok;\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return atBreak;\n    }\n\n    effects.enter('chunkString', {\n      contentType: 'string'\n    });\n    return label(code);\n  }\n  /** @type {State} */\n\n\n  function label(code) {\n    if (code === null || code === 91 || code === 93 || (0, _micromarkUtilCharacter.markdownLineEnding)(code) || size++ > 999) {\n      effects.exit('chunkString');\n      return atBreak(code);\n    }\n\n    effects.consume(code);\n    data = data || !(0, _micromarkUtilCharacter.markdownSpace)(code);\n    return code === 92 ? labelEscape : label;\n  }\n  /** @type {State} */\n\n\n  function labelEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code);\n      size++;\n      return label;\n    }\n\n    return label(code);\n  }\n}",
        "mapping": {
            "micromark-util-character": "{1223719A-E0A9-4DA4-9547-02E76352DBB3}"
        },
        "path": "{remark-parse}/../micromark-factory-label/index.js"
    },
    "{1223719A-E0A9-4DA4-9547-02E76352DBB3}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{870B892C-1B68-4645-8E6B-991BB9509BA6}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Effects} Effects\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factorySpace = factorySpace;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {string} type\n * @param {number} [max=Infinity]\n * @returns {State}\n */\nfunction factorySpace(effects, ok, type, max) {\n  var limit = max ? max - 1 : Number.POSITIVE_INFINITY;\n  var size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.enter(type);\n      return prefix(code);\n    }\n\n    return ok(code);\n  }\n  /** @type {State} */\n\n\n  function prefix(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code) && size++ < limit) {\n      effects.consume(code);\n      return prefix;\n    }\n\n    effects.exit(type);\n    return ok(code);\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-factory-space/index.js"
    },
    "{FCFADE69-0D35-442D-8804-2E673498B0D8}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Effects} Effects\n* @typedef {import('micromark-util-types').State} State\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factoryTitle = factoryTitle;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {State} nok\n * @param {string} type\n * @param {string} markerType\n * @param {string} stringType\n * @returns {State}\n */\n// eslint-disable-next-line max-params\nfunction factoryTitle(effects, ok, nok, type, markerType, stringType) {\n  /** @type {NonNullable<Code>} */\n  var marker;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter(type);\n    effects.enter(markerType);\n    effects.consume(code);\n    effects.exit(markerType);\n    marker = code === 40 ? 41 : code;\n    return atFirstTitleBreak;\n  }\n  /** @type {State} */\n\n\n  function atFirstTitleBreak(code) {\n    if (code === marker) {\n      effects.enter(markerType);\n      effects.consume(code);\n      effects.exit(markerType);\n      effects.exit(type);\n      return ok;\n    }\n\n    effects.enter(stringType);\n    return atTitleBreak(code);\n  }\n  /** @type {State} */\n\n\n  function atTitleBreak(code) {\n    if (code === marker) {\n      effects.exit(stringType);\n      return atFirstTitleBreak(marker);\n    }\n\n    if (code === null) {\n      return nok(code);\n    } // Note: blank lines can’t exist in content.\n\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return (0, _micromarkFactorySpace.factorySpace)(effects, atTitleBreak, 'linePrefix');\n    }\n\n    effects.enter('chunkString', {\n      contentType: 'string'\n    });\n    return title(code);\n  }\n  /** @type {State} */\n\n\n  function title(code) {\n    if (code === marker || code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.exit('chunkString');\n      return atTitleBreak(code);\n    }\n\n    effects.consume(code);\n    return code === 92 ? titleEscape : title;\n  }\n  /** @type {State} */\n\n\n  function titleEscape(code) {\n    if (code === marker || code === 92) {\n      effects.consume(code);\n      return title;\n    }\n\n    return title(code);\n  }\n}",
        "mapping": {
            "micromark-factory-space": "{14FDF9E6-D5D2-42D3-9941-A9AF58AC087B}",
            "micromark-util-character": "{C9C87109-2B1A-4AF7-A191-85AEF5B42967}"
        },
        "path": "{remark-parse}/../micromark-factory-title/index.js"
    },
    "{14FDF9E6-D5D2-42D3-9941-A9AF58AC087B}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Effects} Effects\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factorySpace = factorySpace;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {string} type\n * @param {number} [max=Infinity]\n * @returns {State}\n */\nfunction factorySpace(effects, ok, type, max) {\n  var limit = max ? max - 1 : Number.POSITIVE_INFINITY;\n  var size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.enter(type);\n      return prefix(code);\n    }\n\n    return ok(code);\n  }\n  /** @type {State} */\n\n\n  function prefix(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code) && size++ < limit) {\n      effects.consume(code);\n      return prefix;\n    }\n\n    effects.exit(type);\n    return ok(code);\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-factory-space/index.js"
    },
    "{C9C87109-2B1A-4AF7-A191-85AEF5B42967}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{515B7D2E-3D73-46CE-B62B-88D5514E3CC4}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Effects} Effects\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factoryWhitespace = factoryWhitespace;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n */\nfunction factoryWhitespace(effects, ok) {\n  /** @type {boolean} */\n  var seen;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      seen = true;\n      return start;\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      return (0, _micromarkFactorySpace.factorySpace)(effects, start, seen ? 'linePrefix' : 'lineSuffix')(code);\n    }\n\n    return ok(code);\n  }\n}",
        "mapping": {
            "micromark-factory-space": "{461387C5-CBBD-45AD-9C03-7B5E81530064}",
            "micromark-util-character": "{362FBDB7-2FC5-4671-8508-5273104583FA}"
        },
        "path": "{remark-parse}/../micromark-factory-whitespace/index.js"
    },
    "{461387C5-CBBD-45AD-9C03-7B5E81530064}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Effects} Effects\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factorySpace = factorySpace;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {string} type\n * @param {number} [max=Infinity]\n * @returns {State}\n */\nfunction factorySpace(effects, ok, type, max) {\n  var limit = max ? max - 1 : Number.POSITIVE_INFINITY;\n  var size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.enter(type);\n      return prefix(code);\n    }\n\n    return ok(code);\n  }\n  /** @type {State} */\n\n\n  function prefix(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code) && size++ < limit) {\n      effects.consume(code);\n      return prefix;\n    }\n\n    effects.exit(type);\n    return ok(code);\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-factory-space/index.js"
    },
    "{362FBDB7-2FC5-4671-8508-5273104583FA}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{368A39C8-1A55-4D5E-87C7-A166FC94B851}": {
        "source": "\"use strict\";\n/**\n* Normalize an identifier (such as used in definitions).\n*\n* @param {string} value\n* @returns {string}\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.normalizeIdentifier = normalizeIdentifier;\n\nfunction normalizeIdentifier(value) {\n  return value // Collapse Markdown whitespace.\n  .replace(/[\\t\\n\\r ]+/g, ' ') // Trim.\n  .replace(/^ | $/g, '') // Some characters are considered “uppercase”, but if their lowercase\n  // counterpart is uppercased will result in a different uppercase\n  // character.\n  // Hence, to get that form, we perform both lower- and uppercase.\n  // Upper case makes sure keys will not interact with default prototypal\n  // methods: no method is uppercase.\n  .toLowerCase().toUpperCase();\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-normalize-identifier/index.js"
    },
    "{48F67EDE-62C6-4AAD-A74F-F3E688A8F346}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{3CB41A3F-E4A7-4697-A457-410156D2870F}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hardBreakEscape = void 0;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/** @type {Construct} */\nvar hardBreakEscape = {\n  name: 'hardBreakEscape',\n  tokenize: tokenizeHardBreakEscape\n};\n/** @type {Tokenizer} */\n\nexports.hardBreakEscape = hardBreakEscape;\n\nfunction tokenizeHardBreakEscape(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('hardBreakEscape');\n    effects.enter('escapeMarker');\n    effects.consume(code);\n    return open;\n  }\n  /** @type {State} */\n\n\n  function open(code) {\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.exit('escapeMarker');\n      effects.exit('hardBreakEscape');\n      return ok(code);\n    }\n\n    return nok(code);\n  }\n}",
        "mapping": {
            "micromark-util-character": "{746D2347-A400-4C8B-9066-B62568CDACC9}"
        },
        "path": "{remark-parse}/../micromark-core-commonmark/lib/hard-break-escape.js"
    },
    "{746D2347-A400-4C8B-9066-B62568CDACC9}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{868A9BF8-7966-4F0B-9DC0-98A0CB73FC54}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').Resolver} Resolver\n* @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n* @typedef {import('micromark-util-types').Token} Token\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.headingAtx = void 0;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\nvar _micromarkUtilChunked = require(\"micromark-util-chunked\");\n\n/** @type {Construct} */\nvar headingAtx = {\n  name: 'headingAtx',\n  tokenize: tokenizeHeadingAtx,\n  resolve: resolveHeadingAtx\n};\n/** @type {Resolver} */\n\nexports.headingAtx = headingAtx;\n\nfunction resolveHeadingAtx(events, context) {\n  var contentEnd = events.length - 2;\n  var contentStart = 3;\n  /** @type {Token} */\n\n  var content;\n  /** @type {Token} */\n\n  var text; // Prefix whitespace, part of the opening.\n\n  if (events[contentStart][1].type === 'whitespace') {\n    contentStart += 2;\n  } // Suffix whitespace, part of the closing.\n\n\n  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === 'whitespace') {\n    contentEnd -= 2;\n  }\n\n  if (events[contentEnd][1].type === 'atxHeadingSequence' && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === 'whitespace')) {\n    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;\n  }\n\n  if (contentEnd > contentStart) {\n    content = {\n      type: 'atxHeadingText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end\n    };\n    text = {\n      type: 'chunkText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end,\n      // @ts-expect-error Constants are fine to assign.\n      contentType: 'text'\n    };\n    (0, _micromarkUtilChunked.splice)(events, contentStart, contentEnd - contentStart + 1, [['enter', content, context], ['enter', text, context], ['exit', text, context], ['exit', content, context]]);\n  }\n\n  return events;\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeHeadingAtx(effects, ok, nok) {\n  var self = this;\n  var size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('atxHeading');\n    effects.enter('atxHeadingSequence');\n    return fenceOpenInside(code);\n  }\n  /** @type {State} */\n\n\n  function fenceOpenInside(code) {\n    if (code === 35 && size++ < 6) {\n      effects.consume(code);\n      return fenceOpenInside;\n    }\n\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code)) {\n      effects.exit('atxHeadingSequence');\n      return self.interrupt ? ok(code) : headingBreak(code);\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function headingBreak(code) {\n    if (code === 35) {\n      effects.enter('atxHeadingSequence');\n      return sequence(code);\n    }\n\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.exit('atxHeading');\n      return ok(code);\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      return (0, _micromarkFactorySpace.factorySpace)(effects, headingBreak, 'whitespace')(code);\n    }\n\n    effects.enter('atxHeadingText');\n    return data(code);\n  }\n  /** @type {State} */\n\n\n  function sequence(code) {\n    if (code === 35) {\n      effects.consume(code);\n      return sequence;\n    }\n\n    effects.exit('atxHeadingSequence');\n    return headingBreak(code);\n  }\n  /** @type {State} */\n\n\n  function data(code) {\n    if (code === null || code === 35 || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code)) {\n      effects.exit('atxHeadingText');\n      return headingBreak(code);\n    }\n\n    effects.consume(code);\n    return data;\n  }\n}",
        "mapping": {
            "micromark-factory-space": "{E7360D4D-8320-4ED4-BB48-7BC8A564EF2E}",
            "micromark-util-character": "{7B1B6905-AAA3-4DE5-ABE8-C89C5CADC10D}",
            "micromark-util-chunked": "{B52E6028-3499-4439-93BC-C8F80C4D99E2}"
        },
        "path": "{remark-parse}/../micromark-core-commonmark/lib/heading-atx.js"
    },
    "{E7360D4D-8320-4ED4-BB48-7BC8A564EF2E}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Effects} Effects\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factorySpace = factorySpace;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {string} type\n * @param {number} [max=Infinity]\n * @returns {State}\n */\nfunction factorySpace(effects, ok, type, max) {\n  var limit = max ? max - 1 : Number.POSITIVE_INFINITY;\n  var size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.enter(type);\n      return prefix(code);\n    }\n\n    return ok(code);\n  }\n  /** @type {State} */\n\n\n  function prefix(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code) && size++ < limit) {\n      effects.consume(code);\n      return prefix;\n    }\n\n    effects.exit(type);\n    return ok(code);\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-factory-space/index.js"
    },
    "{7B1B6905-AAA3-4DE5-ABE8-C89C5CADC10D}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{B52E6028-3499-4439-93BC-C8F80C4D99E2}": {
        "source": "\"use strict\";\n/**\n* Like `Array#splice`, but smarter for giant arrays.\n*\n* `Array#splice` takes all items to be inserted as individual argument which\n* causes a stack overflow in V8 when trying to insert 100k items for instance.\n*\n* Otherwise, this does not return the removed items, and takes `items` as an\n* array instead of rest parameters.\n*\n* @template {unknown} T\n* @param {T[]} list\n* @param {number} start\n* @param {number} remove\n* @param {T[]} items\n* @returns {void}\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.push = push;\nexports.splice = splice;\n\nfunction splice(list, start, remove, items) {\n  var end = list.length;\n  var chunkStart = 0;\n  /** @type {unknown[]} */\n\n  var parameters; // Make start between zero and `end` (included).\n\n  if (start < 0) {\n    start = -start > end ? 0 : end + start;\n  } else {\n    start = start > end ? end : start;\n  }\n\n  remove = remove > 0 ? remove : 0; // No need to chunk the items if there’s only a couple (10k) items.\n\n  if (items.length < 10000) {\n    parameters = Array.from(items);\n    parameters.unshift(start, remove) // @ts-expect-error Hush, it’s fine.\n    ;\n    [].splice.apply(list, parameters);\n  } else {\n    // Delete `remove` items starting from `start`\n    if (remove) [].splice.apply(list, [start, remove]); // Insert the items in chunks to not cause stack overflows.\n\n    while (chunkStart < items.length) {\n      parameters = items.slice(chunkStart, chunkStart + 10000);\n      parameters.unshift(start, 0) // @ts-expect-error Hush, it’s fine.\n      ;\n      [].splice.apply(list, parameters);\n      chunkStart += 10000;\n      start += 10000;\n    }\n  }\n}\n/**\n * Append `items` (an array) at the end of `list` (another array).\n * When `list` was empty, returns `items` instead.\n *\n * This prevents a potentially expensive operation when `list` is empty,\n * and adds items in batches to prevent V8 from hanging.\n *\n * @template {unknown} T\n * @param {T[]} list\n * @param {T[]} items\n * @returns {T[]}\n */\n\n\nfunction push(list, items) {\n  if (list.length > 0) {\n    splice(list, list.length, 0, items);\n    return list;\n  }\n\n  return items;\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-chunked/index.js"
    },
    "{E4B39900-5EA8-45BF-917A-4668482B31F8}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').Resolver} Resolver\n* @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n* @typedef {import('micromark-util-types').State} State\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.htmlFlow = void 0;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\nvar _micromarkUtilHtmlTagName = require(\"micromark-util-html-tag-name\");\n\nvar _blankLine = require(\"./blank-line.js\");\n\n/** @type {Construct} */\nvar htmlFlow = {\n  name: 'htmlFlow',\n  tokenize: tokenizeHtmlFlow,\n  resolveTo: resolveToHtmlFlow,\n  concrete: true\n};\n/** @type {Construct} */\n\nexports.htmlFlow = htmlFlow;\nvar nextBlankConstruct = {\n  tokenize: tokenizeNextBlank,\n  partial: true\n};\n/** @type {Resolver} */\n\nfunction resolveToHtmlFlow(events) {\n  var index = events.length;\n\n  while (index--) {\n    if (events[index][0] === 'enter' && events[index][1].type === 'htmlFlow') {\n      break;\n    }\n  }\n\n  if (index > 1 && events[index - 2][1].type === 'linePrefix') {\n    // Add the prefix start to the HTML token.\n    events[index][1].start = events[index - 2][1].start; // Add the prefix start to the HTML line token.\n\n    events[index + 1][1].start = events[index - 2][1].start; // Remove the line prefix.\n\n    events.splice(index - 2, 2);\n  }\n\n  return events;\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeHtmlFlow(effects, ok, nok) {\n  var self = this;\n  /** @type {number} */\n\n  var kind;\n  /** @type {boolean} */\n\n  var startTag;\n  /** @type {string} */\n\n  var buffer;\n  /** @type {number} */\n\n  var index;\n  /** @type {Code} */\n\n  var marker;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('htmlFlow');\n    effects.enter('htmlFlowData');\n    effects.consume(code);\n    return open;\n  }\n  /** @type {State} */\n\n\n  function open(code) {\n    if (code === 33) {\n      effects.consume(code);\n      return declarationStart;\n    }\n\n    if (code === 47) {\n      effects.consume(code);\n      return tagCloseStart;\n    }\n\n    if (code === 63) {\n      effects.consume(code);\n      kind = 3; // While we’re in an instruction instead of a declaration, we’re on a `?`\n      // right now, so we do need to search for `>`, similar to declarations.\n\n      return self.interrupt ? ok : continuationDeclarationInside;\n    }\n\n    if ((0, _micromarkUtilCharacter.asciiAlpha)(code)) {\n      effects.consume(code);\n      buffer = String.fromCharCode(code);\n      startTag = true;\n      return tagName;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function declarationStart(code) {\n    if (code === 45) {\n      effects.consume(code);\n      kind = 2;\n      return commentOpenInside;\n    }\n\n    if (code === 91) {\n      effects.consume(code);\n      kind = 5;\n      buffer = 'CDATA[';\n      index = 0;\n      return cdataOpenInside;\n    }\n\n    if ((0, _micromarkUtilCharacter.asciiAlpha)(code)) {\n      effects.consume(code);\n      kind = 4;\n      return self.interrupt ? ok : continuationDeclarationInside;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function commentOpenInside(code) {\n    if (code === 45) {\n      effects.consume(code);\n      return self.interrupt ? ok : continuationDeclarationInside;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function cdataOpenInside(code) {\n    if (code === buffer.charCodeAt(index++)) {\n      effects.consume(code);\n      return index === buffer.length ? self.interrupt ? ok : continuation : cdataOpenInside;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function tagCloseStart(code) {\n    if ((0, _micromarkUtilCharacter.asciiAlpha)(code)) {\n      effects.consume(code);\n      buffer = String.fromCharCode(code);\n      return tagName;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function tagName(code) {\n    if (code === null || code === 47 || code === 62 || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code)) {\n      if (code !== 47 && startTag && _micromarkUtilHtmlTagName.htmlRawNames.includes(buffer.toLowerCase())) {\n        kind = 1;\n        return self.interrupt ? ok(code) : continuation(code);\n      }\n\n      if (_micromarkUtilHtmlTagName.htmlBlockNames.includes(buffer.toLowerCase())) {\n        kind = 6;\n\n        if (code === 47) {\n          effects.consume(code);\n          return basicSelfClosing;\n        }\n\n        return self.interrupt ? ok(code) : continuation(code);\n      }\n\n      kind = 7; // Do not support complete HTML when interrupting\n\n      return self.interrupt && !self.parser.lazy[self.now().line] ? nok(code) : startTag ? completeAttributeNameBefore(code) : completeClosingTagAfter(code);\n    }\n\n    if (code === 45 || (0, _micromarkUtilCharacter.asciiAlphanumeric)(code)) {\n      effects.consume(code);\n      buffer += String.fromCharCode(code);\n      return tagName;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function basicSelfClosing(code) {\n    if (code === 62) {\n      effects.consume(code);\n      return self.interrupt ? ok : continuation;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function completeClosingTagAfter(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.consume(code);\n      return completeClosingTagAfter;\n    }\n\n    return completeEnd(code);\n  }\n  /** @type {State} */\n\n\n  function completeAttributeNameBefore(code) {\n    if (code === 47) {\n      effects.consume(code);\n      return completeEnd;\n    }\n\n    if (code === 58 || code === 95 || (0, _micromarkUtilCharacter.asciiAlpha)(code)) {\n      effects.consume(code);\n      return completeAttributeName;\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.consume(code);\n      return completeAttributeNameBefore;\n    }\n\n    return completeEnd(code);\n  }\n  /** @type {State} */\n\n\n  function completeAttributeName(code) {\n    if (code === 45 || code === 46 || code === 58 || code === 95 || (0, _micromarkUtilCharacter.asciiAlphanumeric)(code)) {\n      effects.consume(code);\n      return completeAttributeName;\n    }\n\n    return completeAttributeNameAfter(code);\n  }\n  /** @type {State} */\n\n\n  function completeAttributeNameAfter(code) {\n    if (code === 61) {\n      effects.consume(code);\n      return completeAttributeValueBefore;\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.consume(code);\n      return completeAttributeNameAfter;\n    }\n\n    return completeAttributeNameBefore(code);\n  }\n  /** @type {State} */\n\n\n  function completeAttributeValueBefore(code) {\n    if (code === null || code === 60 || code === 61 || code === 62 || code === 96) {\n      return nok(code);\n    }\n\n    if (code === 34 || code === 39) {\n      effects.consume(code);\n      marker = code;\n      return completeAttributeValueQuoted;\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.consume(code);\n      return completeAttributeValueBefore;\n    }\n\n    marker = null;\n    return completeAttributeValueUnquoted(code);\n  }\n  /** @type {State} */\n\n\n  function completeAttributeValueQuoted(code) {\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      return nok(code);\n    }\n\n    if (code === marker) {\n      effects.consume(code);\n      return completeAttributeValueQuotedAfter;\n    }\n\n    effects.consume(code);\n    return completeAttributeValueQuoted;\n  }\n  /** @type {State} */\n\n\n  function completeAttributeValueUnquoted(code) {\n    if (code === null || code === 34 || code === 39 || code === 60 || code === 61 || code === 62 || code === 96 || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code)) {\n      return completeAttributeNameAfter(code);\n    }\n\n    effects.consume(code);\n    return completeAttributeValueUnquoted;\n  }\n  /** @type {State} */\n\n\n  function completeAttributeValueQuotedAfter(code) {\n    if (code === 47 || code === 62 || (0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      return completeAttributeNameBefore(code);\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function completeEnd(code) {\n    if (code === 62) {\n      effects.consume(code);\n      return completeAfter;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function completeAfter(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.consume(code);\n      return completeAfter;\n    }\n\n    return code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code) ? continuation(code) : nok(code);\n  }\n  /** @type {State} */\n\n\n  function continuation(code) {\n    if (code === 45 && kind === 2) {\n      effects.consume(code);\n      return continuationCommentInside;\n    }\n\n    if (code === 60 && kind === 1) {\n      effects.consume(code);\n      return continuationRawTagOpen;\n    }\n\n    if (code === 62 && kind === 4) {\n      effects.consume(code);\n      return continuationClose;\n    }\n\n    if (code === 63 && kind === 3) {\n      effects.consume(code);\n      return continuationDeclarationInside;\n    }\n\n    if (code === 93 && kind === 5) {\n      effects.consume(code);\n      return continuationCharacterDataInside;\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code) && (kind === 6 || kind === 7)) {\n      return effects.check(nextBlankConstruct, continuationClose, continuationAtLineEnding)(code);\n    }\n\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      return continuationAtLineEnding(code);\n    }\n\n    effects.consume(code);\n    return continuation;\n  }\n  /** @type {State} */\n\n\n  function continuationAtLineEnding(code) {\n    effects.exit('htmlFlowData');\n    return htmlContinueStart(code);\n  }\n  /** @type {State} */\n\n\n  function htmlContinueStart(code) {\n    if (code === null) {\n      return done(code);\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      return effects.attempt({\n        tokenize: htmlLineEnd,\n        partial: true\n      }, htmlContinueStart, done)(code);\n    }\n\n    effects.enter('htmlFlowData');\n    return continuation(code);\n  }\n  /** @type {Tokenizer} */\n\n\n  function htmlLineEnd(effects, ok, nok) {\n    return start;\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return lineStart;\n    }\n    /** @type {State} */\n\n\n    function lineStart(code) {\n      return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n    }\n  }\n  /** @type {State} */\n\n\n  function continuationCommentInside(code) {\n    if (code === 45) {\n      effects.consume(code);\n      return continuationDeclarationInside;\n    }\n\n    return continuation(code);\n  }\n  /** @type {State} */\n\n\n  function continuationRawTagOpen(code) {\n    if (code === 47) {\n      effects.consume(code);\n      buffer = '';\n      return continuationRawEndTag;\n    }\n\n    return continuation(code);\n  }\n  /** @type {State} */\n\n\n  function continuationRawEndTag(code) {\n    if (code === 62 && _micromarkUtilHtmlTagName.htmlRawNames.includes(buffer.toLowerCase())) {\n      effects.consume(code);\n      return continuationClose;\n    }\n\n    if ((0, _micromarkUtilCharacter.asciiAlpha)(code) && buffer.length < 8) {\n      effects.consume(code);\n      buffer += String.fromCharCode(code);\n      return continuationRawEndTag;\n    }\n\n    return continuation(code);\n  }\n  /** @type {State} */\n\n\n  function continuationCharacterDataInside(code) {\n    if (code === 93) {\n      effects.consume(code);\n      return continuationDeclarationInside;\n    }\n\n    return continuation(code);\n  }\n  /** @type {State} */\n\n\n  function continuationDeclarationInside(code) {\n    if (code === 62) {\n      effects.consume(code);\n      return continuationClose;\n    } // More dashes.\n\n\n    if (code === 45 && kind === 2) {\n      effects.consume(code);\n      return continuationDeclarationInside;\n    }\n\n    return continuation(code);\n  }\n  /** @type {State} */\n\n\n  function continuationClose(code) {\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.exit('htmlFlowData');\n      return done(code);\n    }\n\n    effects.consume(code);\n    return continuationClose;\n  }\n  /** @type {State} */\n\n\n  function done(code) {\n    effects.exit('htmlFlow');\n    return ok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeNextBlank(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.exit('htmlFlowData');\n    effects.enter('lineEndingBlank');\n    effects.consume(code);\n    effects.exit('lineEndingBlank');\n    return effects.attempt(_blankLine.blankLine, ok, nok);\n  }\n}",
        "mapping": {
            "micromark-util-character": "{6AEF0396-391E-4BAE-9691-88FE1870D595}",
            "micromark-util-html-tag-name": "{146B32CD-FFEE-4CD1-AA4A-DDF4E9036F27}",
            "./blank-line.js": "{1275C03B-CD0D-4B78-9ECE-68CE38EA4BE9}"
        },
        "path": "{remark-parse}/../micromark-core-commonmark/lib/html-flow.js"
    },
    "{6AEF0396-391E-4BAE-9691-88FE1870D595}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{146B32CD-FFEE-4CD1-AA4A-DDF4E9036F27}": {
        "source": "\"use strict\";\n/**\n* List of lowercase HTML tag names which when parsing HTML (flow), result\n* in more relaxed rules (condition 6): because they are known blocks, the\n* HTML-like syntax doesn’t have to be strictly parsed.\n* For tag names not in this list, a more strict algorithm (condition 7) is used\n* to detect whether the HTML-like syntax is seen as HTML (flow) or not.\n*\n* This is copied from:\n* <https://spec.commonmark.org/0.29/#html-blocks>.\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.htmlRawNames = exports.htmlBlockNames = void 0;\nvar htmlBlockNames = ['address', 'article', 'aside', 'base', 'basefont', 'blockquote', 'body', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dialog', 'dir', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hr', 'html', 'iframe', 'legend', 'li', 'link', 'main', 'menu', 'menuitem', 'nav', 'noframes', 'ol', 'optgroup', 'option', 'p', 'param', 'section', 'source', 'summary', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul'];\n/**\n * List of lowercase HTML tag names which when parsing HTML (flow), result in\n * HTML that can include lines w/o exiting, until a closing tag also in this\n * list is found (condition 1).\n *\n * This module is copied from:\n * <https://spec.commonmark.org/0.29/#html-blocks>.\n *\n * Note that `textarea` is not available in `CommonMark@0.29` but has been\n * merged to the primary branch and is slated to be released in the next release\n * of CommonMark.\n */\n\nexports.htmlBlockNames = htmlBlockNames;\nvar htmlRawNames = ['pre', 'script', 'style', 'textarea'];\nexports.htmlRawNames = htmlRawNames;",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-html-tag-name/index.js"
    },
    "{1275C03B-CD0D-4B78-9ECE-68CE38EA4BE9}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.blankLine = void 0;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/** @type {Construct} */\nvar blankLine = {\n  tokenize: tokenizeBlankLine,\n  partial: true\n};\n/** @type {Tokenizer} */\n\nexports.blankLine = blankLine;\n\nfunction tokenizeBlankLine(effects, ok, nok) {\n  return (0, _micromarkFactorySpace.factorySpace)(effects, afterWhitespace, 'linePrefix');\n  /** @type {State} */\n\n  function afterWhitespace(code) {\n    return code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code) ? ok(code) : nok(code);\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-core-commonmark/lib/blank-line.js"
    },
    "{46EEFB01-D4D5-4B79-9696-D0AC21887895}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n* @typedef {import('micromark-util-types').State} State\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.htmlText = void 0;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/** @type {Construct} */\nvar htmlText = {\n  name: 'htmlText',\n  tokenize: tokenizeHtmlText\n};\n/** @type {Tokenizer} */\n\nexports.htmlText = htmlText;\n\nfunction tokenizeHtmlText(effects, ok, nok) {\n  var self = this;\n  /** @type {NonNullable<Code>|undefined} */\n\n  var marker;\n  /** @type {string} */\n\n  var buffer;\n  /** @type {number} */\n\n  var index;\n  /** @type {State} */\n\n  var returnState;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('htmlText');\n    effects.enter('htmlTextData');\n    effects.consume(code);\n    return open;\n  }\n  /** @type {State} */\n\n\n  function open(code) {\n    if (code === 33) {\n      effects.consume(code);\n      return declarationOpen;\n    }\n\n    if (code === 47) {\n      effects.consume(code);\n      return tagCloseStart;\n    }\n\n    if (code === 63) {\n      effects.consume(code);\n      return instruction;\n    }\n\n    if ((0, _micromarkUtilCharacter.asciiAlpha)(code)) {\n      effects.consume(code);\n      return tagOpen;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function declarationOpen(code) {\n    if (code === 45) {\n      effects.consume(code);\n      return commentOpen;\n    }\n\n    if (code === 91) {\n      effects.consume(code);\n      buffer = 'CDATA[';\n      index = 0;\n      return cdataOpen;\n    }\n\n    if ((0, _micromarkUtilCharacter.asciiAlpha)(code)) {\n      effects.consume(code);\n      return declaration;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function commentOpen(code) {\n    if (code === 45) {\n      effects.consume(code);\n      return commentStart;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function commentStart(code) {\n    if (code === null || code === 62) {\n      return nok(code);\n    }\n\n    if (code === 45) {\n      effects.consume(code);\n      return commentStartDash;\n    }\n\n    return comment(code);\n  }\n  /** @type {State} */\n\n\n  function commentStartDash(code) {\n    if (code === null || code === 62) {\n      return nok(code);\n    }\n\n    return comment(code);\n  }\n  /** @type {State} */\n\n\n  function comment(code) {\n    if (code === null) {\n      return nok(code);\n    }\n\n    if (code === 45) {\n      effects.consume(code);\n      return commentClose;\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      returnState = comment;\n      return atLineEnding(code);\n    }\n\n    effects.consume(code);\n    return comment;\n  }\n  /** @type {State} */\n\n\n  function commentClose(code) {\n    if (code === 45) {\n      effects.consume(code);\n      return end;\n    }\n\n    return comment(code);\n  }\n  /** @type {State} */\n\n\n  function cdataOpen(code) {\n    if (code === buffer.charCodeAt(index++)) {\n      effects.consume(code);\n      return index === buffer.length ? cdata : cdataOpen;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function cdata(code) {\n    if (code === null) {\n      return nok(code);\n    }\n\n    if (code === 93) {\n      effects.consume(code);\n      return cdataClose;\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      returnState = cdata;\n      return atLineEnding(code);\n    }\n\n    effects.consume(code);\n    return cdata;\n  }\n  /** @type {State} */\n\n\n  function cdataClose(code) {\n    if (code === 93) {\n      effects.consume(code);\n      return cdataEnd;\n    }\n\n    return cdata(code);\n  }\n  /** @type {State} */\n\n\n  function cdataEnd(code) {\n    if (code === 62) {\n      return end(code);\n    }\n\n    if (code === 93) {\n      effects.consume(code);\n      return cdataEnd;\n    }\n\n    return cdata(code);\n  }\n  /** @type {State} */\n\n\n  function declaration(code) {\n    if (code === null || code === 62) {\n      return end(code);\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      returnState = declaration;\n      return atLineEnding(code);\n    }\n\n    effects.consume(code);\n    return declaration;\n  }\n  /** @type {State} */\n\n\n  function instruction(code) {\n    if (code === null) {\n      return nok(code);\n    }\n\n    if (code === 63) {\n      effects.consume(code);\n      return instructionClose;\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      returnState = instruction;\n      return atLineEnding(code);\n    }\n\n    effects.consume(code);\n    return instruction;\n  }\n  /** @type {State} */\n\n\n  function instructionClose(code) {\n    return code === 62 ? end(code) : instruction(code);\n  }\n  /** @type {State} */\n\n\n  function tagCloseStart(code) {\n    if ((0, _micromarkUtilCharacter.asciiAlpha)(code)) {\n      effects.consume(code);\n      return tagClose;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function tagClose(code) {\n    if (code === 45 || (0, _micromarkUtilCharacter.asciiAlphanumeric)(code)) {\n      effects.consume(code);\n      return tagClose;\n    }\n\n    return tagCloseBetween(code);\n  }\n  /** @type {State} */\n\n\n  function tagCloseBetween(code) {\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      returnState = tagCloseBetween;\n      return atLineEnding(code);\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.consume(code);\n      return tagCloseBetween;\n    }\n\n    return end(code);\n  }\n  /** @type {State} */\n\n\n  function tagOpen(code) {\n    if (code === 45 || (0, _micromarkUtilCharacter.asciiAlphanumeric)(code)) {\n      effects.consume(code);\n      return tagOpen;\n    }\n\n    if (code === 47 || code === 62 || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code)) {\n      return tagOpenBetween(code);\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function tagOpenBetween(code) {\n    if (code === 47) {\n      effects.consume(code);\n      return end;\n    }\n\n    if (code === 58 || code === 95 || (0, _micromarkUtilCharacter.asciiAlpha)(code)) {\n      effects.consume(code);\n      return tagOpenAttributeName;\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      returnState = tagOpenBetween;\n      return atLineEnding(code);\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.consume(code);\n      return tagOpenBetween;\n    }\n\n    return end(code);\n  }\n  /** @type {State} */\n\n\n  function tagOpenAttributeName(code) {\n    if (code === 45 || code === 46 || code === 58 || code === 95 || (0, _micromarkUtilCharacter.asciiAlphanumeric)(code)) {\n      effects.consume(code);\n      return tagOpenAttributeName;\n    }\n\n    return tagOpenAttributeNameAfter(code);\n  }\n  /** @type {State} */\n\n\n  function tagOpenAttributeNameAfter(code) {\n    if (code === 61) {\n      effects.consume(code);\n      return tagOpenAttributeValueBefore;\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      returnState = tagOpenAttributeNameAfter;\n      return atLineEnding(code);\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.consume(code);\n      return tagOpenAttributeNameAfter;\n    }\n\n    return tagOpenBetween(code);\n  }\n  /** @type {State} */\n\n\n  function tagOpenAttributeValueBefore(code) {\n    if (code === null || code === 60 || code === 61 || code === 62 || code === 96) {\n      return nok(code);\n    }\n\n    if (code === 34 || code === 39) {\n      effects.consume(code);\n      marker = code;\n      return tagOpenAttributeValueQuoted;\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      returnState = tagOpenAttributeValueBefore;\n      return atLineEnding(code);\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.consume(code);\n      return tagOpenAttributeValueBefore;\n    }\n\n    effects.consume(code);\n    marker = undefined;\n    return tagOpenAttributeValueUnquoted;\n  }\n  /** @type {State} */\n\n\n  function tagOpenAttributeValueQuoted(code) {\n    if (code === marker) {\n      effects.consume(code);\n      return tagOpenAttributeValueQuotedAfter;\n    }\n\n    if (code === null) {\n      return nok(code);\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      returnState = tagOpenAttributeValueQuoted;\n      return atLineEnding(code);\n    }\n\n    effects.consume(code);\n    return tagOpenAttributeValueQuoted;\n  }\n  /** @type {State} */\n\n\n  function tagOpenAttributeValueQuotedAfter(code) {\n    if (code === 62 || code === 47 || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code)) {\n      return tagOpenBetween(code);\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function tagOpenAttributeValueUnquoted(code) {\n    if (code === null || code === 34 || code === 39 || code === 60 || code === 61 || code === 96) {\n      return nok(code);\n    }\n\n    if (code === 62 || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code)) {\n      return tagOpenBetween(code);\n    }\n\n    effects.consume(code);\n    return tagOpenAttributeValueUnquoted;\n  } // We can’t have blank lines in content, so no need to worry about empty\n  // tokens.\n\n  /** @type {State} */\n\n\n  function atLineEnding(code) {\n    effects.exit('htmlTextData');\n    effects.enter('lineEnding');\n    effects.consume(code);\n    effects.exit('lineEnding');\n    return (0, _micromarkFactorySpace.factorySpace)(effects, afterPrefix, 'linePrefix', self.parser.constructs.disable[\"null\"].includes('codeIndented') ? undefined : 4);\n  }\n  /** @type {State} */\n\n\n  function afterPrefix(code) {\n    effects.enter('htmlTextData');\n    return returnState(code);\n  }\n  /** @type {State} */\n\n\n  function end(code) {\n    if (code === 62) {\n      effects.consume(code);\n      effects.exit('htmlTextData');\n      effects.exit('htmlText');\n      return ok;\n    }\n\n    return nok(code);\n  }\n}",
        "mapping": {
            "micromark-factory-space": "{4927E951-7D29-4511-91E5-3040F6DD96E0}",
            "micromark-util-character": "{4F40D193-6E3B-469B-8626-55DEDC151D2E}"
        },
        "path": "{remark-parse}/../micromark-core-commonmark/lib/html-text.js"
    },
    "{4927E951-7D29-4511-91E5-3040F6DD96E0}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Effects} Effects\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factorySpace = factorySpace;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {string} type\n * @param {number} [max=Infinity]\n * @returns {State}\n */\nfunction factorySpace(effects, ok, type, max) {\n  var limit = max ? max - 1 : Number.POSITIVE_INFINITY;\n  var size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.enter(type);\n      return prefix(code);\n    }\n\n    return ok(code);\n  }\n  /** @type {State} */\n\n\n  function prefix(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code) && size++ < limit) {\n      effects.consume(code);\n      return prefix;\n    }\n\n    effects.exit(type);\n    return ok(code);\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-factory-space/index.js"
    },
    "{4F40D193-6E3B-469B-8626-55DEDC151D2E}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{0C59C510-54EE-4531-AA45-A15211DAD1C7}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').Resolver} Resolver\n* @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n* @typedef {import('micromark-util-types').Event} Event\n* @typedef {import('micromark-util-types').Token} Token\n* @typedef {import('micromark-util-types').State} State\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.labelEnd = void 0;\n\nvar _micromarkFactoryDestination = require(\"micromark-factory-destination\");\n\nvar _micromarkFactoryLabel = require(\"micromark-factory-label\");\n\nvar _micromarkFactoryTitle = require(\"micromark-factory-title\");\n\nvar _micromarkFactoryWhitespace = require(\"micromark-factory-whitespace\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\nvar _micromarkUtilChunked = require(\"micromark-util-chunked\");\n\nvar _micromarkUtilNormalizeIdentifier = require(\"micromark-util-normalize-identifier\");\n\nvar _micromarkUtilResolveAll = require(\"micromark-util-resolve-all\");\n\n/** @type {Construct} */\nvar labelEnd = {\n  name: 'labelEnd',\n  tokenize: tokenizeLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  resolveAll: resolveAllLabelEnd\n};\n/** @type {Construct} */\n\nexports.labelEnd = labelEnd;\nvar resourceConstruct = {\n  tokenize: tokenizeResource\n};\n/** @type {Construct} */\n\nvar fullReferenceConstruct = {\n  tokenize: tokenizeFullReference\n};\n/** @type {Construct} */\n\nvar collapsedReferenceConstruct = {\n  tokenize: tokenizeCollapsedReference\n};\n/** @type {Resolver} */\n\nfunction resolveAllLabelEnd(events) {\n  var index = -1;\n  /** @type {Token} */\n\n  var token;\n\n  while (++index < events.length) {\n    token = events[index][1];\n\n    if (token.type === 'labelImage' || token.type === 'labelLink' || token.type === 'labelEnd') {\n      // Remove the marker.\n      events.splice(index + 1, token.type === 'labelImage' ? 4 : 2);\n      token.type = 'data';\n      index++;\n    }\n  }\n\n  return events;\n}\n/** @type {Resolver} */\n\n\nfunction resolveToLabelEnd(events, context) {\n  var index = events.length;\n  var offset = 0;\n  /** @type {Token} */\n\n  var token;\n  /** @type {number|undefined} */\n\n  var open;\n  /** @type {number|undefined} */\n\n  var close;\n  /** @type {Event[]} */\n\n  var media; // Find an opening.\n\n  while (index--) {\n    token = events[index][1];\n\n    if (open) {\n      // If we see another link, or inactive link label, we’ve been here before.\n      if (token.type === 'link' || token.type === 'labelLink' && token._inactive) {\n        break;\n      } // Mark other link openings as inactive, as we can’t have links in\n      // links.\n\n\n      if (events[index][0] === 'enter' && token.type === 'labelLink') {\n        token._inactive = true;\n      }\n    } else if (close) {\n      if (events[index][0] === 'enter' && (token.type === 'labelImage' || token.type === 'labelLink') && !token._balanced) {\n        open = index;\n\n        if (token.type !== 'labelLink') {\n          offset = 2;\n          break;\n        }\n      }\n    } else if (token.type === 'labelEnd') {\n      close = index;\n    }\n  }\n\n  var group = {\n    type: events[open][1].type === 'labelLink' ? 'link' : 'image',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  };\n  var label = {\n    type: 'label',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[close][1].end)\n  };\n  var text = {\n    type: 'labelText',\n    start: Object.assign({}, events[open + offset + 2][1].end),\n    end: Object.assign({}, events[close - 2][1].start)\n  };\n  media = [['enter', group, context], ['enter', label, context]]; // Opening marker.\n\n  media = (0, _micromarkUtilChunked.push)(media, events.slice(open + 1, open + offset + 3)); // Text open.\n\n  media = (0, _micromarkUtilChunked.push)(media, [['enter', text, context]]); // Between.\n\n  media = (0, _micromarkUtilChunked.push)(media, (0, _micromarkUtilResolveAll.resolveAll)(context.parser.constructs.insideSpan[\"null\"], events.slice(open + offset + 4, close - 3), context)); // Text close, marker close, label close.\n\n  media = (0, _micromarkUtilChunked.push)(media, [['exit', text, context], events[close - 2], events[close - 1], ['exit', label, context]]); // Reference, resource, or so.\n\n  media = (0, _micromarkUtilChunked.push)(media, events.slice(close + 1)); // Media close.\n\n  media = (0, _micromarkUtilChunked.push)(media, [['exit', group, context]]);\n  (0, _micromarkUtilChunked.splice)(events, open, events.length, media);\n  return events;\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  var self = this;\n  var index = self.events.length;\n  /** @type {Token} */\n\n  var labelStart;\n  /** @type {boolean} */\n\n  var defined; // Find an opening.\n\n  while (index--) {\n    if ((self.events[index][1].type === 'labelImage' || self.events[index][1].type === 'labelLink') && !self.events[index][1]._balanced) {\n      labelStart = self.events[index][1];\n      break;\n    }\n  }\n\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (!labelStart) {\n      return nok(code);\n    } // It’s a balanced bracket, but contains a link.\n\n\n    if (labelStart._inactive) return balanced(code);\n    defined = self.parser.defined.includes((0, _micromarkUtilNormalizeIdentifier.normalizeIdentifier)(self.sliceSerialize({\n      start: labelStart.end,\n      end: self.now()\n    })));\n    effects.enter('labelEnd');\n    effects.enter('labelMarker');\n    effects.consume(code);\n    effects.exit('labelMarker');\n    effects.exit('labelEnd');\n    return afterLabelEnd;\n  }\n  /** @type {State} */\n\n\n  function afterLabelEnd(code) {\n    // Resource: `[asd](fgh)`.\n    if (code === 40) {\n      return effects.attempt(resourceConstruct, ok, defined ? ok : balanced)(code);\n    } // Collapsed (`[asd][]`) or full (`[asd][fgh]`) reference?\n\n\n    if (code === 91) {\n      return effects.attempt(fullReferenceConstruct, ok, defined ? effects.attempt(collapsedReferenceConstruct, ok, balanced) : balanced)(code);\n    } // Shortcut reference: `[asd]`?\n\n\n    return defined ? ok(code) : balanced(code);\n  }\n  /** @type {State} */\n\n\n  function balanced(code) {\n    labelStart._balanced = true;\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeResource(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('resource');\n    effects.enter('resourceMarker');\n    effects.consume(code);\n    effects.exit('resourceMarker');\n    return (0, _micromarkFactoryWhitespace.factoryWhitespace)(effects, open);\n  }\n  /** @type {State} */\n\n\n  function open(code) {\n    if (code === 41) {\n      return end(code);\n    }\n\n    return (0, _micromarkFactoryDestination.factoryDestination)(effects, destinationAfter, nok, 'resourceDestination', 'resourceDestinationLiteral', 'resourceDestinationLiteralMarker', 'resourceDestinationRaw', 'resourceDestinationString', 32)(code);\n  }\n  /** @type {State} */\n\n\n  function destinationAfter(code) {\n    return (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code) ? (0, _micromarkFactoryWhitespace.factoryWhitespace)(effects, between)(code) : end(code);\n  }\n  /** @type {State} */\n\n\n  function between(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return (0, _micromarkFactoryTitle.factoryTitle)(effects, (0, _micromarkFactoryWhitespace.factoryWhitespace)(effects, end), nok, 'resourceTitle', 'resourceTitleMarker', 'resourceTitleString')(code);\n    }\n\n    return end(code);\n  }\n  /** @type {State} */\n\n\n  function end(code) {\n    if (code === 41) {\n      effects.enter('resourceMarker');\n      effects.consume(code);\n      effects.exit('resourceMarker');\n      effects.exit('resource');\n      return ok;\n    }\n\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeFullReference(effects, ok, nok) {\n  var self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    return _micromarkFactoryLabel.factoryLabel.call(self, effects, afterLabel, nok, 'reference', 'referenceMarker', 'referenceString')(code);\n  }\n  /** @type {State} */\n\n\n  function afterLabel(code) {\n    return self.parser.defined.includes((0, _micromarkUtilNormalizeIdentifier.normalizeIdentifier)(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1))) ? ok(code) : nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeCollapsedReference(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('reference');\n    effects.enter('referenceMarker');\n    effects.consume(code);\n    effects.exit('referenceMarker');\n    return open;\n  }\n  /** @type {State} */\n\n\n  function open(code) {\n    if (code === 93) {\n      effects.enter('referenceMarker');\n      effects.consume(code);\n      effects.exit('referenceMarker');\n      effects.exit('reference');\n      return ok;\n    }\n\n    return nok(code);\n  }\n}",
        "mapping": {
            "micromark-factory-destination": "{D529E171-4965-4D04-8B8C-1E77AD9BD392}",
            "micromark-factory-label": "{9B5472C8-3A6E-4AEB-A7AC-A63AC75A30E7}",
            "micromark-factory-title": "{31AEDE69-A673-4D29-A47E-212C254A5701}",
            "micromark-factory-whitespace": "{FE5503DF-5965-4C40-AEB6-F618A386D68B}",
            "micromark-util-character": "{697AD78E-8CF9-47B6-9F7F-D781AE267A6A}",
            "micromark-util-chunked": "{543C13F7-03FB-435A-BFE9-F352D77885D7}",
            "micromark-util-normalize-identifier": "{459B7028-DC25-46C0-A9AB-E07ADBBFA274}",
            "micromark-util-resolve-all": "{D1F52E1C-B1A1-4C48-BD44-9183AD0CCC5B}"
        },
        "path": "{remark-parse}/../micromark-core-commonmark/lib/label-end.js"
    },
    "{D529E171-4965-4D04-8B8C-1E77AD9BD392}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Effects} Effects\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factoryDestination = factoryDestination;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {State} nok\n * @param {string} type\n * @param {string} literalType\n * @param {string} literalMarkerType\n * @param {string} rawType\n * @param {string} stringType\n * @param {number} [max=Infinity]\n * @returns {State}\n */\n// eslint-disable-next-line max-params\nfunction factoryDestination(effects, ok, nok, type, literalType, literalMarkerType, rawType, stringType, max) {\n  var limit = max || Number.POSITIVE_INFINITY;\n  var balance = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (code === 60) {\n      effects.enter(type);\n      effects.enter(literalType);\n      effects.enter(literalMarkerType);\n      effects.consume(code);\n      effects.exit(literalMarkerType);\n      return destinationEnclosedBefore;\n    }\n\n    if (code === null || code === 41 || (0, _micromarkUtilCharacter.asciiControl)(code)) {\n      return nok(code);\n    }\n\n    effects.enter(type);\n    effects.enter(rawType);\n    effects.enter(stringType);\n    effects.enter('chunkString', {\n      contentType: 'string'\n    });\n    return destinationRaw(code);\n  }\n  /** @type {State} */\n\n\n  function destinationEnclosedBefore(code) {\n    if (code === 62) {\n      effects.enter(literalMarkerType);\n      effects.consume(code);\n      effects.exit(literalMarkerType);\n      effects.exit(literalType);\n      effects.exit(type);\n      return ok;\n    }\n\n    effects.enter(stringType);\n    effects.enter('chunkString', {\n      contentType: 'string'\n    });\n    return destinationEnclosed(code);\n  }\n  /** @type {State} */\n\n\n  function destinationEnclosed(code) {\n    if (code === 62) {\n      effects.exit('chunkString');\n      effects.exit(stringType);\n      return destinationEnclosedBefore(code);\n    }\n\n    if (code === null || code === 60 || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      return nok(code);\n    }\n\n    effects.consume(code);\n    return code === 92 ? destinationEnclosedEscape : destinationEnclosed;\n  }\n  /** @type {State} */\n\n\n  function destinationEnclosedEscape(code) {\n    if (code === 60 || code === 62 || code === 92) {\n      effects.consume(code);\n      return destinationEnclosed;\n    }\n\n    return destinationEnclosed(code);\n  }\n  /** @type {State} */\n\n\n  function destinationRaw(code) {\n    if (code === 40) {\n      if (++balance > limit) return nok(code);\n      effects.consume(code);\n      return destinationRaw;\n    }\n\n    if (code === 41) {\n      if (!balance--) {\n        effects.exit('chunkString');\n        effects.exit(stringType);\n        effects.exit(rawType);\n        effects.exit(type);\n        return ok(code);\n      }\n\n      effects.consume(code);\n      return destinationRaw;\n    }\n\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code)) {\n      if (balance) return nok(code);\n      effects.exit('chunkString');\n      effects.exit(stringType);\n      effects.exit(rawType);\n      effects.exit(type);\n      return ok(code);\n    }\n\n    if ((0, _micromarkUtilCharacter.asciiControl)(code)) return nok(code);\n    effects.consume(code);\n    return code === 92 ? destinationRawEscape : destinationRaw;\n  }\n  /** @type {State} */\n\n\n  function destinationRawEscape(code) {\n    if (code === 40 || code === 41 || code === 92) {\n      effects.consume(code);\n      return destinationRaw;\n    }\n\n    return destinationRaw(code);\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-factory-destination/index.js"
    },
    "{9B5472C8-3A6E-4AEB-A7AC-A63AC75A30E7}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Effects} Effects\n* @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factoryLabel = factoryLabel;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @this {TokenizeContext}\n * @param {Effects} effects\n * @param {State} ok\n * @param {State} nok\n * @param {string} type\n * @param {string} markerType\n * @param {string} stringType\n * @returns {State}\n */\n// eslint-disable-next-line max-params\nfunction factoryLabel(effects, ok, nok, type, markerType, stringType) {\n  var self = this;\n  var size = 0;\n  /** @type {boolean} */\n\n  var data;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter(type);\n    effects.enter(markerType);\n    effects.consume(code);\n    effects.exit(markerType);\n    effects.enter(stringType);\n    return atBreak;\n  }\n  /** @type {State} */\n\n\n  function atBreak(code) {\n    if (code === null || code === 91 || code === 93 && !data ||\n    /* To do: remove in the future once we’ve switched from\n     * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,\n     * which doesn’t need this */\n\n    /* Hidden footnotes hook */\n\n    /* c8 ignore next 3 */\n    code === 94 && !size && '_hiddenFootnoteSupport' in self.parser.constructs || size > 999) {\n      return nok(code);\n    }\n\n    if (code === 93) {\n      effects.exit(stringType);\n      effects.enter(markerType);\n      effects.consume(code);\n      effects.exit(markerType);\n      effects.exit(type);\n      return ok;\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return atBreak;\n    }\n\n    effects.enter('chunkString', {\n      contentType: 'string'\n    });\n    return label(code);\n  }\n  /** @type {State} */\n\n\n  function label(code) {\n    if (code === null || code === 91 || code === 93 || (0, _micromarkUtilCharacter.markdownLineEnding)(code) || size++ > 999) {\n      effects.exit('chunkString');\n      return atBreak(code);\n    }\n\n    effects.consume(code);\n    data = data || !(0, _micromarkUtilCharacter.markdownSpace)(code);\n    return code === 92 ? labelEscape : label;\n  }\n  /** @type {State} */\n\n\n  function labelEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code);\n      size++;\n      return label;\n    }\n\n    return label(code);\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-factory-label/index.js"
    },
    "{31AEDE69-A673-4D29-A47E-212C254A5701}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Effects} Effects\n* @typedef {import('micromark-util-types').State} State\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factoryTitle = factoryTitle;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {State} nok\n * @param {string} type\n * @param {string} markerType\n * @param {string} stringType\n * @returns {State}\n */\n// eslint-disable-next-line max-params\nfunction factoryTitle(effects, ok, nok, type, markerType, stringType) {\n  /** @type {NonNullable<Code>} */\n  var marker;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter(type);\n    effects.enter(markerType);\n    effects.consume(code);\n    effects.exit(markerType);\n    marker = code === 40 ? 41 : code;\n    return atFirstTitleBreak;\n  }\n  /** @type {State} */\n\n\n  function atFirstTitleBreak(code) {\n    if (code === marker) {\n      effects.enter(markerType);\n      effects.consume(code);\n      effects.exit(markerType);\n      effects.exit(type);\n      return ok;\n    }\n\n    effects.enter(stringType);\n    return atTitleBreak(code);\n  }\n  /** @type {State} */\n\n\n  function atTitleBreak(code) {\n    if (code === marker) {\n      effects.exit(stringType);\n      return atFirstTitleBreak(marker);\n    }\n\n    if (code === null) {\n      return nok(code);\n    } // Note: blank lines can’t exist in content.\n\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return (0, _micromarkFactorySpace.factorySpace)(effects, atTitleBreak, 'linePrefix');\n    }\n\n    effects.enter('chunkString', {\n      contentType: 'string'\n    });\n    return title(code);\n  }\n  /** @type {State} */\n\n\n  function title(code) {\n    if (code === marker || code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.exit('chunkString');\n      return atTitleBreak(code);\n    }\n\n    effects.consume(code);\n    return code === 92 ? titleEscape : title;\n  }\n  /** @type {State} */\n\n\n  function titleEscape(code) {\n    if (code === marker || code === 92) {\n      effects.consume(code);\n      return title;\n    }\n\n    return title(code);\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-factory-title/index.js"
    },
    "{FE5503DF-5965-4C40-AEB6-F618A386D68B}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Effects} Effects\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factoryWhitespace = factoryWhitespace;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n */\nfunction factoryWhitespace(effects, ok) {\n  /** @type {boolean} */\n  var seen;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      seen = true;\n      return start;\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      return (0, _micromarkFactorySpace.factorySpace)(effects, start, seen ? 'linePrefix' : 'lineSuffix')(code);\n    }\n\n    return ok(code);\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-factory-whitespace/index.js"
    },
    "{697AD78E-8CF9-47B6-9F7F-D781AE267A6A}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{543C13F7-03FB-435A-BFE9-F352D77885D7}": {
        "source": "\"use strict\";\n/**\n* Like `Array#splice`, but smarter for giant arrays.\n*\n* `Array#splice` takes all items to be inserted as individual argument which\n* causes a stack overflow in V8 when trying to insert 100k items for instance.\n*\n* Otherwise, this does not return the removed items, and takes `items` as an\n* array instead of rest parameters.\n*\n* @template {unknown} T\n* @param {T[]} list\n* @param {number} start\n* @param {number} remove\n* @param {T[]} items\n* @returns {void}\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.push = push;\nexports.splice = splice;\n\nfunction splice(list, start, remove, items) {\n  var end = list.length;\n  var chunkStart = 0;\n  /** @type {unknown[]} */\n\n  var parameters; // Make start between zero and `end` (included).\n\n  if (start < 0) {\n    start = -start > end ? 0 : end + start;\n  } else {\n    start = start > end ? end : start;\n  }\n\n  remove = remove > 0 ? remove : 0; // No need to chunk the items if there’s only a couple (10k) items.\n\n  if (items.length < 10000) {\n    parameters = Array.from(items);\n    parameters.unshift(start, remove) // @ts-expect-error Hush, it’s fine.\n    ;\n    [].splice.apply(list, parameters);\n  } else {\n    // Delete `remove` items starting from `start`\n    if (remove) [].splice.apply(list, [start, remove]); // Insert the items in chunks to not cause stack overflows.\n\n    while (chunkStart < items.length) {\n      parameters = items.slice(chunkStart, chunkStart + 10000);\n      parameters.unshift(start, 0) // @ts-expect-error Hush, it’s fine.\n      ;\n      [].splice.apply(list, parameters);\n      chunkStart += 10000;\n      start += 10000;\n    }\n  }\n}\n/**\n * Append `items` (an array) at the end of `list` (another array).\n * When `list` was empty, returns `items` instead.\n *\n * This prevents a potentially expensive operation when `list` is empty,\n * and adds items in batches to prevent V8 from hanging.\n *\n * @template {unknown} T\n * @param {T[]} list\n * @param {T[]} items\n * @returns {T[]}\n */\n\n\nfunction push(list, items) {\n  if (list.length > 0) {\n    splice(list, list.length, 0, items);\n    return list;\n  }\n\n  return items;\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-chunked/index.js"
    },
    "{459B7028-DC25-46C0-A9AB-E07ADBBFA274}": {
        "source": "\"use strict\";\n/**\n* Normalize an identifier (such as used in definitions).\n*\n* @param {string} value\n* @returns {string}\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.normalizeIdentifier = normalizeIdentifier;\n\nfunction normalizeIdentifier(value) {\n  return value // Collapse Markdown whitespace.\n  .replace(/[\\t\\n\\r ]+/g, ' ') // Trim.\n  .replace(/^ | $/g, '') // Some characters are considered “uppercase”, but if their lowercase\n  // counterpart is uppercased will result in a different uppercase\n  // character.\n  // Hence, to get that form, we perform both lower- and uppercase.\n  // Upper case makes sure keys will not interact with default prototypal\n  // methods: no method is uppercase.\n  .toLowerCase().toUpperCase();\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-normalize-identifier/index.js"
    },
    "{D1F52E1C-B1A1-4C48-BD44-9183AD0CCC5B}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n* @typedef {import('micromark-util-types').Event} Event\n* @typedef {import('micromark-util-types').Resolver} Resolver\n*/\n\n/**\n * Call all `resolveAll`s.\n *\n * @param {{resolveAll?: Resolver}[]} constructs\n * @param {Event[]} events\n * @param {TokenizeContext} context\n * @returns {Event[]}\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveAll = resolveAll;\n\nfunction resolveAll(constructs, events, context) {\n  /** @type {Resolver[]} */\n  var called = [];\n  var index = -1;\n\n  while (++index < constructs.length) {\n    var resolve = constructs[index].resolveAll;\n\n    if (resolve && !called.includes(resolve)) {\n      events = resolve(events, context);\n      called.push(resolve);\n    }\n  }\n\n  return events;\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-resolve-all/index.js"
    },
    "{B5A9F5F4-875D-4BF6-BD87-2EE5DACF5BB7}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.labelStartImage = void 0;\n\nvar _labelEnd = require(\"./label-end.js\");\n\n/** @type {Construct} */\nvar labelStartImage = {\n  name: 'labelStartImage',\n  tokenize: tokenizeLabelStartImage,\n  resolveAll: _labelEnd.labelEnd.resolveAll\n};\n/** @type {Tokenizer} */\n\nexports.labelStartImage = labelStartImage;\n\nfunction tokenizeLabelStartImage(effects, ok, nok) {\n  var self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('labelImage');\n    effects.enter('labelImageMarker');\n    effects.consume(code);\n    effects.exit('labelImageMarker');\n    return open;\n  }\n  /** @type {State} */\n\n\n  function open(code) {\n    if (code === 91) {\n      effects.enter('labelMarker');\n      effects.consume(code);\n      effects.exit('labelMarker');\n      effects.exit('labelImage');\n      return after;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    /* To do: remove in the future once we’ve switched from\n     * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,\n     * which doesn’t need this */\n\n    /* Hidden footnotes hook */\n\n    /* c8 ignore next 3 */\n    return code === 94 && '_hiddenFootnoteSupport' in self.parser.constructs ? nok(code) : ok(code);\n  }\n}",
        "mapping": {
            "./label-end.js": "{DE9F7456-9A45-4655-9A11-ED134F04DD64}"
        },
        "path": "{remark-parse}/../micromark-core-commonmark/lib/label-start-image.js"
    },
    "{DE9F7456-9A45-4655-9A11-ED134F04DD64}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').Resolver} Resolver\n* @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n* @typedef {import('micromark-util-types').Event} Event\n* @typedef {import('micromark-util-types').Token} Token\n* @typedef {import('micromark-util-types').State} State\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.labelEnd = void 0;\n\nvar _micromarkFactoryDestination = require(\"micromark-factory-destination\");\n\nvar _micromarkFactoryLabel = require(\"micromark-factory-label\");\n\nvar _micromarkFactoryTitle = require(\"micromark-factory-title\");\n\nvar _micromarkFactoryWhitespace = require(\"micromark-factory-whitespace\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\nvar _micromarkUtilChunked = require(\"micromark-util-chunked\");\n\nvar _micromarkUtilNormalizeIdentifier = require(\"micromark-util-normalize-identifier\");\n\nvar _micromarkUtilResolveAll = require(\"micromark-util-resolve-all\");\n\n/** @type {Construct} */\nvar labelEnd = {\n  name: 'labelEnd',\n  tokenize: tokenizeLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  resolveAll: resolveAllLabelEnd\n};\n/** @type {Construct} */\n\nexports.labelEnd = labelEnd;\nvar resourceConstruct = {\n  tokenize: tokenizeResource\n};\n/** @type {Construct} */\n\nvar fullReferenceConstruct = {\n  tokenize: tokenizeFullReference\n};\n/** @type {Construct} */\n\nvar collapsedReferenceConstruct = {\n  tokenize: tokenizeCollapsedReference\n};\n/** @type {Resolver} */\n\nfunction resolveAllLabelEnd(events) {\n  var index = -1;\n  /** @type {Token} */\n\n  var token;\n\n  while (++index < events.length) {\n    token = events[index][1];\n\n    if (token.type === 'labelImage' || token.type === 'labelLink' || token.type === 'labelEnd') {\n      // Remove the marker.\n      events.splice(index + 1, token.type === 'labelImage' ? 4 : 2);\n      token.type = 'data';\n      index++;\n    }\n  }\n\n  return events;\n}\n/** @type {Resolver} */\n\n\nfunction resolveToLabelEnd(events, context) {\n  var index = events.length;\n  var offset = 0;\n  /** @type {Token} */\n\n  var token;\n  /** @type {number|undefined} */\n\n  var open;\n  /** @type {number|undefined} */\n\n  var close;\n  /** @type {Event[]} */\n\n  var media; // Find an opening.\n\n  while (index--) {\n    token = events[index][1];\n\n    if (open) {\n      // If we see another link, or inactive link label, we’ve been here before.\n      if (token.type === 'link' || token.type === 'labelLink' && token._inactive) {\n        break;\n      } // Mark other link openings as inactive, as we can’t have links in\n      // links.\n\n\n      if (events[index][0] === 'enter' && token.type === 'labelLink') {\n        token._inactive = true;\n      }\n    } else if (close) {\n      if (events[index][0] === 'enter' && (token.type === 'labelImage' || token.type === 'labelLink') && !token._balanced) {\n        open = index;\n\n        if (token.type !== 'labelLink') {\n          offset = 2;\n          break;\n        }\n      }\n    } else if (token.type === 'labelEnd') {\n      close = index;\n    }\n  }\n\n  var group = {\n    type: events[open][1].type === 'labelLink' ? 'link' : 'image',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  };\n  var label = {\n    type: 'label',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[close][1].end)\n  };\n  var text = {\n    type: 'labelText',\n    start: Object.assign({}, events[open + offset + 2][1].end),\n    end: Object.assign({}, events[close - 2][1].start)\n  };\n  media = [['enter', group, context], ['enter', label, context]]; // Opening marker.\n\n  media = (0, _micromarkUtilChunked.push)(media, events.slice(open + 1, open + offset + 3)); // Text open.\n\n  media = (0, _micromarkUtilChunked.push)(media, [['enter', text, context]]); // Between.\n\n  media = (0, _micromarkUtilChunked.push)(media, (0, _micromarkUtilResolveAll.resolveAll)(context.parser.constructs.insideSpan[\"null\"], events.slice(open + offset + 4, close - 3), context)); // Text close, marker close, label close.\n\n  media = (0, _micromarkUtilChunked.push)(media, [['exit', text, context], events[close - 2], events[close - 1], ['exit', label, context]]); // Reference, resource, or so.\n\n  media = (0, _micromarkUtilChunked.push)(media, events.slice(close + 1)); // Media close.\n\n  media = (0, _micromarkUtilChunked.push)(media, [['exit', group, context]]);\n  (0, _micromarkUtilChunked.splice)(events, open, events.length, media);\n  return events;\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  var self = this;\n  var index = self.events.length;\n  /** @type {Token} */\n\n  var labelStart;\n  /** @type {boolean} */\n\n  var defined; // Find an opening.\n\n  while (index--) {\n    if ((self.events[index][1].type === 'labelImage' || self.events[index][1].type === 'labelLink') && !self.events[index][1]._balanced) {\n      labelStart = self.events[index][1];\n      break;\n    }\n  }\n\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (!labelStart) {\n      return nok(code);\n    } // It’s a balanced bracket, but contains a link.\n\n\n    if (labelStart._inactive) return balanced(code);\n    defined = self.parser.defined.includes((0, _micromarkUtilNormalizeIdentifier.normalizeIdentifier)(self.sliceSerialize({\n      start: labelStart.end,\n      end: self.now()\n    })));\n    effects.enter('labelEnd');\n    effects.enter('labelMarker');\n    effects.consume(code);\n    effects.exit('labelMarker');\n    effects.exit('labelEnd');\n    return afterLabelEnd;\n  }\n  /** @type {State} */\n\n\n  function afterLabelEnd(code) {\n    // Resource: `[asd](fgh)`.\n    if (code === 40) {\n      return effects.attempt(resourceConstruct, ok, defined ? ok : balanced)(code);\n    } // Collapsed (`[asd][]`) or full (`[asd][fgh]`) reference?\n\n\n    if (code === 91) {\n      return effects.attempt(fullReferenceConstruct, ok, defined ? effects.attempt(collapsedReferenceConstruct, ok, balanced) : balanced)(code);\n    } // Shortcut reference: `[asd]`?\n\n\n    return defined ? ok(code) : balanced(code);\n  }\n  /** @type {State} */\n\n\n  function balanced(code) {\n    labelStart._balanced = true;\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeResource(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('resource');\n    effects.enter('resourceMarker');\n    effects.consume(code);\n    effects.exit('resourceMarker');\n    return (0, _micromarkFactoryWhitespace.factoryWhitespace)(effects, open);\n  }\n  /** @type {State} */\n\n\n  function open(code) {\n    if (code === 41) {\n      return end(code);\n    }\n\n    return (0, _micromarkFactoryDestination.factoryDestination)(effects, destinationAfter, nok, 'resourceDestination', 'resourceDestinationLiteral', 'resourceDestinationLiteralMarker', 'resourceDestinationRaw', 'resourceDestinationString', 32)(code);\n  }\n  /** @type {State} */\n\n\n  function destinationAfter(code) {\n    return (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code) ? (0, _micromarkFactoryWhitespace.factoryWhitespace)(effects, between)(code) : end(code);\n  }\n  /** @type {State} */\n\n\n  function between(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return (0, _micromarkFactoryTitle.factoryTitle)(effects, (0, _micromarkFactoryWhitespace.factoryWhitespace)(effects, end), nok, 'resourceTitle', 'resourceTitleMarker', 'resourceTitleString')(code);\n    }\n\n    return end(code);\n  }\n  /** @type {State} */\n\n\n  function end(code) {\n    if (code === 41) {\n      effects.enter('resourceMarker');\n      effects.consume(code);\n      effects.exit('resourceMarker');\n      effects.exit('resource');\n      return ok;\n    }\n\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeFullReference(effects, ok, nok) {\n  var self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    return _micromarkFactoryLabel.factoryLabel.call(self, effects, afterLabel, nok, 'reference', 'referenceMarker', 'referenceString')(code);\n  }\n  /** @type {State} */\n\n\n  function afterLabel(code) {\n    return self.parser.defined.includes((0, _micromarkUtilNormalizeIdentifier.normalizeIdentifier)(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1))) ? ok(code) : nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeCollapsedReference(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('reference');\n    effects.enter('referenceMarker');\n    effects.consume(code);\n    effects.exit('referenceMarker');\n    return open;\n  }\n  /** @type {State} */\n\n\n  function open(code) {\n    if (code === 93) {\n      effects.enter('referenceMarker');\n      effects.consume(code);\n      effects.exit('referenceMarker');\n      effects.exit('reference');\n      return ok;\n    }\n\n    return nok(code);\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-core-commonmark/lib/label-end.js"
    },
    "{523E41E5-5250-4860-85F4-CE0DCE6317FC}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.labelStartLink = void 0;\n\nvar _labelEnd = require(\"./label-end.js\");\n\n/** @type {Construct} */\nvar labelStartLink = {\n  name: 'labelStartLink',\n  tokenize: tokenizeLabelStartLink,\n  resolveAll: _labelEnd.labelEnd.resolveAll\n};\n/** @type {Tokenizer} */\n\nexports.labelStartLink = labelStartLink;\n\nfunction tokenizeLabelStartLink(effects, ok, nok) {\n  var self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('labelLink');\n    effects.enter('labelMarker');\n    effects.consume(code);\n    effects.exit('labelMarker');\n    effects.exit('labelLink');\n    return after;\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    /* To do: remove in the future once we’ve switched from\n     * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,\n     * which doesn’t need this */\n\n    /* Hidden footnotes hook. */\n\n    /* c8 ignore next 3 */\n    return code === 94 && '_hiddenFootnoteSupport' in self.parser.constructs ? nok(code) : ok(code);\n  }\n}",
        "mapping": {
            "./label-end.js": "{6FEFE151-DC1C-4F73-8551-0BC26A0FFDFC}"
        },
        "path": "{remark-parse}/../micromark-core-commonmark/lib/label-start-link.js"
    },
    "{6FEFE151-DC1C-4F73-8551-0BC26A0FFDFC}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').Resolver} Resolver\n* @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n* @typedef {import('micromark-util-types').Event} Event\n* @typedef {import('micromark-util-types').Token} Token\n* @typedef {import('micromark-util-types').State} State\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.labelEnd = void 0;\n\nvar _micromarkFactoryDestination = require(\"micromark-factory-destination\");\n\nvar _micromarkFactoryLabel = require(\"micromark-factory-label\");\n\nvar _micromarkFactoryTitle = require(\"micromark-factory-title\");\n\nvar _micromarkFactoryWhitespace = require(\"micromark-factory-whitespace\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\nvar _micromarkUtilChunked = require(\"micromark-util-chunked\");\n\nvar _micromarkUtilNormalizeIdentifier = require(\"micromark-util-normalize-identifier\");\n\nvar _micromarkUtilResolveAll = require(\"micromark-util-resolve-all\");\n\n/** @type {Construct} */\nvar labelEnd = {\n  name: 'labelEnd',\n  tokenize: tokenizeLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  resolveAll: resolveAllLabelEnd\n};\n/** @type {Construct} */\n\nexports.labelEnd = labelEnd;\nvar resourceConstruct = {\n  tokenize: tokenizeResource\n};\n/** @type {Construct} */\n\nvar fullReferenceConstruct = {\n  tokenize: tokenizeFullReference\n};\n/** @type {Construct} */\n\nvar collapsedReferenceConstruct = {\n  tokenize: tokenizeCollapsedReference\n};\n/** @type {Resolver} */\n\nfunction resolveAllLabelEnd(events) {\n  var index = -1;\n  /** @type {Token} */\n\n  var token;\n\n  while (++index < events.length) {\n    token = events[index][1];\n\n    if (token.type === 'labelImage' || token.type === 'labelLink' || token.type === 'labelEnd') {\n      // Remove the marker.\n      events.splice(index + 1, token.type === 'labelImage' ? 4 : 2);\n      token.type = 'data';\n      index++;\n    }\n  }\n\n  return events;\n}\n/** @type {Resolver} */\n\n\nfunction resolveToLabelEnd(events, context) {\n  var index = events.length;\n  var offset = 0;\n  /** @type {Token} */\n\n  var token;\n  /** @type {number|undefined} */\n\n  var open;\n  /** @type {number|undefined} */\n\n  var close;\n  /** @type {Event[]} */\n\n  var media; // Find an opening.\n\n  while (index--) {\n    token = events[index][1];\n\n    if (open) {\n      // If we see another link, or inactive link label, we’ve been here before.\n      if (token.type === 'link' || token.type === 'labelLink' && token._inactive) {\n        break;\n      } // Mark other link openings as inactive, as we can’t have links in\n      // links.\n\n\n      if (events[index][0] === 'enter' && token.type === 'labelLink') {\n        token._inactive = true;\n      }\n    } else if (close) {\n      if (events[index][0] === 'enter' && (token.type === 'labelImage' || token.type === 'labelLink') && !token._balanced) {\n        open = index;\n\n        if (token.type !== 'labelLink') {\n          offset = 2;\n          break;\n        }\n      }\n    } else if (token.type === 'labelEnd') {\n      close = index;\n    }\n  }\n\n  var group = {\n    type: events[open][1].type === 'labelLink' ? 'link' : 'image',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  };\n  var label = {\n    type: 'label',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[close][1].end)\n  };\n  var text = {\n    type: 'labelText',\n    start: Object.assign({}, events[open + offset + 2][1].end),\n    end: Object.assign({}, events[close - 2][1].start)\n  };\n  media = [['enter', group, context], ['enter', label, context]]; // Opening marker.\n\n  media = (0, _micromarkUtilChunked.push)(media, events.slice(open + 1, open + offset + 3)); // Text open.\n\n  media = (0, _micromarkUtilChunked.push)(media, [['enter', text, context]]); // Between.\n\n  media = (0, _micromarkUtilChunked.push)(media, (0, _micromarkUtilResolveAll.resolveAll)(context.parser.constructs.insideSpan[\"null\"], events.slice(open + offset + 4, close - 3), context)); // Text close, marker close, label close.\n\n  media = (0, _micromarkUtilChunked.push)(media, [['exit', text, context], events[close - 2], events[close - 1], ['exit', label, context]]); // Reference, resource, or so.\n\n  media = (0, _micromarkUtilChunked.push)(media, events.slice(close + 1)); // Media close.\n\n  media = (0, _micromarkUtilChunked.push)(media, [['exit', group, context]]);\n  (0, _micromarkUtilChunked.splice)(events, open, events.length, media);\n  return events;\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  var self = this;\n  var index = self.events.length;\n  /** @type {Token} */\n\n  var labelStart;\n  /** @type {boolean} */\n\n  var defined; // Find an opening.\n\n  while (index--) {\n    if ((self.events[index][1].type === 'labelImage' || self.events[index][1].type === 'labelLink') && !self.events[index][1]._balanced) {\n      labelStart = self.events[index][1];\n      break;\n    }\n  }\n\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (!labelStart) {\n      return nok(code);\n    } // It’s a balanced bracket, but contains a link.\n\n\n    if (labelStart._inactive) return balanced(code);\n    defined = self.parser.defined.includes((0, _micromarkUtilNormalizeIdentifier.normalizeIdentifier)(self.sliceSerialize({\n      start: labelStart.end,\n      end: self.now()\n    })));\n    effects.enter('labelEnd');\n    effects.enter('labelMarker');\n    effects.consume(code);\n    effects.exit('labelMarker');\n    effects.exit('labelEnd');\n    return afterLabelEnd;\n  }\n  /** @type {State} */\n\n\n  function afterLabelEnd(code) {\n    // Resource: `[asd](fgh)`.\n    if (code === 40) {\n      return effects.attempt(resourceConstruct, ok, defined ? ok : balanced)(code);\n    } // Collapsed (`[asd][]`) or full (`[asd][fgh]`) reference?\n\n\n    if (code === 91) {\n      return effects.attempt(fullReferenceConstruct, ok, defined ? effects.attempt(collapsedReferenceConstruct, ok, balanced) : balanced)(code);\n    } // Shortcut reference: `[asd]`?\n\n\n    return defined ? ok(code) : balanced(code);\n  }\n  /** @type {State} */\n\n\n  function balanced(code) {\n    labelStart._balanced = true;\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeResource(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('resource');\n    effects.enter('resourceMarker');\n    effects.consume(code);\n    effects.exit('resourceMarker');\n    return (0, _micromarkFactoryWhitespace.factoryWhitespace)(effects, open);\n  }\n  /** @type {State} */\n\n\n  function open(code) {\n    if (code === 41) {\n      return end(code);\n    }\n\n    return (0, _micromarkFactoryDestination.factoryDestination)(effects, destinationAfter, nok, 'resourceDestination', 'resourceDestinationLiteral', 'resourceDestinationLiteralMarker', 'resourceDestinationRaw', 'resourceDestinationString', 32)(code);\n  }\n  /** @type {State} */\n\n\n  function destinationAfter(code) {\n    return (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code) ? (0, _micromarkFactoryWhitespace.factoryWhitespace)(effects, between)(code) : end(code);\n  }\n  /** @type {State} */\n\n\n  function between(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return (0, _micromarkFactoryTitle.factoryTitle)(effects, (0, _micromarkFactoryWhitespace.factoryWhitespace)(effects, end), nok, 'resourceTitle', 'resourceTitleMarker', 'resourceTitleString')(code);\n    }\n\n    return end(code);\n  }\n  /** @type {State} */\n\n\n  function end(code) {\n    if (code === 41) {\n      effects.enter('resourceMarker');\n      effects.consume(code);\n      effects.exit('resourceMarker');\n      effects.exit('resource');\n      return ok;\n    }\n\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeFullReference(effects, ok, nok) {\n  var self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    return _micromarkFactoryLabel.factoryLabel.call(self, effects, afterLabel, nok, 'reference', 'referenceMarker', 'referenceString')(code);\n  }\n  /** @type {State} */\n\n\n  function afterLabel(code) {\n    return self.parser.defined.includes((0, _micromarkUtilNormalizeIdentifier.normalizeIdentifier)(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1))) ? ok(code) : nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeCollapsedReference(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('reference');\n    effects.enter('referenceMarker');\n    effects.consume(code);\n    effects.exit('referenceMarker');\n    return open;\n  }\n  /** @type {State} */\n\n\n  function open(code) {\n    if (code === 93) {\n      effects.enter('referenceMarker');\n      effects.consume(code);\n      effects.exit('referenceMarker');\n      effects.exit('reference');\n      return ok;\n    }\n\n    return nok(code);\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-core-commonmark/lib/label-end.js"
    },
    "{C3B770E0-46C7-45B2-9DDB-59E6FC7EA737}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lineEnding = void 0;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/** @type {Construct} */\nvar lineEnding = {\n  name: 'lineEnding',\n  tokenize: tokenizeLineEnding\n};\n/** @type {Tokenizer} */\n\nexports.lineEnding = lineEnding;\n\nfunction tokenizeLineEnding(effects, ok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('lineEnding');\n    effects.consume(code);\n    effects.exit('lineEnding');\n    return (0, _micromarkFactorySpace.factorySpace)(effects, ok, 'linePrefix');\n  }\n}",
        "mapping": {
            "micromark-factory-space": "{E16A68CD-1DF8-487D-8B5E-693BF7E5E9DF}",
            "micromark-util-character": "{3D577305-9B08-4983-A854-20687E70EB2A}"
        },
        "path": "{remark-parse}/../micromark-core-commonmark/lib/line-ending.js"
    },
    "{E16A68CD-1DF8-487D-8B5E-693BF7E5E9DF}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Effects} Effects\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factorySpace = factorySpace;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {string} type\n * @param {number} [max=Infinity]\n * @returns {State}\n */\nfunction factorySpace(effects, ok, type, max) {\n  var limit = max ? max - 1 : Number.POSITIVE_INFINITY;\n  var size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.enter(type);\n      return prefix(code);\n    }\n\n    return ok(code);\n  }\n  /** @type {State} */\n\n\n  function prefix(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code) && size++ < limit) {\n      effects.consume(code);\n      return prefix;\n    }\n\n    effects.exit(type);\n    return ok(code);\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-factory-space/index.js"
    },
    "{3D577305-9B08-4983-A854-20687E70EB2A}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{EB5C361A-188D-4874-8B96-DB139A77064A}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n* @typedef {import('micromark-util-types').Exiter} Exiter\n* @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n* @typedef {import('micromark-util-types').State} State\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\n/**\n * @typedef {Record<string, unknown> & {marker: Code, type: string, size: number}} ListContainerState\n * @typedef {TokenizeContext & {containerState: ListContainerState}} TokenizeContextWithState\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.list = void 0;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\nvar _blankLine = require(\"./blank-line.js\");\n\nvar _thematicBreak = require(\"./thematic-break.js\");\n\n/** @type {Construct} */\nvar list = {\n  name: 'list',\n  tokenize: tokenizeListStart,\n  continuation: {\n    tokenize: tokenizeListContinuation\n  },\n  exit: tokenizeListEnd\n};\n/** @type {Construct} */\n\nexports.list = list;\nvar listItemPrefixWhitespaceConstruct = {\n  tokenize: tokenizeListItemPrefixWhitespace,\n  partial: true\n};\n/** @type {Construct} */\n\nvar indentConstruct = {\n  tokenize: tokenizeIndent,\n  partial: true\n};\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */\n\nfunction tokenizeListStart(effects, ok, nok) {\n  var self = this;\n  var tail = self.events[self.events.length - 1];\n  var initialSize = tail && tail[1].type === 'linePrefix' ? tail[2].sliceSerialize(tail[1], true).length : 0;\n  var size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    var kind = self.containerState.type || (code === 42 || code === 43 || code === 45 ? 'listUnordered' : 'listOrdered');\n\n    if (kind === 'listUnordered' ? !self.containerState.marker || code === self.containerState.marker : (0, _micromarkUtilCharacter.asciiDigit)(code)) {\n      if (!self.containerState.type) {\n        self.containerState.type = kind;\n        effects.enter(kind, {\n          _container: true\n        });\n      }\n\n      if (kind === 'listUnordered') {\n        effects.enter('listItemPrefix');\n        return code === 42 || code === 45 ? effects.check(_thematicBreak.thematicBreak, nok, atMarker)(code) : atMarker(code);\n      }\n\n      if (!self.interrupt || code === 49) {\n        effects.enter('listItemPrefix');\n        effects.enter('listItemValue');\n        return inside(code);\n      }\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function inside(code) {\n    if ((0, _micromarkUtilCharacter.asciiDigit)(code) && ++size < 10) {\n      effects.consume(code);\n      return inside;\n    }\n\n    if ((!self.interrupt || size < 2) && (self.containerState.marker ? code === self.containerState.marker : code === 41 || code === 46)) {\n      effects.exit('listItemValue');\n      return atMarker(code);\n    }\n\n    return nok(code);\n  }\n  /**\n   * @type {State}\n   **/\n\n\n  function atMarker(code) {\n    effects.enter('listItemMarker');\n    effects.consume(code);\n    effects.exit('listItemMarker');\n    self.containerState.marker = self.containerState.marker || code;\n    return effects.check(_blankLine.blankLine, // Can’t be empty when interrupting.\n    self.interrupt ? nok : onBlank, effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix));\n  }\n  /** @type {State} */\n\n\n  function onBlank(code) {\n    self.containerState.initialBlankLine = true;\n    initialSize++;\n    return endOfPrefix(code);\n  }\n  /** @type {State} */\n\n\n  function otherPrefix(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.enter('listItemPrefixWhitespace');\n      effects.consume(code);\n      effects.exit('listItemPrefixWhitespace');\n      return endOfPrefix;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function endOfPrefix(code) {\n    self.containerState.size = initialSize + self.sliceSerialize(effects.exit('listItemPrefix'), true).length;\n    return ok(code);\n  }\n}\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */\n\n\nfunction tokenizeListContinuation(effects, ok, nok) {\n  var self = this;\n  self.containerState._closeFlow = undefined;\n  return effects.check(_blankLine.blankLine, onBlank, notBlank);\n  /** @type {State} */\n\n  function onBlank(code) {\n    self.containerState.furtherBlankLines = self.containerState.furtherBlankLines || self.containerState.initialBlankLine; // We have a blank line.\n    // Still, try to consume at most the items size.\n\n    return (0, _micromarkFactorySpace.factorySpace)(effects, ok, 'listItemIndent', self.containerState.size + 1)(code);\n  }\n  /** @type {State} */\n\n\n  function notBlank(code) {\n    if (self.containerState.furtherBlankLines || !(0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      self.containerState.furtherBlankLines = undefined;\n      self.containerState.initialBlankLine = undefined;\n      return notInCurrentItem(code);\n    }\n\n    self.containerState.furtherBlankLines = undefined;\n    self.containerState.initialBlankLine = undefined;\n    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code);\n  }\n  /** @type {State} */\n\n\n  function notInCurrentItem(code) {\n    // While we do continue, we signal that the flow should be closed.\n    self.containerState._closeFlow = true; // As we’re closing flow, we’re no longer interrupting.\n\n    self.interrupt = undefined;\n    return (0, _micromarkFactorySpace.factorySpace)(effects, effects.attempt(list, ok, nok), 'linePrefix', self.parser.constructs.disable[\"null\"].includes('codeIndented') ? undefined : 4)(code);\n  }\n}\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */\n\n\nfunction tokenizeIndent(effects, ok, nok) {\n  var self = this;\n  return (0, _micromarkFactorySpace.factorySpace)(effects, afterPrefix, 'listItemIndent', self.containerState.size + 1);\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    var tail = self.events[self.events.length - 1];\n    return tail && tail[1].type === 'listItemIndent' && tail[2].sliceSerialize(tail[1], true).length === self.containerState.size ? ok(code) : nok(code);\n  }\n}\n/**\n * @type {Exiter}\n * @this {TokenizeContextWithState}\n */\n\n\nfunction tokenizeListEnd(effects) {\n  effects.exit(this.containerState.type);\n}\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */\n\n\nfunction tokenizeListItemPrefixWhitespace(effects, ok, nok) {\n  var self = this;\n  return (0, _micromarkFactorySpace.factorySpace)(effects, afterPrefix, 'listItemPrefixWhitespace', self.parser.constructs.disable[\"null\"].includes('codeIndented') ? undefined : 4 + 1);\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    var tail = self.events[self.events.length - 1];\n    return !(0, _micromarkUtilCharacter.markdownSpace)(code) && tail && tail[1].type === 'listItemPrefixWhitespace' ? ok(code) : nok(code);\n  }\n}",
        "mapping": {
            "micromark-factory-space": "{FE22E364-919A-46CA-97AB-1D44C8DA216C}",
            "micromark-util-character": "{34AD529B-B573-4DEB-94CF-97CE676D2425}",
            "./blank-line.js": "{21BEA1F7-46B8-4AF5-A84C-C25E651118F3}",
            "./thematic-break.js": "{1063C6F2-0FEA-4735-84D8-3AFA0E42FDB2}"
        },
        "path": "{remark-parse}/../micromark-core-commonmark/lib/list.js"
    },
    "{FE22E364-919A-46CA-97AB-1D44C8DA216C}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Effects} Effects\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factorySpace = factorySpace;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {string} type\n * @param {number} [max=Infinity]\n * @returns {State}\n */\nfunction factorySpace(effects, ok, type, max) {\n  var limit = max ? max - 1 : Number.POSITIVE_INFINITY;\n  var size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.enter(type);\n      return prefix(code);\n    }\n\n    return ok(code);\n  }\n  /** @type {State} */\n\n\n  function prefix(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code) && size++ < limit) {\n      effects.consume(code);\n      return prefix;\n    }\n\n    effects.exit(type);\n    return ok(code);\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-factory-space/index.js"
    },
    "{34AD529B-B573-4DEB-94CF-97CE676D2425}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{21BEA1F7-46B8-4AF5-A84C-C25E651118F3}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.blankLine = void 0;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/** @type {Construct} */\nvar blankLine = {\n  tokenize: tokenizeBlankLine,\n  partial: true\n};\n/** @type {Tokenizer} */\n\nexports.blankLine = blankLine;\n\nfunction tokenizeBlankLine(effects, ok, nok) {\n  return (0, _micromarkFactorySpace.factorySpace)(effects, afterWhitespace, 'linePrefix');\n  /** @type {State} */\n\n  function afterWhitespace(code) {\n    return code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code) ? ok(code) : nok(code);\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-core-commonmark/lib/blank-line.js"
    },
    "{1063C6F2-0FEA-4735-84D8-3AFA0E42FDB2}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n* @typedef {import('micromark-util-types').State} State\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.thematicBreak = void 0;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/** @type {Construct} */\nvar thematicBreak = {\n  name: 'thematicBreak',\n  tokenize: tokenizeThematicBreak\n};\n/** @type {Tokenizer} */\n\nexports.thematicBreak = thematicBreak;\n\nfunction tokenizeThematicBreak(effects, ok, nok) {\n  var size = 0;\n  /** @type {NonNullable<Code>} */\n\n  var marker;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('thematicBreak');\n    marker = code;\n    return atBreak(code);\n  }\n  /** @type {State} */\n\n\n  function atBreak(code) {\n    if (code === marker) {\n      effects.enter('thematicBreakSequence');\n      return sequence(code);\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      return (0, _micromarkFactorySpace.factorySpace)(effects, atBreak, 'whitespace')(code);\n    }\n\n    if (size < 3 || code !== null && !(0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      return nok(code);\n    }\n\n    effects.exit('thematicBreak');\n    return ok(code);\n  }\n  /** @type {State} */\n\n\n  function sequence(code) {\n    if (code === marker) {\n      effects.consume(code);\n      size++;\n      return sequence;\n    }\n\n    effects.exit('thematicBreakSequence');\n    return atBreak(code);\n  }\n}",
        "mapping": {
            "micromark-factory-space": "{3FC37D41-8721-43C5-BE65-80CB9F381A7D}",
            "micromark-util-character": "{DA9B6414-531F-4523-B908-5C37DAAA0F9F}"
        },
        "path": "{remark-parse}/../micromark-core-commonmark/lib/thematic-break.js"
    },
    "{3FC37D41-8721-43C5-BE65-80CB9F381A7D}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Effects} Effects\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factorySpace = factorySpace;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {string} type\n * @param {number} [max=Infinity]\n * @returns {State}\n */\nfunction factorySpace(effects, ok, type, max) {\n  var limit = max ? max - 1 : Number.POSITIVE_INFINITY;\n  var size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.enter(type);\n      return prefix(code);\n    }\n\n    return ok(code);\n  }\n  /** @type {State} */\n\n\n  function prefix(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code) && size++ < limit) {\n      effects.consume(code);\n      return prefix;\n    }\n\n    effects.exit(type);\n    return ok(code);\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-factory-space/index.js"
    },
    "{DA9B6414-531F-4523-B908-5C37DAAA0F9F}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{A3B1EC3F-0E1E-48B8-B12E-4F17035FCB3E}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').Resolver} Resolver\n* @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n* @typedef {import('micromark-util-types').State} State\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setextUnderline = void 0;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/** @type {Construct} */\nvar setextUnderline = {\n  name: 'setextUnderline',\n  tokenize: tokenizeSetextUnderline,\n  resolveTo: resolveToSetextUnderline\n};\n/** @type {Resolver} */\n\nexports.setextUnderline = setextUnderline;\n\nfunction resolveToSetextUnderline(events, context) {\n  var index = events.length;\n  /** @type {number|undefined} */\n\n  var content;\n  /** @type {number|undefined} */\n\n  var text;\n  /** @type {number|undefined} */\n\n  var definition; // Find the opening of the content.\n  // It’ll always exist: we don’t tokenize if it isn’t there.\n\n  while (index--) {\n    if (events[index][0] === 'enter') {\n      if (events[index][1].type === 'content') {\n        content = index;\n        break;\n      }\n\n      if (events[index][1].type === 'paragraph') {\n        text = index;\n      }\n    } // Exit\n    else {\n      if (events[index][1].type === 'content') {\n        // Remove the content end (if needed we’ll add it later)\n        events.splice(index, 1);\n      }\n\n      if (!definition && events[index][1].type === 'definition') {\n        definition = index;\n      }\n    }\n  }\n\n  var heading = {\n    type: 'setextHeading',\n    start: Object.assign({}, events[text][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }; // Change the paragraph to setext heading text.\n\n  events[text][1].type = 'setextHeadingText'; // If we have definitions in the content, we’ll keep on having content,\n  // but we need move it.\n\n  if (definition) {\n    events.splice(text, 0, ['enter', heading, context]);\n    events.splice(definition + 1, 0, ['exit', events[content][1], context]);\n    events[content][1].end = Object.assign({}, events[definition][1].end);\n  } else {\n    events[content][1] = heading;\n  } // Add the heading exit at the end.\n\n\n  events.push(['exit', heading, context]);\n  return events;\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeSetextUnderline(effects, ok, nok) {\n  var self = this;\n  var index = self.events.length;\n  /** @type {NonNullable<Code>} */\n\n  var marker;\n  /** @type {boolean} */\n\n  var paragraph; // Find an opening.\n\n  while (index--) {\n    // Skip enter/exit of line ending, line prefix, and content.\n    // We can now either have a definition or a paragraph.\n    if (self.events[index][1].type !== 'lineEnding' && self.events[index][1].type !== 'linePrefix' && self.events[index][1].type !== 'content') {\n      paragraph = self.events[index][1].type === 'paragraph';\n      break;\n    }\n  }\n\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {\n      effects.enter('setextHeadingLine');\n      effects.enter('setextHeadingLineSequence');\n      marker = code;\n      return closingSequence(code);\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function closingSequence(code) {\n    if (code === marker) {\n      effects.consume(code);\n      return closingSequence;\n    }\n\n    effects.exit('setextHeadingLineSequence');\n    return (0, _micromarkFactorySpace.factorySpace)(effects, closingSequenceEnd, 'lineSuffix')(code);\n  }\n  /** @type {State} */\n\n\n  function closingSequenceEnd(code) {\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.exit('setextHeadingLine');\n      return ok(code);\n    }\n\n    return nok(code);\n  }\n}",
        "mapping": {
            "micromark-factory-space": "{7AD54633-DF20-41A0-95A6-7A7C61BA8225}",
            "micromark-util-character": "{3F4ED449-9CCC-4C85-82CD-608203B22C25}"
        },
        "path": "{remark-parse}/../micromark-core-commonmark/lib/setext-underline.js"
    },
    "{7AD54633-DF20-41A0-95A6-7A7C61BA8225}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Effects} Effects\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factorySpace = factorySpace;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {string} type\n * @param {number} [max=Infinity]\n * @returns {State}\n */\nfunction factorySpace(effects, ok, type, max) {\n  var limit = max ? max - 1 : Number.POSITIVE_INFINITY;\n  var size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.enter(type);\n      return prefix(code);\n    }\n\n    return ok(code);\n  }\n  /** @type {State} */\n\n\n  function prefix(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code) && size++ < limit) {\n      effects.consume(code);\n      return prefix;\n    }\n\n    effects.exit(type);\n    return ok(code);\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-factory-space/index.js"
    },
    "{3F4ED449-9CCC-4C85-82CD-608203B22C25}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{4652C076-8C94-47B7-8F76-81F1E94A9D65}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n* @typedef {import('micromark-util-types').State} State\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.thematicBreak = void 0;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/** @type {Construct} */\nvar thematicBreak = {\n  name: 'thematicBreak',\n  tokenize: tokenizeThematicBreak\n};\n/** @type {Tokenizer} */\n\nexports.thematicBreak = thematicBreak;\n\nfunction tokenizeThematicBreak(effects, ok, nok) {\n  var size = 0;\n  /** @type {NonNullable<Code>} */\n\n  var marker;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('thematicBreak');\n    marker = code;\n    return atBreak(code);\n  }\n  /** @type {State} */\n\n\n  function atBreak(code) {\n    if (code === marker) {\n      effects.enter('thematicBreakSequence');\n      return sequence(code);\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      return (0, _micromarkFactorySpace.factorySpace)(effects, atBreak, 'whitespace')(code);\n    }\n\n    if (size < 3 || code !== null && !(0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      return nok(code);\n    }\n\n    effects.exit('thematicBreak');\n    return ok(code);\n  }\n  /** @type {State} */\n\n\n  function sequence(code) {\n    if (code === marker) {\n      effects.consume(code);\n      size++;\n      return sequence;\n    }\n\n    effects.exit('thematicBreakSequence');\n    return atBreak(code);\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-core-commonmark/lib/thematic-break.js"
    },
    "{CB6FDCB5-B8E6-43E1-B8FC-5E7AAB4B43CF}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Effects} Effects\n* @typedef {import('micromark-util-types').State} State\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factorySpace = factorySpace;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {string} type\n * @param {number} [max=Infinity]\n * @returns {State}\n */\nfunction factorySpace(effects, ok, type, max) {\n  var limit = max ? max - 1 : Number.POSITIVE_INFINITY;\n  var size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.enter(type);\n      return prefix(code);\n    }\n\n    return ok(code);\n  }\n  /** @type {State} */\n\n\n  function prefix(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code) && size++ < limit) {\n      effects.consume(code);\n      return prefix;\n    }\n\n    effects.exit(type);\n    return ok(code);\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-factory-space/index.js"
    },
    "{F9A71FEF-AC56-4E24-A932-D0518F92A183}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{FF987C0B-BAE7-47F7-AF87-D8CD3501D555}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Resolver} Resolver\n* @typedef {import('micromark-util-types').Initializer} Initializer\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n* @typedef {import('micromark-util-types').State} State\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.text = exports.string = exports.resolver = void 0;\nvar resolver = {\n  resolveAll: createResolver()\n};\nexports.resolver = resolver;\nvar string = initializeFactory('string');\nexports.string = string;\nvar text = initializeFactory('text');\n/**\n * @param {'string'|'text'} field\n * @returns {InitialConstruct}\n */\n\nexports.text = text;\n\nfunction initializeFactory(field) {\n  return {\n    tokenize: initializeText,\n    resolveAll: createResolver(field === 'text' ? resolveAllLineSuffixes : undefined)\n  };\n  /** @type {Initializer} */\n\n  function initializeText(effects) {\n    var self = this;\n    var constructs = this.parser.constructs[field];\n    var text = effects.attempt(constructs, start, notText);\n    return start;\n    /** @type {State} */\n\n    function start(code) {\n      return atBreak(code) ? text(code) : notText(code);\n    }\n    /** @type {State} */\n\n\n    function notText(code) {\n      if (code === null) {\n        effects.consume(code);\n        return;\n      }\n\n      effects.enter('data');\n      effects.consume(code);\n      return data;\n    }\n    /** @type {State} */\n\n\n    function data(code) {\n      if (atBreak(code)) {\n        effects.exit('data');\n        return text(code);\n      } // Data.\n\n\n      effects.consume(code);\n      return data;\n    }\n    /**\n     * @param {Code} code\n     * @returns {boolean}\n     */\n\n\n    function atBreak(code) {\n      if (code === null) {\n        return true;\n      }\n\n      var list = constructs[code];\n      var index = -1;\n\n      if (list) {\n        while (++index < list.length) {\n          var item = list[index];\n\n          if (!item.previous || item.previous.call(self, self.previous)) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n  }\n}\n/**\n * @param {Resolver} [extraResolver]\n * @returns {Resolver}\n */\n\n\nfunction createResolver(extraResolver) {\n  return resolveAllText;\n  /** @type {Resolver} */\n\n  function resolveAllText(events, context) {\n    var index = -1;\n    /** @type {number|undefined} */\n\n    var enter; // A rather boring computation (to merge adjacent `data` events) which\n    // improves mm performance by 29%.\n\n    while (++index <= events.length) {\n      if (enter === undefined) {\n        if (events[index] && events[index][1].type === 'data') {\n          enter = index;\n          index++;\n        }\n      } else if (!events[index] || events[index][1].type !== 'data') {\n        // Don’t do anything if there is one data token.\n        if (index !== enter + 2) {\n          events[enter][1].end = events[index - 1][1].end;\n          events.splice(enter + 2, index - enter - 2);\n          index = enter + 2;\n        }\n\n        enter = undefined;\n      }\n    }\n\n    return extraResolver ? extraResolver(events, context) : events;\n  }\n}\n/**\n * A rather ugly set of instructions which again looks at chunks in the input\n * stream.\n * The reason to do this here is that it is *much* faster to parse in reverse.\n * And that we can’t hook into `null` to split the line suffix before an EOF.\n * To do: figure out if we can make this into a clean utility, or even in core.\n * As it will be useful for GFMs literal autolink extension (and maybe even\n * tables?)\n *\n * @type {Resolver}\n */\n\n\nfunction resolveAllLineSuffixes(events, context) {\n  var eventIndex = 0; // Skip first.\n\n  while (++eventIndex <= events.length) {\n    if ((eventIndex === events.length || events[eventIndex][1].type === 'lineEnding') && events[eventIndex - 1][1].type === 'data') {\n      var data = events[eventIndex - 1][1];\n      var chunks = context.sliceStream(data);\n      var index = chunks.length;\n      var bufferIndex = -1;\n      var size = 0;\n      /** @type {boolean|undefined} */\n\n      var tabs = void 0;\n\n      while (index--) {\n        var chunk = chunks[index];\n\n        if (typeof chunk === 'string') {\n          bufferIndex = chunk.length;\n\n          while (chunk.charCodeAt(bufferIndex - 1) === 32) {\n            size++;\n            bufferIndex--;\n          }\n\n          if (bufferIndex) break;\n          bufferIndex = -1;\n        } // Number\n        else if (chunk === -2) {\n          tabs = true;\n          size++;\n        } else if (chunk === -1) {// Empty\n        } else {\n          // Replacement character, exit.\n          index++;\n          break;\n        }\n      }\n\n      if (size) {\n        var token = {\n          type: eventIndex === events.length || tabs || size < 2 ? 'lineSuffix' : 'hardBreakTrailing',\n          start: {\n            line: data.end.line,\n            column: data.end.column - size,\n            offset: data.end.offset - size,\n            _index: data.start._index + index,\n            _bufferIndex: index ? bufferIndex : data.start._bufferIndex + bufferIndex\n          },\n          end: Object.assign({}, data.end)\n        };\n        data.end = Object.assign({}, token.start);\n\n        if (data.start.offset === data.end.offset) {\n          Object.assign(data, token);\n        } else {\n          events.splice(eventIndex, 0, ['enter', token, context], ['exit', token, context]);\n          eventIndex += 2;\n        }\n      }\n\n      eventIndex++;\n    }\n  }\n\n  return events;\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark/lib/initialize/text.js"
    },
    "{17D6994B-1CC0-41E1-8099-C00E5D33ED1A}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n* @typedef {import('micromark-util-types').Chunk} Chunk\n* @typedef {import('micromark-util-types').Point} Point\n* @typedef {import('micromark-util-types').Token} Token\n* @typedef {import('micromark-util-types').Effects} Effects\n* @typedef {import('micromark-util-types').State} State\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n* @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n* @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n* @typedef {import('micromark-util-types').ParseContext} ParseContext\n*/\n\n/**\n * @typedef Info\n * @property {() => void} restore\n * @property {number} from\n *\n * @callback ReturnHandle\n *   Handle a successful run.\n * @param {Construct} construct\n * @param {Info} info\n * @returns {void}\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createTokenizer = createTokenizer;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\nvar _micromarkUtilChunked = require(\"micromark-util-chunked\");\n\nvar _micromarkUtilResolveAll = require(\"micromark-util-resolve-all\");\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * Create a tokenizer.\n * Tokenizers deal with one type of data (e.g., containers, flow, text).\n * The parser is the object dealing with it all.\n * `initialize` works like other constructs, except that only its `tokenize`\n * function is used, in which case it doesn’t receive an `ok` or `nok`.\n * `from` can be given to set the point before the first character, although\n * when further lines are indented, they must be set with `defineSkip`.\n *\n * @param {ParseContext} parser\n * @param {InitialConstruct} initialize\n * @param {Omit<Point, '_index'|'_bufferIndex'>} [from]\n * @returns {TokenizeContext}\n */\nfunction createTokenizer(parser, initialize, from) {\n  /** @type {Point} */\n  var point = Object.assign(from ? Object.assign({}, from) : {\n    line: 1,\n    column: 1,\n    offset: 0\n  }, {\n    _index: 0,\n    _bufferIndex: -1\n  });\n  /** @type {Record<string, number>} */\n\n  var columnStart = {};\n  /** @type {Construct[]} */\n\n  var resolveAllConstructs = [];\n  /** @type {Chunk[]} */\n\n  var chunks = [];\n  /** @type {Token[]} */\n\n  var stack = [];\n  /** @type {boolean|undefined} */\n\n  var consumed = true;\n  /**\n   * Tools used for tokenizing.\n   *\n   * @type {Effects}\n   */\n\n  var effects = {\n    consume: consume,\n    enter: enter,\n    exit: exit,\n    attempt: constructFactory(onsuccessfulconstruct),\n    check: constructFactory(onsuccessfulcheck),\n    interrupt: constructFactory(onsuccessfulcheck, {\n      interrupt: true\n    })\n  };\n  /**\n   * State and tools for resolving and serializing.\n   *\n   * @type {TokenizeContext}\n   */\n\n  var context = {\n    previous: null,\n    code: null,\n    containerState: {},\n    events: [],\n    parser: parser,\n    sliceStream: sliceStream,\n    sliceSerialize: sliceSerialize,\n    now: now,\n    defineSkip: defineSkip,\n    write: write\n  };\n  /**\n   * The state function.\n   *\n   * @type {State|void}\n   */\n\n  var state = initialize.tokenize.call(context, effects);\n  /**\n   * Track which character we expect to be consumed, to catch bugs.\n   *\n   * @type {Code}\n   */\n\n  var expectedCode;\n\n  if (initialize.resolveAll) {\n    resolveAllConstructs.push(initialize);\n  }\n\n  return context;\n  /** @type {TokenizeContext['write']} */\n\n  function write(slice) {\n    chunks = (0, _micromarkUtilChunked.push)(chunks, slice);\n    main(); // Exit if we’re not done, resolve might change stuff.\n\n    if (chunks[chunks.length - 1] !== null) {\n      return [];\n    }\n\n    addResult(initialize, 0); // Otherwise, resolve, and exit.\n\n    context.events = (0, _micromarkUtilResolveAll.resolveAll)(resolveAllConstructs, context.events, context);\n    return context.events;\n  } //\n  // Tools.\n  //\n\n  /** @type {TokenizeContext['sliceSerialize']} */\n\n\n  function sliceSerialize(token, expandTabs) {\n    return serializeChunks(sliceStream(token), expandTabs);\n  }\n  /** @type {TokenizeContext['sliceStream']} */\n\n\n  function sliceStream(token) {\n    return sliceChunks(chunks, token);\n  }\n  /** @type {TokenizeContext['now']} */\n\n\n  function now() {\n    return Object.assign({}, point);\n  }\n  /** @type {TokenizeContext['defineSkip']} */\n\n\n  function defineSkip(value) {\n    columnStart[value.line] = value.column;\n    accountForPotentialSkip();\n  } //\n  // State management.\n  //\n\n  /**\n   * Main loop (note that `_index` and `_bufferIndex` in `point` are modified by\n   * `consume`).\n   * Here is where we walk through the chunks, which either include strings of\n   * several characters, or numerical character codes.\n   * The reason to do this in a loop instead of a call is so the stack can\n   * drain.\n   *\n   * @returns {void}\n   */\n\n\n  function main() {\n    /** @type {number} */\n    var chunkIndex;\n\n    while (point._index < chunks.length) {\n      var chunk = chunks[point._index]; // If we’re in a buffer chunk, loop through it.\n\n      if (typeof chunk === 'string') {\n        chunkIndex = point._index;\n\n        if (point._bufferIndex < 0) {\n          point._bufferIndex = 0;\n        }\n\n        while (point._index === chunkIndex && point._bufferIndex < chunk.length) {\n          go(chunk.charCodeAt(point._bufferIndex));\n        }\n      } else {\n        go(chunk);\n      }\n    }\n  }\n  /**\n   * Deal with one code.\n   *\n   * @param {Code} code\n   * @returns {void}\n   */\n\n\n  function go(code) {\n    consumed = undefined;\n    expectedCode = code;\n    state = state(code);\n  }\n  /** @type {Effects['consume']} */\n\n\n  function consume(code) {\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      point.line++;\n      point.column = 1;\n      point.offset += code === -3 ? 2 : 1;\n      accountForPotentialSkip();\n    } else if (code !== -1) {\n      point.column++;\n      point.offset++;\n    } // Not in a string chunk.\n\n\n    if (point._bufferIndex < 0) {\n      point._index++;\n    } else {\n      point._bufferIndex++; // At end of string chunk.\n      // @ts-expect-error Points w/ non-negative `_bufferIndex` reference\n      // strings.\n\n      if (point._bufferIndex === chunks[point._index].length) {\n        point._bufferIndex = -1;\n        point._index++;\n      }\n    } // Expose the previous character.\n\n\n    context.previous = code; // Mark as consumed.\n\n    consumed = true;\n  }\n  /** @type {Effects['enter']} */\n\n\n  function enter(type, fields) {\n    /** @type {Token} */\n    // @ts-expect-error Patch instead of assign required fields to help GC.\n    var token = fields || {};\n    token.type = type;\n    token.start = now();\n    context.events.push(['enter', token, context]);\n    stack.push(token);\n    return token;\n  }\n  /** @type {Effects['exit']} */\n\n\n  function exit(type) {\n    var token = stack.pop();\n    token.end = now();\n    context.events.push(['exit', token, context]);\n    return token;\n  }\n  /**\n   * Use results.\n   *\n   * @type {ReturnHandle}\n   */\n\n\n  function onsuccessfulconstruct(construct, info) {\n    addResult(construct, info.from);\n  }\n  /**\n   * Discard results.\n   *\n   * @type {ReturnHandle}\n   */\n\n\n  function onsuccessfulcheck(_, info) {\n    info.restore();\n  }\n  /**\n   * Factory to attempt/check/interrupt.\n   *\n   * @param {ReturnHandle} onreturn\n   * @param {Record<string, unknown>} [fields]\n   */\n\n\n  function constructFactory(onreturn, fields) {\n    return hook;\n    /**\n     * Handle either an object mapping codes to constructs, a list of\n     * constructs, or a single construct.\n     *\n     * @param {Construct|Construct[]|ConstructRecord} constructs\n     * @param {State} returnState\n     * @param {State} [bogusState]\n     * @returns {State}\n     */\n\n    function hook(constructs, returnState, bogusState) {\n      /** @type {Construct[]} */\n      var listOfConstructs;\n      /** @type {number} */\n\n      var constructIndex;\n      /** @type {Construct} */\n\n      var currentConstruct;\n      /** @type {Info} */\n\n      var info;\n      return Array.isArray(constructs) ?\n      /* c8 ignore next 1 */\n      handleListOfConstructs(constructs) : 'tokenize' in constructs // @ts-expect-error Looks like a construct.\n      ? handleListOfConstructs([constructs]) : handleMapOfConstructs(constructs);\n      /**\n       * Handle a list of construct.\n       *\n       * @param {ConstructRecord} map\n       * @returns {State}\n       */\n\n      function handleMapOfConstructs(map) {\n        return start;\n        /** @type {State} */\n\n        function start(code) {\n          var def = code !== null && map[code];\n          var all = code !== null && map[\"null\"];\n          var list = [].concat(_toConsumableArray(Array.isArray(def) ? def : def ? [def] : []), _toConsumableArray(Array.isArray(all) ? all : all ? [all] : []));\n          return handleListOfConstructs(list)(code);\n        }\n      }\n      /**\n       * Handle a list of construct.\n       *\n       * @param {Construct[]} list\n       * @returns {State}\n       */\n\n\n      function handleListOfConstructs(list) {\n        listOfConstructs = list;\n        constructIndex = 0;\n\n        if (list.length === 0) {\n          return bogusState;\n        }\n\n        return handleConstruct(list[constructIndex]);\n      }\n      /**\n       * Handle a single construct.\n       *\n       * @param {Construct} construct\n       * @returns {State}\n       */\n\n\n      function handleConstruct(construct) {\n        return start;\n        /** @type {State} */\n\n        function start(code) {\n          // To do: not needed to store if there is no bogus state, probably?\n          // Currently doesn’t work because `inspect` in document does a check\n          // w/o a bogus, which doesn’t make sense. But it does seem to help perf\n          // by not storing.\n          info = store();\n          currentConstruct = construct;\n\n          if (!construct.partial) {\n            context.currentConstruct = construct;\n          }\n\n          if (construct.name && context.parser.constructs.disable[\"null\"].includes(construct.name)) {\n            return nok(code);\n          }\n\n          return construct.tokenize.call( // If we do have fields, create an object w/ `context` as its\n          // prototype.\n          // This allows a “live binding”, which is needed for `interrupt`.\n          fields ? Object.assign(Object.create(context), fields) : context, effects, ok, nok)(code);\n        }\n      }\n      /** @type {State} */\n\n\n      function ok(code) {\n        consumed = true;\n        onreturn(currentConstruct, info);\n        return returnState;\n      }\n      /** @type {State} */\n\n\n      function nok(code) {\n        consumed = true;\n        info.restore();\n\n        if (++constructIndex < listOfConstructs.length) {\n          return handleConstruct(listOfConstructs[constructIndex]);\n        }\n\n        return bogusState;\n      }\n    }\n  }\n  /**\n   * @param {Construct} construct\n   * @param {number} from\n   * @returns {void}\n   */\n\n\n  function addResult(construct, from) {\n    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {\n      resolveAllConstructs.push(construct);\n    }\n\n    if (construct.resolve) {\n      (0, _micromarkUtilChunked.splice)(context.events, from, context.events.length - from, construct.resolve(context.events.slice(from), context));\n    }\n\n    if (construct.resolveTo) {\n      context.events = construct.resolveTo(context.events, context);\n    }\n  }\n  /**\n   * Store state.\n   *\n   * @returns {Info}\n   */\n\n\n  function store() {\n    var startPoint = now();\n    var startPrevious = context.previous;\n    var startCurrentConstruct = context.currentConstruct;\n    var startEventsIndex = context.events.length;\n    var startStack = Array.from(stack);\n    return {\n      restore: restore,\n      from: startEventsIndex\n    };\n    /**\n     * Restore state.\n     *\n     * @returns {void}\n     */\n\n    function restore() {\n      point = startPoint;\n      context.previous = startPrevious;\n      context.currentConstruct = startCurrentConstruct;\n      context.events.length = startEventsIndex;\n      stack = startStack;\n      accountForPotentialSkip();\n    }\n  }\n  /**\n   * Move the current point a bit forward in the line when it’s on a column\n   * skip.\n   *\n   * @returns {void}\n   */\n\n\n  function accountForPotentialSkip() {\n    if (point.line in columnStart && point.column < 2) {\n      point.column = columnStart[point.line];\n      point.offset += columnStart[point.line] - 1;\n    }\n  }\n}\n/**\n * Get the chunks from a slice of chunks in the range of a token.\n *\n * @param {Chunk[]} chunks\n * @param {Pick<Token, 'start'|'end'>} token\n * @returns {Chunk[]}\n */\n\n\nfunction sliceChunks(chunks, token) {\n  var startIndex = token.start._index;\n  var startBufferIndex = token.start._bufferIndex;\n  var endIndex = token.end._index;\n  var endBufferIndex = token.end._bufferIndex;\n  /** @type {Chunk[]} */\n\n  var view;\n\n  if (startIndex === endIndex) {\n    // @ts-expect-error `_bufferIndex` is used on string chunks.\n    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];\n  } else {\n    view = chunks.slice(startIndex, endIndex);\n\n    if (startBufferIndex > -1) {\n      // @ts-expect-error `_bufferIndex` is used on string chunks.\n      view[0] = view[0].slice(startBufferIndex);\n    }\n\n    if (endBufferIndex > 0) {\n      // @ts-expect-error `_bufferIndex` is used on string chunks.\n      view.push(chunks[endIndex].slice(0, endBufferIndex));\n    }\n  }\n\n  return view;\n}\n/**\n * Get the string value of a slice of chunks.\n *\n * @param {Chunk[]} chunks\n * @param {boolean} [expandTabs=false]\n * @returns {string}\n */\n\n\nfunction serializeChunks(chunks, expandTabs) {\n  var index = -1;\n  /** @type {string[]} */\n\n  var result = [];\n  /** @type {boolean|undefined} */\n\n  var atTab;\n\n  while (++index < chunks.length) {\n    var chunk = chunks[index];\n    /** @type {string} */\n\n    var value = void 0;\n\n    if (typeof chunk === 'string') {\n      value = chunk;\n    } else switch (chunk) {\n      case -5:\n        {\n          value = '\\r';\n          break;\n        }\n\n      case -4:\n        {\n          value = '\\n';\n          break;\n        }\n\n      case -3:\n        {\n          value = '\\r' + '\\n';\n          break;\n        }\n\n      case -2:\n        {\n          value = expandTabs ? ' ' : '\\t';\n          break;\n        }\n\n      case -1:\n        {\n          if (!expandTabs && atTab) continue;\n          value = ' ';\n          break;\n        }\n\n      default:\n        {\n          // Currently only replacement character.\n          value = String.fromCharCode(chunk);\n        }\n    }\n\n    atTab = chunk === -2;\n    result.push(value);\n  }\n\n  return result.join('');\n}",
        "mapping": {
            "micromark-util-character": "{3A0699B4-200A-4C5B-932D-58F8CDEF9804}",
            "micromark-util-chunked": "{949BC73B-A5F3-476B-9399-A011063BDECB}",
            "micromark-util-resolve-all": "{6DDE2C5C-A85A-4A01-8AE7-44569FD34151}"
        },
        "path": "{remark-parse}/../micromark/lib/create-tokenizer.js"
    },
    "{3A0699B4-200A-4C5B-932D-58F8CDEF9804}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asciiAtext = exports.asciiAlphanumeric = exports.asciiAlpha = void 0;\nexports.asciiControl = asciiControl;\nexports.asciiPunctuation = exports.asciiHexDigit = exports.asciiDigit = void 0;\nexports.markdownLineEnding = markdownLineEnding;\nexports.markdownLineEndingOrSpace = markdownLineEndingOrSpace;\nexports.markdownSpace = markdownSpace;\nexports.unicodeWhitespace = exports.unicodePunctuation = void 0;\n\nvar _unicodePunctuationRegex = require(\"./lib/unicode-punctuation-regex.js\");\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexports.asciiAlpha = asciiAlpha;\nvar asciiDigit = regexCheck(/\\d/);\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexports.asciiDigit = asciiDigit;\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexports.asciiHexDigit = asciiHexDigit;\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexports.asciiAlphanumeric = asciiAlphanumeric;\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexports.asciiPunctuation = asciiPunctuation;\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexports.asciiAtext = asciiAtext;\n\nfunction asciiControl(code) {\n  return (// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\n\nvar unicodeWhitespace = regexCheck(/\\s/);\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexports.unicodeWhitespace = unicodeWhitespace;\nvar unicodePunctuation = regexCheck(_unicodePunctuationRegex.unicodePunctuationRegex);\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nexports.unicodePunctuation = unicodePunctuation;\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-character/index.js"
    },
    "{949BC73B-A5F3-476B-9399-A011063BDECB}": {
        "source": "\"use strict\";\n/**\n* Like `Array#splice`, but smarter for giant arrays.\n*\n* `Array#splice` takes all items to be inserted as individual argument which\n* causes a stack overflow in V8 when trying to insert 100k items for instance.\n*\n* Otherwise, this does not return the removed items, and takes `items` as an\n* array instead of rest parameters.\n*\n* @template {unknown} T\n* @param {T[]} list\n* @param {number} start\n* @param {number} remove\n* @param {T[]} items\n* @returns {void}\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.push = push;\nexports.splice = splice;\n\nfunction splice(list, start, remove, items) {\n  var end = list.length;\n  var chunkStart = 0;\n  /** @type {unknown[]} */\n\n  var parameters; // Make start between zero and `end` (included).\n\n  if (start < 0) {\n    start = -start > end ? 0 : end + start;\n  } else {\n    start = start > end ? end : start;\n  }\n\n  remove = remove > 0 ? remove : 0; // No need to chunk the items if there’s only a couple (10k) items.\n\n  if (items.length < 10000) {\n    parameters = Array.from(items);\n    parameters.unshift(start, remove) // @ts-expect-error Hush, it’s fine.\n    ;\n    [].splice.apply(list, parameters);\n  } else {\n    // Delete `remove` items starting from `start`\n    if (remove) [].splice.apply(list, [start, remove]); // Insert the items in chunks to not cause stack overflows.\n\n    while (chunkStart < items.length) {\n      parameters = items.slice(chunkStart, chunkStart + 10000);\n      parameters.unshift(start, 0) // @ts-expect-error Hush, it’s fine.\n      ;\n      [].splice.apply(list, parameters);\n      chunkStart += 10000;\n      start += 10000;\n    }\n  }\n}\n/**\n * Append `items` (an array) at the end of `list` (another array).\n * When `list` was empty, returns `items` instead.\n *\n * This prevents a potentially expensive operation when `list` is empty,\n * and adds items in batches to prevent V8 from hanging.\n *\n * @template {unknown} T\n * @param {T[]} list\n * @param {T[]} items\n * @returns {T[]}\n */\n\n\nfunction push(list, items) {\n  if (list.length > 0) {\n    splice(list, list.length, 0, items);\n    return list;\n  }\n\n  return items;\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-chunked/index.js"
    },
    "{6DDE2C5C-A85A-4A01-8AE7-44569FD34151}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n* @typedef {import('micromark-util-types').Event} Event\n* @typedef {import('micromark-util-types').Resolver} Resolver\n*/\n\n/**\n * Call all `resolveAll`s.\n *\n * @param {{resolveAll?: Resolver}[]} constructs\n * @param {Event[]} events\n * @param {TokenizeContext} context\n * @returns {Event[]}\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveAll = resolveAll;\n\nfunction resolveAll(constructs, events, context) {\n  /** @type {Resolver[]} */\n  var called = [];\n  var index = -1;\n\n  while (++index < constructs.length) {\n    var resolve = constructs[index].resolveAll;\n\n    if (resolve && !called.includes(resolve)) {\n      events = resolve(events, context);\n      called.push(resolve);\n    }\n  }\n\n  return events;\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-resolve-all/index.js"
    },
    "{AA5209E9-0519-40DE-A13F-890C3D505809}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Extension} Extension\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.text = exports.string = exports.insideSpan = exports.flowInitial = exports.flow = exports.document = exports.disable = exports.contentInitial = exports.attentionMarkers = void 0;\n\nvar _micromarkCoreCommonmark = require(\"micromark-core-commonmark\");\n\nvar _text2 = require(\"./initialize/text.js\");\n\nvar _document, _flowInitial, _flow, _string, _text;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/** @type {Extension['document']} */\nvar document = (_document = {}, _defineProperty(_document, 42, _micromarkCoreCommonmark.list), _defineProperty(_document, 43, _micromarkCoreCommonmark.list), _defineProperty(_document, 45, _micromarkCoreCommonmark.list), _defineProperty(_document, 48, _micromarkCoreCommonmark.list), _defineProperty(_document, 49, _micromarkCoreCommonmark.list), _defineProperty(_document, 50, _micromarkCoreCommonmark.list), _defineProperty(_document, 51, _micromarkCoreCommonmark.list), _defineProperty(_document, 52, _micromarkCoreCommonmark.list), _defineProperty(_document, 53, _micromarkCoreCommonmark.list), _defineProperty(_document, 54, _micromarkCoreCommonmark.list), _defineProperty(_document, 55, _micromarkCoreCommonmark.list), _defineProperty(_document, 56, _micromarkCoreCommonmark.list), _defineProperty(_document, 57, _micromarkCoreCommonmark.list), _defineProperty(_document, 62, _micromarkCoreCommonmark.blockQuote), _document);\n/** @type {Extension['contentInitial']} */\n\nexports.document = document;\n\nvar contentInitial = _defineProperty({}, 91, _micromarkCoreCommonmark.definition);\n/** @type {Extension['flowInitial']} */\n\n\nexports.contentInitial = contentInitial;\nvar flowInitial = (_flowInitial = {}, _defineProperty(_flowInitial, -2, _micromarkCoreCommonmark.codeIndented), _defineProperty(_flowInitial, -1, _micromarkCoreCommonmark.codeIndented), _defineProperty(_flowInitial, 32, _micromarkCoreCommonmark.codeIndented), _flowInitial);\n/** @type {Extension['flow']} */\n\nexports.flowInitial = flowInitial;\nvar flow = (_flow = {}, _defineProperty(_flow, 35, _micromarkCoreCommonmark.headingAtx), _defineProperty(_flow, 42, _micromarkCoreCommonmark.thematicBreak), _defineProperty(_flow, 45, [_micromarkCoreCommonmark.setextUnderline, _micromarkCoreCommonmark.thematicBreak]), _defineProperty(_flow, 60, _micromarkCoreCommonmark.htmlFlow), _defineProperty(_flow, 61, _micromarkCoreCommonmark.setextUnderline), _defineProperty(_flow, 95, _micromarkCoreCommonmark.thematicBreak), _defineProperty(_flow, 96, _micromarkCoreCommonmark.codeFenced), _defineProperty(_flow, 126, _micromarkCoreCommonmark.codeFenced), _flow);\n/** @type {Extension['string']} */\n\nexports.flow = flow;\nvar string = (_string = {}, _defineProperty(_string, 38, _micromarkCoreCommonmark.characterReference), _defineProperty(_string, 92, _micromarkCoreCommonmark.characterEscape), _string);\n/** @type {Extension['text']} */\n\nexports.string = string;\nvar text = (_text = {}, _defineProperty(_text, -5, _micromarkCoreCommonmark.lineEnding), _defineProperty(_text, -4, _micromarkCoreCommonmark.lineEnding), _defineProperty(_text, -3, _micromarkCoreCommonmark.lineEnding), _defineProperty(_text, 33, _micromarkCoreCommonmark.labelStartImage), _defineProperty(_text, 38, _micromarkCoreCommonmark.characterReference), _defineProperty(_text, 42, _micromarkCoreCommonmark.attention), _defineProperty(_text, 60, [_micromarkCoreCommonmark.autolink, _micromarkCoreCommonmark.htmlText]), _defineProperty(_text, 91, _micromarkCoreCommonmark.labelStartLink), _defineProperty(_text, 92, [_micromarkCoreCommonmark.hardBreakEscape, _micromarkCoreCommonmark.characterEscape]), _defineProperty(_text, 93, _micromarkCoreCommonmark.labelEnd), _defineProperty(_text, 95, _micromarkCoreCommonmark.attention), _defineProperty(_text, 96, _micromarkCoreCommonmark.codeText), _text);\n/** @type {Extension['insideSpan']} */\n\nexports.text = text;\nvar insideSpan = {\n  \"null\": [_micromarkCoreCommonmark.attention, _text2.resolver]\n};\n/** @type {Extension['attentionMarkers']} */\n\nexports.insideSpan = insideSpan;\nvar attentionMarkers = {\n  \"null\": [42, 95]\n};\n/** @type {Extension['disable']} */\n\nexports.attentionMarkers = attentionMarkers;\nvar disable = {\n  \"null\": []\n};\nexports.disable = disable;",
        "mapping": {
            "micromark-core-commonmark": "{F11A3EA3-CED0-4BFD-ABC8-ECF9E19BC4FD}",
            "./initialize/text.js": "{859C913C-F39C-42D9-8AD7-530A8322210F}"
        },
        "path": "{remark-parse}/../micromark/lib/constructs.js"
    },
    "{F11A3EA3-CED0-4BFD-ABC8-ECF9E19BC4FD}": {
        "source": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"attention\", {\n  enumerable: true,\n  get: function get() {\n    return _attention.attention;\n  }\n});\nObject.defineProperty(exports, \"autolink\", {\n  enumerable: true,\n  get: function get() {\n    return _autolink.autolink;\n  }\n});\nObject.defineProperty(exports, \"blankLine\", {\n  enumerable: true,\n  get: function get() {\n    return _blankLine.blankLine;\n  }\n});\nObject.defineProperty(exports, \"blockQuote\", {\n  enumerable: true,\n  get: function get() {\n    return _blockQuote.blockQuote;\n  }\n});\nObject.defineProperty(exports, \"characterEscape\", {\n  enumerable: true,\n  get: function get() {\n    return _characterEscape.characterEscape;\n  }\n});\nObject.defineProperty(exports, \"characterReference\", {\n  enumerable: true,\n  get: function get() {\n    return _characterReference.characterReference;\n  }\n});\nObject.defineProperty(exports, \"codeFenced\", {\n  enumerable: true,\n  get: function get() {\n    return _codeFenced.codeFenced;\n  }\n});\nObject.defineProperty(exports, \"codeIndented\", {\n  enumerable: true,\n  get: function get() {\n    return _codeIndented.codeIndented;\n  }\n});\nObject.defineProperty(exports, \"codeText\", {\n  enumerable: true,\n  get: function get() {\n    return _codeText.codeText;\n  }\n});\nObject.defineProperty(exports, \"content\", {\n  enumerable: true,\n  get: function get() {\n    return _content.content;\n  }\n});\nObject.defineProperty(exports, \"definition\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.definition;\n  }\n});\nObject.defineProperty(exports, \"hardBreakEscape\", {\n  enumerable: true,\n  get: function get() {\n    return _hardBreakEscape.hardBreakEscape;\n  }\n});\nObject.defineProperty(exports, \"headingAtx\", {\n  enumerable: true,\n  get: function get() {\n    return _headingAtx.headingAtx;\n  }\n});\nObject.defineProperty(exports, \"htmlFlow\", {\n  enumerable: true,\n  get: function get() {\n    return _htmlFlow.htmlFlow;\n  }\n});\nObject.defineProperty(exports, \"htmlText\", {\n  enumerable: true,\n  get: function get() {\n    return _htmlText.htmlText;\n  }\n});\nObject.defineProperty(exports, \"labelEnd\", {\n  enumerable: true,\n  get: function get() {\n    return _labelEnd.labelEnd;\n  }\n});\nObject.defineProperty(exports, \"labelStartImage\", {\n  enumerable: true,\n  get: function get() {\n    return _labelStartImage.labelStartImage;\n  }\n});\nObject.defineProperty(exports, \"labelStartLink\", {\n  enumerable: true,\n  get: function get() {\n    return _labelStartLink.labelStartLink;\n  }\n});\nObject.defineProperty(exports, \"lineEnding\", {\n  enumerable: true,\n  get: function get() {\n    return _lineEnding.lineEnding;\n  }\n});\nObject.defineProperty(exports, \"list\", {\n  enumerable: true,\n  get: function get() {\n    return _list.list;\n  }\n});\nObject.defineProperty(exports, \"setextUnderline\", {\n  enumerable: true,\n  get: function get() {\n    return _setextUnderline.setextUnderline;\n  }\n});\nObject.defineProperty(exports, \"thematicBreak\", {\n  enumerable: true,\n  get: function get() {\n    return _thematicBreak.thematicBreak;\n  }\n});\n\nvar _attention = require(\"./lib/attention.js\");\n\nvar _autolink = require(\"./lib/autolink.js\");\n\nvar _blankLine = require(\"./lib/blank-line.js\");\n\nvar _blockQuote = require(\"./lib/block-quote.js\");\n\nvar _characterEscape = require(\"./lib/character-escape.js\");\n\nvar _characterReference = require(\"./lib/character-reference.js\");\n\nvar _codeFenced = require(\"./lib/code-fenced.js\");\n\nvar _codeIndented = require(\"./lib/code-indented.js\");\n\nvar _codeText = require(\"./lib/code-text.js\");\n\nvar _content = require(\"./lib/content.js\");\n\nvar _definition = require(\"./lib/definition.js\");\n\nvar _hardBreakEscape = require(\"./lib/hard-break-escape.js\");\n\nvar _headingAtx = require(\"./lib/heading-atx.js\");\n\nvar _htmlFlow = require(\"./lib/html-flow.js\");\n\nvar _htmlText = require(\"./lib/html-text.js\");\n\nvar _labelEnd = require(\"./lib/label-end.js\");\n\nvar _labelStartImage = require(\"./lib/label-start-image.js\");\n\nvar _labelStartLink = require(\"./lib/label-start-link.js\");\n\nvar _lineEnding = require(\"./lib/line-ending.js\");\n\nvar _list = require(\"./lib/list.js\");\n\nvar _setextUnderline = require(\"./lib/setext-underline.js\");\n\nvar _thematicBreak = require(\"./lib/thematic-break.js\");",
        "mapping": {},
        "path": "{remark-parse}/../micromark-core-commonmark/index.js"
    },
    "{859C913C-F39C-42D9-8AD7-530A8322210F}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Resolver} Resolver\n* @typedef {import('micromark-util-types').Initializer} Initializer\n* @typedef {import('micromark-util-types').Construct} Construct\n* @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n* @typedef {import('micromark-util-types').State} State\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.text = exports.string = exports.resolver = void 0;\nvar resolver = {\n  resolveAll: createResolver()\n};\nexports.resolver = resolver;\nvar string = initializeFactory('string');\nexports.string = string;\nvar text = initializeFactory('text');\n/**\n * @param {'string'|'text'} field\n * @returns {InitialConstruct}\n */\n\nexports.text = text;\n\nfunction initializeFactory(field) {\n  return {\n    tokenize: initializeText,\n    resolveAll: createResolver(field === 'text' ? resolveAllLineSuffixes : undefined)\n  };\n  /** @type {Initializer} */\n\n  function initializeText(effects) {\n    var self = this;\n    var constructs = this.parser.constructs[field];\n    var text = effects.attempt(constructs, start, notText);\n    return start;\n    /** @type {State} */\n\n    function start(code) {\n      return atBreak(code) ? text(code) : notText(code);\n    }\n    /** @type {State} */\n\n\n    function notText(code) {\n      if (code === null) {\n        effects.consume(code);\n        return;\n      }\n\n      effects.enter('data');\n      effects.consume(code);\n      return data;\n    }\n    /** @type {State} */\n\n\n    function data(code) {\n      if (atBreak(code)) {\n        effects.exit('data');\n        return text(code);\n      } // Data.\n\n\n      effects.consume(code);\n      return data;\n    }\n    /**\n     * @param {Code} code\n     * @returns {boolean}\n     */\n\n\n    function atBreak(code) {\n      if (code === null) {\n        return true;\n      }\n\n      var list = constructs[code];\n      var index = -1;\n\n      if (list) {\n        while (++index < list.length) {\n          var item = list[index];\n\n          if (!item.previous || item.previous.call(self, self.previous)) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n  }\n}\n/**\n * @param {Resolver} [extraResolver]\n * @returns {Resolver}\n */\n\n\nfunction createResolver(extraResolver) {\n  return resolveAllText;\n  /** @type {Resolver} */\n\n  function resolveAllText(events, context) {\n    var index = -1;\n    /** @type {number|undefined} */\n\n    var enter; // A rather boring computation (to merge adjacent `data` events) which\n    // improves mm performance by 29%.\n\n    while (++index <= events.length) {\n      if (enter === undefined) {\n        if (events[index] && events[index][1].type === 'data') {\n          enter = index;\n          index++;\n        }\n      } else if (!events[index] || events[index][1].type !== 'data') {\n        // Don’t do anything if there is one data token.\n        if (index !== enter + 2) {\n          events[enter][1].end = events[index - 1][1].end;\n          events.splice(enter + 2, index - enter - 2);\n          index = enter + 2;\n        }\n\n        enter = undefined;\n      }\n    }\n\n    return extraResolver ? extraResolver(events, context) : events;\n  }\n}\n/**\n * A rather ugly set of instructions which again looks at chunks in the input\n * stream.\n * The reason to do this here is that it is *much* faster to parse in reverse.\n * And that we can’t hook into `null` to split the line suffix before an EOF.\n * To do: figure out if we can make this into a clean utility, or even in core.\n * As it will be useful for GFMs literal autolink extension (and maybe even\n * tables?)\n *\n * @type {Resolver}\n */\n\n\nfunction resolveAllLineSuffixes(events, context) {\n  var eventIndex = 0; // Skip first.\n\n  while (++eventIndex <= events.length) {\n    if ((eventIndex === events.length || events[eventIndex][1].type === 'lineEnding') && events[eventIndex - 1][1].type === 'data') {\n      var data = events[eventIndex - 1][1];\n      var chunks = context.sliceStream(data);\n      var index = chunks.length;\n      var bufferIndex = -1;\n      var size = 0;\n      /** @type {boolean|undefined} */\n\n      var tabs = void 0;\n\n      while (index--) {\n        var chunk = chunks[index];\n\n        if (typeof chunk === 'string') {\n          bufferIndex = chunk.length;\n\n          while (chunk.charCodeAt(bufferIndex - 1) === 32) {\n            size++;\n            bufferIndex--;\n          }\n\n          if (bufferIndex) break;\n          bufferIndex = -1;\n        } // Number\n        else if (chunk === -2) {\n          tabs = true;\n          size++;\n        } else if (chunk === -1) {// Empty\n        } else {\n          // Replacement character, exit.\n          index++;\n          break;\n        }\n      }\n\n      if (size) {\n        var token = {\n          type: eventIndex === events.length || tabs || size < 2 ? 'lineSuffix' : 'hardBreakTrailing',\n          start: {\n            line: data.end.line,\n            column: data.end.column - size,\n            offset: data.end.offset - size,\n            _index: data.start._index + index,\n            _bufferIndex: index ? bufferIndex : data.start._bufferIndex + bufferIndex\n          },\n          end: Object.assign({}, data.end)\n        };\n        data.end = Object.assign({}, token.start);\n\n        if (data.start.offset === data.end.offset) {\n          Object.assign(data, token);\n        } else {\n          events.splice(eventIndex, 0, ['enter', token, context], ['exit', token, context]);\n          eventIndex += 2;\n        }\n      }\n\n      eventIndex++;\n    }\n  }\n\n  return events;\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark/lib/initialize/text.js"
    },
    "{32A054D9-B22D-47BD-9453-523697AC14DE}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Encoding} Encoding\n* @typedef {import('micromark-util-types').Value} Value\n* @typedef {import('micromark-util-types').Chunk} Chunk\n* @typedef {import('micromark-util-types').Code} Code\n*/\n\n/**\n * @callback Preprocessor\n * @param {Value} value\n * @param {Encoding} [encoding]\n * @param {boolean} [end=false]\n * @returns {Chunk[]}\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.preprocess = preprocess;\nvar search = /[\\0\\t\\n\\r]/g;\n/**\n * @returns {Preprocessor}\n */\n\nfunction preprocess() {\n  var column = 1;\n  var buffer = '';\n  /** @type {boolean|undefined} */\n\n  var start = true;\n  /** @type {boolean|undefined} */\n\n  var atCarriageReturn;\n  return preprocessor;\n  /** @type {Preprocessor} */\n\n  function preprocessor(value, encoding, end) {\n    /** @type {Chunk[]} */\n    var chunks = [];\n    /** @type {RegExpMatchArray|null} */\n\n    var match;\n    /** @type {number} */\n\n    var next;\n    /** @type {number} */\n\n    var startPosition;\n    /** @type {number} */\n\n    var endPosition;\n    /** @type {Code} */\n\n    var code; // @ts-expect-error `Buffer` does allow an encoding.\n\n    value = buffer + value.toString(encoding);\n    startPosition = 0;\n    buffer = '';\n\n    if (start) {\n      if (value.charCodeAt(0) === 65279) {\n        startPosition++;\n      }\n\n      start = undefined;\n    }\n\n    while (startPosition < value.length) {\n      search.lastIndex = startPosition;\n      match = search.exec(value);\n      endPosition = match && match.index !== undefined ? match.index : value.length;\n      code = value.charCodeAt(endPosition);\n\n      if (!match) {\n        buffer = value.slice(startPosition);\n        break;\n      }\n\n      if (code === 10 && startPosition === endPosition && atCarriageReturn) {\n        chunks.push(-3);\n        atCarriageReturn = undefined;\n      } else {\n        if (atCarriageReturn) {\n          chunks.push(-5);\n          atCarriageReturn = undefined;\n        }\n\n        if (startPosition < endPosition) {\n          chunks.push(value.slice(startPosition, endPosition));\n          column += endPosition - startPosition;\n        }\n\n        switch (code) {\n          case 0:\n            {\n              chunks.push(65533);\n              column++;\n              break;\n            }\n\n          case 9:\n            {\n              next = Math.ceil(column / 4) * 4;\n              chunks.push(-2);\n\n              while (column++ < next) {\n                chunks.push(-1);\n              }\n\n              break;\n            }\n\n          case 10:\n            {\n              chunks.push(-4);\n              column = 1;\n              break;\n            }\n\n          default:\n            {\n              atCarriageReturn = true;\n              column = 1;\n            }\n        }\n      }\n\n      startPosition = endPosition + 1;\n    }\n\n    if (end) {\n      if (atCarriageReturn) chunks.push(-5);\n      if (buffer) chunks.push(buffer);\n      chunks.push(null);\n    }\n\n    return chunks;\n  }\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark/lib/preprocess.js"
    },
    "{52F31653-675A-4073-A033-71D7A003E18C}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Event} Event\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.postprocess = postprocess;\n\nvar _micromarkUtilSubtokenize = require(\"micromark-util-subtokenize\");\n\n/**\n * @param {Event[]} events\n * @returns {Event[]}\n */\nfunction postprocess(events) {\n  while (!(0, _micromarkUtilSubtokenize.subtokenize)(events)) {// Empty\n  }\n\n  return events;\n}",
        "mapping": {
            "micromark-util-subtokenize": "{8528A6EB-7A94-4F89-8A16-12411560D05E}"
        },
        "path": "{remark-parse}/../micromark/lib/postprocess.js"
    },
    "{8528A6EB-7A94-4F89-8A16-12411560D05E}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('micromark-util-types').Token} Token\n* @typedef {import('micromark-util-types').Chunk} Chunk\n* @typedef {import('micromark-util-types').Event} Event\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.subtokenize = subtokenize;\n\nvar _micromarkUtilChunked = require(\"micromark-util-chunked\");\n\n/**\n * Tokenize subcontent.\n *\n * @param {Event[]} events\n * @returns {boolean}\n */\nfunction subtokenize(events) {\n  /** @type {Record<string, number>} */\n  var jumps = {};\n  var index = -1;\n  /** @type {Event} */\n\n  var event;\n  /** @type {number|undefined} */\n\n  var lineIndex;\n  /** @type {number} */\n\n  var otherIndex;\n  /** @type {Event} */\n\n  var otherEvent;\n  /** @type {Event[]} */\n\n  var parameters;\n  /** @type {Event[]} */\n\n  var subevents;\n  /** @type {boolean|undefined} */\n\n  var more;\n\n  while (++index < events.length) {\n    while (index in jumps) {\n      index = jumps[index];\n    }\n\n    event = events[index]; // Add a hook for the GFM tasklist extension, which needs to know if text\n    // is in the first content of a list item.\n\n    if (index && event[1].type === 'chunkFlow' && events[index - 1][1].type === 'listItemPrefix') {\n      subevents = event[1]._tokenizer.events;\n      otherIndex = 0;\n\n      if (otherIndex < subevents.length && subevents[otherIndex][1].type === 'lineEndingBlank') {\n        otherIndex += 2;\n      }\n\n      if (otherIndex < subevents.length && subevents[otherIndex][1].type === 'content') {\n        while (++otherIndex < subevents.length) {\n          if (subevents[otherIndex][1].type === 'content') {\n            break;\n          }\n\n          if (subevents[otherIndex][1].type === 'chunkText') {\n            subevents[otherIndex][1]._isInFirstContentOfListItem = true;\n            otherIndex++;\n          }\n        }\n      }\n    } // Enter.\n\n\n    if (event[0] === 'enter') {\n      if (event[1].contentType) {\n        Object.assign(jumps, subcontent(events, index));\n        index = jumps[index];\n        more = true;\n      }\n    } // Exit.\n    else if (event[1]._container) {\n      otherIndex = index;\n      lineIndex = undefined;\n\n      while (otherIndex--) {\n        otherEvent = events[otherIndex];\n\n        if (otherEvent[1].type === 'lineEnding' || otherEvent[1].type === 'lineEndingBlank') {\n          if (otherEvent[0] === 'enter') {\n            if (lineIndex) {\n              events[lineIndex][1].type = 'lineEndingBlank';\n            }\n\n            otherEvent[1].type = 'lineEnding';\n            lineIndex = otherIndex;\n          }\n        } else {\n          break;\n        }\n      }\n\n      if (lineIndex) {\n        // Fix position.\n        event[1].end = Object.assign({}, events[lineIndex][1].start); // Switch container exit w/ line endings.\n\n        parameters = events.slice(lineIndex, index);\n        parameters.unshift(event);\n        (0, _micromarkUtilChunked.splice)(events, lineIndex, index - lineIndex + 1, parameters);\n      }\n    }\n  }\n\n  return !more;\n}\n/**\n * Tokenize embedded tokens.\n *\n * @param {Event[]} events\n * @param {number} eventIndex\n * @returns {Record<string, number>}\n */\n\n\nfunction subcontent(events, eventIndex) {\n  var token = events[eventIndex][1];\n  var context = events[eventIndex][2];\n  var startPosition = eventIndex - 1;\n  /** @type {number[]} */\n\n  var startPositions = [];\n  var tokenizer = token._tokenizer || context.parser[token.contentType](token.start);\n  var childEvents = tokenizer.events;\n  /** @type {[number, number][]} */\n\n  var jumps = [];\n  /** @type {Record<string, number>} */\n\n  var gaps = {};\n  /** @type {Chunk[]} */\n\n  var stream;\n  /** @type {Token|undefined} */\n\n  var previous;\n  var index = -1;\n  /** @type {Token|undefined} */\n\n  var current = token;\n  var adjust = 0;\n  var start = 0;\n  var breaks = [start]; // Loop forward through the linked tokens to pass them in order to the\n  // subtokenizer.\n\n  while (current) {\n    // Find the position of the event for this token.\n    while (events[++startPosition][1] !== current) {// Empty.\n    }\n\n    startPositions.push(startPosition);\n\n    if (!current._tokenizer) {\n      stream = context.sliceStream(current);\n\n      if (!current.next) {\n        stream.push(null);\n      }\n\n      if (previous) {\n        tokenizer.defineSkip(current.start);\n      }\n\n      if (current._isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = true;\n      }\n\n      tokenizer.write(stream);\n\n      if (current._isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = undefined;\n      }\n    } // Unravel the next token.\n\n\n    previous = current;\n    current = current.next;\n  } // Now, loop back through all events (and linked tokens), to figure out which\n  // parts belong where.\n\n\n  current = token;\n\n  while (++index < childEvents.length) {\n    if ( // Find a void token that includes a break.\n    childEvents[index][0] === 'exit' && childEvents[index - 1][0] === 'enter' && childEvents[index][1].type === childEvents[index - 1][1].type && childEvents[index][1].start.line !== childEvents[index][1].end.line) {\n      start = index + 1;\n      breaks.push(start); // Help GC.\n\n      current._tokenizer = undefined;\n      current.previous = undefined;\n      current = current.next;\n    }\n  } // Help GC.\n\n\n  tokenizer.events = []; // If there’s one more token (which is the cases for lines that end in an\n  // EOF), that’s perfect: the last point we found starts it.\n  // If there isn’t then make sure any remaining content is added to it.\n\n  if (current) {\n    // Help GC.\n    current._tokenizer = undefined;\n    current.previous = undefined;\n  } else {\n    breaks.pop();\n  } // Now splice the events from the subtokenizer into the current events,\n  // moving back to front so that splice indices aren’t affected.\n\n\n  index = breaks.length;\n\n  while (index--) {\n    var slice = childEvents.slice(breaks[index], breaks[index + 1]);\n\n    var _start = startPositions.pop();\n\n    jumps.unshift([_start, _start + slice.length - 1]);\n    (0, _micromarkUtilChunked.splice)(events, _start, 2, slice);\n  }\n\n  index = -1;\n\n  while (++index < jumps.length) {\n    gaps[adjust + jumps[index][0]] = adjust + jumps[index][1];\n    adjust += jumps[index][1] - jumps[index][0] - 1;\n  }\n\n  return gaps;\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-subtokenize/index.js"
    },
    "{BCC305A4-BFB3-45F1-BFB8-CDDC7CDB946A}": {
        "source": "\"use strict\";\n/**\n* Turn the number (in string form as either hexa- or plain decimal) coming from\n* a numeric character reference into a character.\n*\n* @param {string} value\n*   Value to decode.\n* @param {number} base\n*   Numeric base.\n* @returns {string}\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeNumericCharacterReference = decodeNumericCharacterReference;\n\nfunction decodeNumericCharacterReference(value, base) {\n  var code = Number.parseInt(value, base);\n\n  if ( // C0 except for HT, LF, FF, CR, space\n  code < 9 || code === 11 || code > 13 && code < 32 || // Control character (DEL) of the basic block and C1 controls.\n  code > 126 && code < 160 || // Lone high surrogates and low surrogates.\n  code > 55295 && code < 57344 || // Noncharacters.\n  code > 64975 && code < 65008 || (code & 65535) === 65535 || (code & 65535) === 65534 || // Out of range\n  code > 1114111) {\n    return \"\\uFFFD\";\n  }\n\n  return String.fromCharCode(code);\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-decode-numeric-character-reference/index.js"
    },
    "{AC9460D6-4D8A-4AAE-BC63-C5A4EBB5443E}": {
        "source": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeString = decodeString;\n\nvar _decodeNamedCharacterReference = require(\"decode-named-character-reference\");\n\nvar _micromarkUtilDecodeNumericCharacterReference = require(\"micromark-util-decode-numeric-character-reference\");\n\nvar characterEscapeOrReference = /\\\\([!-/:-@[-`{-~])|&(#(?:\\d{1,7}|x[\\da-f]{1,6})|[\\da-z]{1,31});/gi;\n/**\n * Utility to decode markdown strings (which occur in places such as fenced\n * code info strings, destinations, labels, and titles).\n * The “string” content type allows character escapes and -references.\n * This decodes those.\n *\n * @param {string} value\n * @returns {string}\n */\n\nfunction decodeString(value) {\n  return value.replace(characterEscapeOrReference, decode);\n}\n/**\n * @param {string} $0\n * @param {string} $1\n * @param {string} $2\n * @returns {string}\n */\n\n\nfunction decode($0, $1, $2) {\n  if ($1) {\n    // Escape.\n    return $1;\n  } // Reference.\n\n\n  var head = $2.charCodeAt(0);\n\n  if (head === 35) {\n    var _head = $2.charCodeAt(1);\n\n    var hex = _head === 120 || _head === 88;\n    return (0, _micromarkUtilDecodeNumericCharacterReference.decodeNumericCharacterReference)($2.slice(hex ? 2 : 1), hex ? 16 : 10);\n  }\n\n  return (0, _decodeNamedCharacterReference.decodeNamedCharacterReference)($2) || $0;\n}",
        "mapping": {
            "decode-named-character-reference": "{6100E0C4-3717-4D90-A147-F48938380B3A}",
            "micromark-util-decode-numeric-character-reference": "{A2E35B64-8052-48D3-9917-E95098141812}"
        },
        "path": "{remark-parse}/../micromark-util-decode-string/index.js"
    },
    "{6100E0C4-3717-4D90-A147-F48938380B3A}": {
        "source": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeNamedCharacterReference = decodeNamedCharacterReference;\n\nvar _characterEntities = require(\"character-entities\");\n\nvar own = {}.hasOwnProperty;\n/**\n * Decode a single character reference (without the `&` or `;`).\n * You probably only need this when you’re building parsers yourself that follow\n * different rules compared to HTML.\n * This is optimized to be tiny in browsers.\n *\n * @param {string} value\n *   `notin` (named), `#123` (deci), `#x123` (hexa).\n * @returns {string|false}\n *   Decoded reference.\n */\n\nfunction decodeNamedCharacterReference(value) {\n  return own.call(_characterEntities.characterEntities, value) ? _characterEntities.characterEntities[value] : false;\n}",
        "mapping": {},
        "path": "{remark-parse}/../decode-named-character-reference/index.js"
    },
    "{A2E35B64-8052-48D3-9917-E95098141812}": {
        "source": "\"use strict\";\n/**\n* Turn the number (in string form as either hexa- or plain decimal) coming from\n* a numeric character reference into a character.\n*\n* @param {string} value\n*   Value to decode.\n* @param {number} base\n*   Numeric base.\n* @returns {string}\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeNumericCharacterReference = decodeNumericCharacterReference;\n\nfunction decodeNumericCharacterReference(value, base) {\n  var code = Number.parseInt(value, base);\n\n  if ( // C0 except for HT, LF, FF, CR, space\n  code < 9 || code === 11 || code > 13 && code < 32 || // Control character (DEL) of the basic block and C1 controls.\n  code > 126 && code < 160 || // Lone high surrogates and low surrogates.\n  code > 55295 && code < 57344 || // Noncharacters.\n  code > 64975 && code < 65008 || (code & 65535) === 65535 || (code & 65535) === 65534 || // Out of range\n  code > 1114111) {\n    return \"\\uFFFD\";\n  }\n\n  return String.fromCharCode(code);\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-decode-numeric-character-reference/index.js"
    },
    "{2DCCC183-8747-4B15-B12E-8E8EF1049A0C}": {
        "source": "\"use strict\";\n/**\n* Normalize an identifier (such as used in definitions).\n*\n* @param {string} value\n* @returns {string}\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.normalizeIdentifier = normalizeIdentifier;\n\nfunction normalizeIdentifier(value) {\n  return value // Collapse Markdown whitespace.\n  .replace(/[\\t\\n\\r ]+/g, ' ') // Trim.\n  .replace(/^ | $/g, '') // Some characters are considered “uppercase”, but if their lowercase\n  // counterpart is uppercased will result in a different uppercase\n  // character.\n  // Hence, to get that form, we perform both lower- and uppercase.\n  // Upper case makes sure keys will not interact with default prototypal\n  // methods: no method is uppercase.\n  .toLowerCase().toUpperCase();\n}",
        "mapping": {},
        "path": "{remark-parse}/../micromark-util-normalize-identifier/index.js"
    },
    "{51DC88FA-8373-443C-BAA0-8A2EC6E4B846}": {
        "source": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeNamedCharacterReference = decodeNamedCharacterReference;\n\nvar _characterEntities = require(\"character-entities\");\n\nvar own = {}.hasOwnProperty;\n/**\n * Decode a single character reference (without the `&` or `;`).\n * You probably only need this when you’re building parsers yourself that follow\n * different rules compared to HTML.\n * This is optimized to be tiny in browsers.\n *\n * @param {string} value\n *   `notin` (named), `#123` (deci), `#x123` (hexa).\n * @returns {string|false}\n *   Decoded reference.\n */\n\nfunction decodeNamedCharacterReference(value) {\n  return own.call(_characterEntities.characterEntities, value) ? _characterEntities.characterEntities[value] : false;\n}",
        "mapping": {},
        "path": "{remark-parse}/../decode-named-character-reference/index.js"
    },
    "{46A6F8FD-1366-4C78-B2BA-4EA6C61C83F5}": {
        "source": "\"use strict\";\n/**\n* @typedef {import('unist').Point} Point\n* @typedef {import('unist').Node} Node\n* @typedef {import('unist').Position} Position\n* @typedef {object & {type: string, position?: Position|undefined}} NodeLike\n*/\n\n/**\n * Stringify one point, a position (start and end points), or a node’s\n * positional information.\n *\n * @param {Node|NodeLike|Position|Point|null} [value]\n * @returns {string}\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stringifyPosition = stringifyPosition;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction stringifyPosition(value) {\n  // Nothing.\n  if (!value || _typeof(value) !== 'object') {\n    return '';\n  } // Node.\n\n\n  if ('position' in value || 'type' in value) {\n    return position(value.position);\n  } // Position.\n\n\n  if ('start' in value || 'end' in value) {\n    return position(value);\n  } // Point.\n\n\n  if ('line' in value || 'column' in value) {\n    return point(value);\n  } // ?\n\n\n  return '';\n}\n/**\n * @param {Point|undefined} point\n * @returns {string}\n */\n\n\nfunction point(point) {\n  return index(point && point.line) + ':' + index(point && point.column);\n}\n/**\n * @param {Position|undefined} pos\n * @returns {string}\n */\n\n\nfunction position(pos) {\n  return point(pos && pos.start) + '-' + point(pos && pos.end);\n}\n/**\n * @param {number|undefined} value\n * @returns {number}\n */\n\n\nfunction index(value) {\n  return value && typeof value === 'number' ? value : 1;\n}",
        "mapping": {},
        "path": "{remark-parse}/../unist-util-stringify-position/index.js"
    },
    "{A12BE05F-8E74-4A4B-B342-A9EB4037B1C4}": {
        "source": "{\n  \"_from\": \"remark-parse@^10.0.1\",\n  \"_id\": \"remark-parse@10.0.1\",\n  \"_inBundle\": false,\n  \"_integrity\": \"sha512-1fUyHr2jLsVOkhbvPRBJ5zTKZZyD6yZzYaWCS6BPBdQ8vEMBCH+9zNCDA6tET/zHCi/jLqjCWtlJZUPk+DbnFw==\",\n  \"_location\": \"/remark-parse\",\n  \"_phantomChildren\": {},\n  \"_requested\": {\n    \"type\": \"range\",\n    \"registry\": true,\n    \"raw\": \"remark-parse@^10.0.1\",\n    \"name\": \"remark-parse\",\n    \"escapedName\": \"remark-parse\",\n    \"rawSpec\": \"^10.0.1\",\n    \"saveSpec\": null,\n    \"fetchSpec\": \"^10.0.1\"\n  },\n  \"_requiredBy\": [\n    \"/\"\n  ],\n  \"_resolved\": \"https://registry.npmjs.org/remark-parse/-/remark-parse-10.0.1.tgz\",\n  \"_shasum\": \"6f60ae53edbf0cf38ea223fe643db64d112e0775\",\n  \"_spec\": \"remark-parse@^10.0.1\",\n  \"_where\": \"C:\\\\bin\\\\github\\\\monorepo\",\n  \"author\": {\n    \"name\": \"Titus Wormer\",\n    \"email\": \"tituswormer@gmail.com\",\n    \"url\": \"https://wooorm.com\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/remarkjs/remark/issues\"\n  },\n  \"bundleDependencies\": false,\n  \"contributors\": [\n    {\n      \"name\": \"Titus Wormer\",\n      \"email\": \"tituswormer@gmail.com\",\n      \"url\": \"https://wooorm.com\"\n    },\n    {\n      \"name\": \"Eugene Sharygin\",\n      \"email\": \"eush77@gmail.com\"\n    },\n    {\n      \"name\": \"Junyoung Choi\",\n      \"email\": \"fluke8259@gmail.com\"\n    },\n    {\n      \"name\": \"Elijah Hamovitz\",\n      \"email\": \"elijahhamovitz@gmail.com\"\n    },\n    {\n      \"name\": \"Ika\",\n      \"email\": \"ikatyang@gmail.com\"\n    }\n  ],\n  \"dependencies\": {\n    \"@types/mdast\": \"^3.0.0\",\n    \"mdast-util-from-markdown\": \"^1.0.0\",\n    \"unified\": \"^10.0.0\"\n  },\n  \"deprecated\": false,\n  \"description\": \"remark plugin to add support for parsing markdown input\",\n  \"files\": [\n    \"lib/\",\n    \"index.d.ts\",\n    \"index.js\"\n  ],\n  \"funding\": {\n    \"type\": \"opencollective\",\n    \"url\": \"https://opencollective.com/unified\"\n  },\n  \"homepage\": \"https://remark.js.org\",\n  \"keywords\": [\n    \"unified\",\n    \"remark\",\n    \"remark-plugin\",\n    \"plugin\",\n    \"markdown\",\n    \"mdast\",\n    \"abstract\",\n    \"syntax\",\n    \"tree\",\n    \"ast\",\n    \"parse\"\n  ],\n  \"license\": \"MIT\",\n  \"main\": \"index.js\",\n  \"name\": \"remark-parse\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/remarkjs/remark/tree/main/packages/remark-parse\"\n  },\n  \"scripts\": {\n    \"build\": \"rimraf \\\"test.d.ts\\\" \\\"lib/**/*.d.ts\\\" && tsc && type-coverage\",\n    \"test\": \"node --conditions development test.js\"\n  },\n  \"sideEffects\": false,\n  \"type\": \"module\",\n  \"typeCoverage\": {\n    \"atLeast\": 100,\n    \"detail\": true,\n    \"strict\": true,\n    \"ignoreCatch\": true\n  },\n  \"types\": \"index.d.ts\",\n  \"version\": \"10.0.1\",\n  \"xo\": false\n}\n",
        "path": "{remark-parse}/package.json"
    }
}